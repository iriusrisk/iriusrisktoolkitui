#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri Dec 14 09:45:47 2018 by generateDS.py version 2.30.8.
# Python 3.6.7 (default, Oct 22 2018, 11:32:17)  [GCC 8.2.0]
#
# Command line options:
#   ('-f', '')
#   ('-o', 'sample_lib.py')
#   ('--member-specs', 'dict')
#
# Command line arguments:
#   library.xsd
#
# Command line:
#   ../PygenerateDS/generateDS.py -f -o "sample_lib.py" --member-specs="dict" library.xsd
#
# Current working directory (os.getcwd()):
#   genLibXLS2XML
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class libraryType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'revision': MemberSpec_('revision', 'xs:integer', 0, 0, {'use': 'required'}),
        'type_': MemberSpec_('type_', 'xs:string', 0, 0, {'use': 'required'}),
        'status': MemberSpec_('status', 'xs:string', 0, 0, {'use': 'required'}),
        'enabled': MemberSpec_('enabled', 'xs:boolean', 0, 0, {'use': 'required'}),
        'priority': MemberSpec_('priority', 'xs:string', 0, 0, {'use': 'required'}),
        'tags': MemberSpec_('tags', 'xs:string', 0, 0, {'use': 'required'}),
        'workflowState': MemberSpec_('workflowState', 'xs:string', 0, 1, {'use': 'optional'}),
        'desc': MemberSpec_('desc', 'xs:string', 0, 0, {'type': 'xs:string', 'name': 'desc'}, None),
        'categoryComponents': MemberSpec_('categoryComponents', 'categoryComponentsType', 0, 0, {'type': 'categoryComponentsType', 'name': 'categoryComponents'}, None),
        'componentDefinitions': MemberSpec_('componentDefinitions', 'componentDefinitionsType', 0, 0, {'type': 'componentDefinitionsType', 'name': 'componentDefinitions'}, None),
        'udts': MemberSpec_('udts', 'udtsType', 0, 1, {'type': 'udtsType', 'name': 'udts', 'minOccurs': '0'}, None),
        'dataflows': MemberSpec_('dataflows', 'dataflowsType', 0, 1, {'type': 'dataflowsType', 'name': 'dataflows', 'minOccurs': '0'}, None),
        'supportedStandards': MemberSpec_('supportedStandards', 'supportedStandardsType', 0, 0, {'type': 'supportedStandardsType', 'name': 'supportedStandards'}, None),
        'components': MemberSpec_('components', 'componentsLibraryType', 0, 0, {'type': 'componentsLibraryType', 'name': 'components'}, None),
        'rules': MemberSpec_('rules', 'rulesType', 0, 0, {'type': 'rulesType', 'name': 'rules'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, name=None, revision=None, type_=None, status=None, enabled=None, priority=None, tags=None, workflowState=None, desc=None, categoryComponents=None, componentDefinitions=None, udts=None, dataflows=None, supportedStandards=None, components=None, rules=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.name = _cast(None, name)
        self.revision = _cast(int, revision)
        self.type_ = _cast(None, type_)
        self.status = _cast(None, status)
        self.enabled = _cast(bool, enabled)
        self.priority = _cast(None, priority)
        self.tags = _cast(None, tags)
        self.workflowState = _cast(None, workflowState)
        self.desc = desc
        self.categoryComponents = categoryComponents
        self.componentDefinitions = componentDefinitions
        self.udts = udts
        self.dataflows = dataflows
        self.supportedStandards = supportedStandards
        self.components = components
        self.rules = rules
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, libraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if libraryType.subclass:
            return libraryType.subclass(*args_, **kwargs_)
        else:
            return libraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_categoryComponents(self):
        return self.categoryComponents
    def set_categoryComponents(self, categoryComponents):
        self.categoryComponents = categoryComponents
    def get_componentDefinitions(self):
        return self.componentDefinitions
    def set_componentDefinitions(self, componentDefinitions):
        self.componentDefinitions = componentDefinitions
    def get_udts(self):
        return self.udts
    def set_udts(self, udts):
        self.udts = udts
    def get_dataflows(self):
        return self.dataflows
    def set_dataflows(self, dataflows):
        self.dataflows = dataflows
    def get_supportedStandards(self):
        return self.supportedStandards
    def set_supportedStandards(self, supportedStandards):
        self.supportedStandards = supportedStandards
    def get_components(self):
        return self.components
    def set_components(self, components):
        self.components = components
    def get_rules(self):
        return self.rules
    def set_rules(self, rules):
        self.rules = rules
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_revision(self):
        return self.revision
    def set_revision(self, revision):
        self.revision = revision
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_priority(self):
        return self.priority
    def set_priority(self, priority):
        self.priority = priority
    def get_tags(self):
        return self.tags
    def set_tags(self, tags):
        self.tags = tags
    def get_workflowState(self):
        return self.workflowState
    def set_workflowState(self, workflowState):
        self.workflowState = workflowState
    def hasContent_(self):
        if (
            self.desc is not None or
            self.categoryComponents is not None or
            self.componentDefinitions is not None or
            self.udts is not None or
            self.dataflows is not None or
            self.supportedStandards is not None or
            self.components is not None or
            self.rules is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='libraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('libraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='libraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='libraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='libraryType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.revision is not None and 'revision' not in already_processed:
            already_processed.add('revision')
            outfile.write(' revision="%s"' % self.gds_format_integer(self.revision, input_name='revision'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.status), input_name='status')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            outfile.write(' priority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.priority), input_name='priority')), ))
        if self.tags is not None and 'tags' not in already_processed:
            already_processed.add('tags')
            outfile.write(' tags=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tags), input_name='tags')), ))
        if self.workflowState is not None and 'workflowState' not in already_processed:
            already_processed.add('workflowState')
            outfile.write(' workflowState=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.workflowState), input_name='workflowState')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='libraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.desc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdesc>%s</%sdesc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.desc), input_name='desc')), namespaceprefix_ , eol_))
        if self.categoryComponents is not None:
            self.categoryComponents.export(outfile, level, namespaceprefix_, namespacedef_, name_='categoryComponents', pretty_print=pretty_print)
        if self.componentDefinitions is not None:
            self.componentDefinitions.export(outfile, level, namespaceprefix_, namespacedef_, name_='componentDefinitions', pretty_print=pretty_print)
        if self.udts is not None:
            self.udts.export(outfile, level, namespaceprefix_, name_='udts', pretty_print=pretty_print)
        if self.dataflows is not None:
            self.dataflows.export(outfile, level, namespaceprefix_, name_='dataflows', pretty_print=pretty_print)
        if self.supportedStandards is not None:
            self.supportedStandards.export(outfile, level, namespaceprefix_, namespacedef_, name_='supportedStandards', pretty_print=pretty_print)
        if self.components is not None:
            self.components.export(outfile, level, namespaceprefix_, namespacedef_, name_='components', pretty_print=pretty_print)
        if self.rules is not None:
            self.rules.export(outfile, level, namespaceprefix_, namespacedef_, name_='rules', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('revision', node)
        if value is not None and 'revision' not in already_processed:
            already_processed.add('revision')
            try:
                self.revision = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            self.priority = value
        value = find_attr_value_('tags', node)
        if value is not None and 'tags' not in already_processed:
            already_processed.add('tags')
            self.tags = value
        value = find_attr_value_('workflowState', node)
        if value is not None and 'workflowState' not in already_processed:
            already_processed.add('workflowState')
            self.workflowState = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'desc':
            desc_ = child_.text
            desc_ = self.gds_validate_string(desc_, node, 'desc')
            self.desc = desc_
        elif nodeName_ == 'categoryComponents':
            obj_ = categoryComponentsType.factory(parent_object_=self)
            obj_.build(child_)
            self.categoryComponents = obj_
            obj_.original_tagname_ = 'categoryComponents'
        elif nodeName_ == 'componentDefinitions':
            obj_ = componentDefinitionsType.factory(parent_object_=self)
            obj_.build(child_)
            self.componentDefinitions = obj_
            obj_.original_tagname_ = 'componentDefinitions'
        elif nodeName_ == 'udts':
            obj_ = udtsType.factory(parent_object_=self)
            obj_.build(child_)
            self.udts = obj_
            obj_.original_tagname_ = 'udts'
        elif nodeName_ == 'dataflows':
            obj_ = dataflowsType.factory(parent_object_=self)
            obj_.build(child_)
            self.dataflows = obj_
            obj_.original_tagname_ = 'dataflows'
        elif nodeName_ == 'supportedStandards':
            obj_ = supportedStandardsType.factory(parent_object_=self)
            obj_.build(child_)
            self.supportedStandards = obj_
            obj_.original_tagname_ = 'supportedStandards'
        elif nodeName_ == 'components':
            obj_ = componentsLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.components = obj_
            obj_.original_tagname_ = 'components'
        elif nodeName_ == 'rules':
            obj_ = rulesType.factory(parent_object_=self)
            obj_.build(child_)
            self.rules = obj_
            obj_.original_tagname_ = 'rules'
# end class libraryType


class supportedStandardsType(GeneratedsSuper):
    member_data_items_ = {
        'supportedStandard': MemberSpec_('supportedStandard', 'supportedStandardType', 1, 1, {'type': 'supportedStandardType', 'name': 'supportedStandard', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, supportedStandard=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if supportedStandard is None:
            self.supportedStandard = []
        else:
            self.supportedStandard = supportedStandard
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, supportedStandardsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if supportedStandardsType.subclass:
            return supportedStandardsType.subclass(*args_, **kwargs_)
        else:
            return supportedStandardsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_supportedStandard(self):
        return self.supportedStandard
    def set_supportedStandard(self, supportedStandard):
        self.supportedStandard = supportedStandard
    def add_supportedStandard(self, value):
        self.supportedStandard.append(value)
    def add_supportedStandard(self, value):
        self.supportedStandard.append(value)
    def insert_supportedStandard_at(self, index, value):
        self.supportedStandard.insert(index, value)
    def replace_supportedStandard_at(self, index, value):
        self.supportedStandard[index] = value
    def hasContent_(self):
        if (
            self.supportedStandard
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='supportedStandardsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('supportedStandardsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='supportedStandardsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='supportedStandardsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='supportedStandardsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='supportedStandardsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for supportedStandard_ in self.supportedStandard:
            supportedStandard_.export(outfile, level, namespaceprefix_, name_='supportedStandard', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'supportedStandard':
            obj_ = supportedStandardType.factory(parent_object_=self)
            obj_.build(child_)
            self.supportedStandard.append(obj_)
            obj_.original_tagname_ = 'supportedStandard'
# end class supportedStandardsType


class supportedStandardType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, name=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, supportedStandardType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if supportedStandardType.subclass:
            return supportedStandardType.subclass(*args_, **kwargs_)
        else:
            return supportedStandardType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='supportedStandardType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('supportedStandardType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='supportedStandardType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='supportedStandardType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='supportedStandardType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='supportedStandardType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class supportedStandardType


class udtsType(GeneratedsSuper):
    member_data_items_ = {
        'udt': MemberSpec_('udt', 'udtType', 1, 1, {'type': 'udtType', 'name': 'udt', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, udt=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if udt is None:
            self.udt = []
        else:
            self.udt = udt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, udtsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if udtsType.subclass:
            return udtsType.subclass(*args_, **kwargs_)
        else:
            return udtsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_udt(self):
        return self.udt
    def set_udt(self, udt):
        self.udt = udt
    def add_udt(self, value):
        self.udt.append(value)
    def add_udt(self, value):
        self.udt.append(value)
    def insert_udt_at(self, index, value):
        self.udt.insert(index, value)
    def replace_udt_at(self, index, value):
        self.udt[index] = value
    def hasContent_(self):
        if (
            self.udt
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='udtsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('udtsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='udtsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='udtsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='udtsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='udtsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for udt_ in self.udt:
            udt_.export(outfile, level, namespaceprefix_, name_='udt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'udt':
            obj_ = udtType.factory(parent_object_=self)
            obj_.build(child_)
            self.udt.append(obj_)
            obj_.original_tagname_ = 'udt'
# end class udtsType


class udtType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'value': MemberSpec_('value', 'xs:string', 0, 0, {'use': 'required'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, value=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.value = _cast(None, value)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, udtType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if udtType.subclass:
            return udtType.subclass(*args_, **kwargs_)
        else:
            return udtType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='udtType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('udtType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='udtType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='udtType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='udtType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='udtType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class udtType


class dataflowsType(GeneratedsSuper):
    member_data_items_ = {
        'dataflow': MemberSpec_('dataflow', 'dataflowType', 1, 1, {'type': 'dataflowType', 'name': 'dataflow', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, dataflow=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if dataflow is None:
            self.dataflow = []
        else:
            self.dataflow = dataflow
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dataflowsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dataflowsType.subclass:
            return dataflowsType.subclass(*args_, **kwargs_)
        else:
            return dataflowsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataflow(self):
        return self.dataflow
    def set_dataflow(self, dataflow):
        self.dataflow = dataflow
    def add_dataflow(self, value):
        self.dataflow.append(value)
    def add_dataflow(self, value):
        self.dataflow.append(value)
    def insert_dataflow_at(self, index, value):
        self.dataflow.insert(index, value)
    def replace_dataflow_at(self, index, value):
        self.dataflow[index] = value
    def hasContent_(self):
        if (
            self.dataflow
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dataflowsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dataflowsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dataflowsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dataflowsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dataflowsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dataflowsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dataflow_ in self.dataflow:
            dataflow_.export(outfile, level, namespaceprefix_, name_='dataflow', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataflow':
            obj_ = dataflowType.factory(parent_object_=self)
            obj_.build(child_)
            self.dataflow.append(obj_)
            obj_.original_tagname_ = 'dataflow'
# end class dataflowsType


class dataflowType(GeneratedsSuper):
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'source': MemberSpec_('source', 'xs:string', 0, 0, {'use': 'required'}),
        'target': MemberSpec_('target', 'xs:string', 0, 0, {'use': 'required'}),
        'assets': MemberSpec_('assets', 'assetsRefType', 0, 0, {'type': 'assetsRefType', 'name': 'assets'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, source=None, target=None, assets=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.source = _cast(None, source)
        self.target = _cast(None, target)
        self.assets = assets
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dataflowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dataflowType.subclass:
            return dataflowType.subclass(*args_, **kwargs_)
        else:
            return dataflowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assets(self):
        return self.assets
    def set_assets(self, assets):
        self.assets = assets
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def hasContent_(self):
        if (
            self.assets is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dataflowType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dataflowType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dataflowType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dataflowType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dataflowType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dataflowType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.assets is not None:
            self.assets.export(outfile, level, namespaceprefix_, namespacedef_, name_='assets', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'assets':
            obj_ = assetsRefType.factory(parent_object_=self)
            obj_.build(child_)
            self.assets = obj_
            obj_.original_tagname_ = 'assets'
# end class dataflowType


class assetsRefType(GeneratedsSuper):
    member_data_items_ = {
        'asset': MemberSpec_('asset', 'assetRefType', 1, 1, {'type': 'assetRefType', 'name': 'asset', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, asset=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if asset is None:
            self.asset = []
        else:
            self.asset = asset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, assetsRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if assetsRefType.subclass:
            return assetsRefType.subclass(*args_, **kwargs_)
        else:
            return assetsRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_asset(self):
        return self.asset
    def set_asset(self, asset):
        self.asset = asset
    def add_asset(self, value):
        self.asset.append(value)
    def add_asset(self, value):
        self.asset.append(value)
    def insert_asset_at(self, index, value):
        self.asset.insert(index, value)
    def replace_asset_at(self, index, value):
        self.asset[index] = value
    def hasContent_(self):
        if (
            self.asset
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='assetsRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('assetsRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='assetsRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='assetsRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='assetsRefType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='assetsRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for asset_ in self.asset:
            asset_.export(outfile, level, namespaceprefix_, name_='asset', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'asset':
            obj_ = assetRefType.factory(parent_object_=self)
            obj_.build(child_)
            self.asset.append(obj_)
            obj_.original_tagname_ = 'asset'
# end class assetsRefType


class assetRefType(GeneratedsSuper):
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'accessType': MemberSpec_('accessType', 'xs:integer', 0, 1, {'use': 'optional'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, accessType=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.accessType = _cast(int, accessType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, assetRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if assetRefType.subclass:
            return assetRefType.subclass(*args_, **kwargs_)
        else:
            return assetRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_accessType(self):
        return self.accessType
    def set_accessType(self, accessType):
        self.accessType = accessType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='assetRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('assetRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='assetRefType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='assetRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='assetRefType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.accessType is not None and 'accessType' not in already_processed:
            already_processed.add('accessType')
            outfile.write(' accessType="%s"' % self.gds_format_integer(self.accessType, input_name='accessType'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='assetRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('accessType', node)
        if value is not None and 'accessType' not in already_processed:
            already_processed.add('accessType')
            try:
                self.accessType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class assetRefType


class componentsLibraryType(GeneratedsSuper):
    member_data_items_ = {
        'component': MemberSpec_('component', 'componentLibraryType', 1, 1, {'type': 'componentLibraryType', 'name': 'component', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, component=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if component is None:
            self.component = []
        else:
            self.component = component
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentsLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentsLibraryType.subclass:
            return componentsLibraryType.subclass(*args_, **kwargs_)
        else:
            return componentsLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def add_component(self, value):
        self.component.append(value)
    def add_component(self, value):
        self.component.append(value)
    def insert_component_at(self, index, value):
        self.component.insert(index, value)
    def replace_component_at(self, index, value):
        self.component[index] = value
    def hasContent_(self):
        if (
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='componentsLibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentsLibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='componentsLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='componentsLibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='componentsLibraryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='componentsLibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for component_ in self.component:
            component_.export(outfile, level, namespaceprefix_, name_='component', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'component':
            obj_ = componentLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class componentsLibraryType


class componentLibraryType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'desc': MemberSpec_('desc', 'xs:string', 0, 0, {'use': 'required'}),
        'tags': MemberSpec_('tags', 'xs:string', 0, 0, {'use': 'required'}),
        'position': MemberSpec_('position', 'xs:string', 0, 1, {'use': 'optional'}),
        'groupName': MemberSpec_('groupName', 'xs:string', 0, 1, {'use': 'optional'}),
        'library': MemberSpec_('library', 'xs:string', 0, 1, {'use': 'optional'}),
        'diagramPositionX': MemberSpec_('diagramPositionX', 'xs:string', 0, 1, {'use': 'optional'}),
        'diagramPositionY': MemberSpec_('diagramPositionY', 'xs:string', 0, 1, {'use': 'optional'}),
        'componentDefinitionRef': MemberSpec_('componentDefinitionRef', 'xs:string', 0, 1, {'use': 'optional'}),
        'weaknesses': MemberSpec_('weaknesses', 'weaknessesLibraryType', 0, 0, {'type': 'weaknessesLibraryType', 'name': 'weaknesses'}, None),
        'controls': MemberSpec_('controls', 'controlsLibraryType', 0, 0, {'type': 'controlsLibraryType', 'name': 'controls'}, None),
        'usecases': MemberSpec_('usecases', 'usecasesLibraryType', 0, 0, {'type': 'usecasesLibraryType', 'name': 'usecases'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, name=None, desc=None, tags=None, position=None, groupName=None, library=None, diagramPositionX=None, diagramPositionY=None, componentDefinitionRef=None, weaknesses=None, controls=None, usecases=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.name = _cast(None, name)
        self.desc = _cast(None, desc)
        self.tags = _cast(None, tags)
        self.position = _cast(None, position)
        self.groupName = _cast(None, groupName)
        self.library = _cast(None, library)
        self.diagramPositionX = _cast(None, diagramPositionX)
        self.diagramPositionY = _cast(None, diagramPositionY)
        self.componentDefinitionRef = _cast(None, componentDefinitionRef)
        self.weaknesses = weaknesses
        self.controls = controls
        self.usecases = usecases
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentLibraryType.subclass:
            return componentLibraryType.subclass(*args_, **kwargs_)
        else:
            return componentLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weaknesses(self):
        return self.weaknesses
    def set_weaknesses(self, weaknesses):
        self.weaknesses = weaknesses
    def get_controls(self):
        return self.controls
    def set_controls(self, controls):
        self.controls = controls
    def get_usecases(self):
        return self.usecases
    def set_usecases(self, usecases):
        self.usecases = usecases
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_tags(self):
        return self.tags
    def set_tags(self, tags):
        self.tags = tags
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def get_groupName(self):
        return self.groupName
    def set_groupName(self, groupName):
        self.groupName = groupName
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_diagramPositionX(self):
        return self.diagramPositionX
    def set_diagramPositionX(self, diagramPositionX):
        self.diagramPositionX = diagramPositionX
    def get_diagramPositionY(self):
        return self.diagramPositionY
    def set_diagramPositionY(self, diagramPositionY):
        self.diagramPositionY = diagramPositionY
    def get_componentDefinitionRef(self):
        return self.componentDefinitionRef
    def set_componentDefinitionRef(self, componentDefinitionRef):
        self.componentDefinitionRef = componentDefinitionRef
    def hasContent_(self):
        if (
            self.weaknesses is not None or
            self.controls is not None or
            self.usecases is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='componentLibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentLibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='componentLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='componentLibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='componentLibraryType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.desc is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            outfile.write(' desc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.desc), input_name='desc')), ))
        if self.tags is not None and 'tags' not in already_processed:
            already_processed.add('tags')
            outfile.write(' tags=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tags), input_name='tags')), ))
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.position), input_name='position')), ))
        if self.groupName is not None and 'groupName' not in already_processed:
            already_processed.add('groupName')
            outfile.write(' groupName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.groupName), input_name='groupName')), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.add('library')
            outfile.write(' library=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.library), input_name='library')), ))
        if self.diagramPositionX is not None and 'diagramPositionX' not in already_processed:
            already_processed.add('diagramPositionX')
            outfile.write(' diagramPositionX=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.diagramPositionX), input_name='diagramPositionX')), ))
        if self.diagramPositionY is not None and 'diagramPositionY' not in already_processed:
            already_processed.add('diagramPositionY')
            outfile.write(' diagramPositionY=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.diagramPositionY), input_name='diagramPositionY')), ))
        if self.componentDefinitionRef is not None and 'componentDefinitionRef' not in already_processed:
            already_processed.add('componentDefinitionRef')
            outfile.write(' componentDefinitionRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.componentDefinitionRef), input_name='componentDefinitionRef')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='componentLibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.weaknesses is not None:
            self.weaknesses.export(outfile, level, namespaceprefix_, namespacedef_, name_='weaknesses', pretty_print=pretty_print)
        if self.controls is not None:
            self.controls.export(outfile, level, namespaceprefix_, namespacedef_, name_='controls', pretty_print=pretty_print)
        if self.usecases is not None:
            self.usecases.export(outfile, level, namespaceprefix_, namespacedef_, name_='usecases', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('desc', node)
        if value is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            self.desc = value
        value = find_attr_value_('tags', node)
        if value is not None and 'tags' not in already_processed:
            already_processed.add('tags')
            self.tags = value
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            self.position = value
        value = find_attr_value_('groupName', node)
        if value is not None and 'groupName' not in already_processed:
            already_processed.add('groupName')
            self.groupName = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.add('library')
            self.library = value
        value = find_attr_value_('diagramPositionX', node)
        if value is not None and 'diagramPositionX' not in already_processed:
            already_processed.add('diagramPositionX')
            self.diagramPositionX = value
        value = find_attr_value_('diagramPositionY', node)
        if value is not None and 'diagramPositionY' not in already_processed:
            already_processed.add('diagramPositionY')
            self.diagramPositionY = value
        value = find_attr_value_('componentDefinitionRef', node)
        if value is not None and 'componentDefinitionRef' not in already_processed:
            already_processed.add('componentDefinitionRef')
            self.componentDefinitionRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weaknesses':
            obj_ = weaknessesLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.weaknesses = obj_
            obj_.original_tagname_ = 'weaknesses'
        elif nodeName_ == 'controls':
            obj_ = controlsLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.controls = obj_
            obj_.original_tagname_ = 'controls'
        elif nodeName_ == 'usecases':
            obj_ = usecasesLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.usecases = obj_
            obj_.original_tagname_ = 'usecases'
# end class componentLibraryType


class weaknessesLibraryType(GeneratedsSuper):
    member_data_items_ = {
        'weakness': MemberSpec_('weakness', 'weaknessLibraryType', 1, 1, {'type': 'weaknessLibraryType', 'name': 'weakness', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, weakness=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if weakness is None:
            self.weakness = []
        else:
            self.weakness = weakness
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, weaknessesLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if weaknessesLibraryType.subclass:
            return weaknessesLibraryType.subclass(*args_, **kwargs_)
        else:
            return weaknessesLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weakness(self):
        return self.weakness
    def set_weakness(self, weakness):
        self.weakness = weakness
    def add_weakness(self, value):
        self.weakness.append(value)
    def add_weakness(self, value):
        self.weakness.append(value)
    def insert_weakness_at(self, index, value):
        self.weakness.insert(index, value)
    def replace_weakness_at(self, index, value):
        self.weakness[index] = value
    def hasContent_(self):
        if (
            self.weakness
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='weaknessesLibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('weaknessesLibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='weaknessesLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='weaknessesLibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='weaknessesLibraryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='weaknessesLibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for weakness_ in self.weakness:
            weakness_.export(outfile, level, namespaceprefix_, name_='weakness', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weakness':
            obj_ = weaknessLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.weakness.append(obj_)
            obj_.original_tagname_ = 'weakness'
# end class weaknessesLibraryType


class weaknessLibraryType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'state': MemberSpec_('state', 'xs:integer', 0, 0, {'use': 'required'}),
        'impact': MemberSpec_('impact', 'xs:integer', 0, 0, {'use': 'required'}),
        'issueId': MemberSpec_('issueId', 'xs:string', 0, 1, {'use': 'optional'}),
        'test': MemberSpec_('test', 'testLibraryType', 0, 0, {'type': 'testLibraryType', 'name': 'test'}, None),
        'desc': MemberSpec_('desc', 'xs:string', 0, 0, {'type': 'xs:string', 'name': 'desc'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, name=None, state=None, impact=None, issueId=None, test=None, desc=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.name = _cast(None, name)
        self.state = _cast(int, state)
        self.impact = _cast(int, impact)
        self.issueId = _cast(None, issueId)
        self.test = test
        self.desc = desc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, weaknessLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if weaknessLibraryType.subclass:
            return weaknessLibraryType.subclass(*args_, **kwargs_)
        else:
            return weaknessLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_test(self):
        return self.test
    def set_test(self, test):
        self.test = test
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def get_impact(self):
        return self.impact
    def set_impact(self, impact):
        self.impact = impact
    def get_issueId(self):
        return self.issueId
    def set_issueId(self, issueId):
        self.issueId = issueId
    def hasContent_(self):
        if (
            self.test is not None or
            self.desc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='weaknessLibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('weaknessLibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='weaknessLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='weaknessLibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='weaknessLibraryType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state="%s"' % self.gds_format_integer(self.state, input_name='state'))
        if self.impact is not None and 'impact' not in already_processed:
            already_processed.add('impact')
            outfile.write(' impact="%s"' % self.gds_format_integer(self.impact, input_name='impact'))
        if self.issueId is not None and 'issueId' not in already_processed:
            already_processed.add('issueId')
            outfile.write(' issueId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.issueId), input_name='issueId')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='weaknessLibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.test is not None:
            self.test.export(outfile, level, namespaceprefix_, namespacedef_, name_='test', pretty_print=pretty_print)
        if self.desc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdesc>%s</%sdesc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.desc), input_name='desc')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            try:
                self.state = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('impact', node)
        if value is not None and 'impact' not in already_processed:
            already_processed.add('impact')
            try:
                self.impact = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('issueId', node)
        if value is not None and 'issueId' not in already_processed:
            already_processed.add('issueId')
            self.issueId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'test':
            obj_ = testLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.test = obj_
            obj_.original_tagname_ = 'test'
        elif nodeName_ == 'desc':
            desc_ = child_.text
            desc_ = self.gds_validate_string(desc_, node, 'desc')
            self.desc = desc_
# end class weaknessLibraryType


class testLibraryType(GeneratedsSuper):
    member_data_items_ = {
        'expiryDate': MemberSpec_('expiryDate', 'xs:string', 0, 0, {'use': 'required'}),
        'expiryPeriod': MemberSpec_('expiryPeriod', 'xs:string', 0, 0, {'use': 'required'}),
        'steps': MemberSpec_('steps', 'xs:string', 0, 0, {'type': 'xs:string', 'name': 'steps'}, None),
        'notes': MemberSpec_('notes', 'xs:string', 0, 0, {'type': 'xs:string', 'name': 'notes'}, None),
        'references': MemberSpec_('references', 'referencesType', 0, 0, {'type': 'referencesType', 'name': 'references'}, None),
        'source': MemberSpec_('source', 'sourceType', 0, 1, {'type': 'sourceType', 'name': 'source', 'minOccurs': '0'}, None),
        'udts': MemberSpec_('udts', 'udtsType', 0, 0, {'type': 'udtsType', 'name': 'udts'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, expiryDate=None, expiryPeriod=None, steps=None, notes=None, references=None, source=None, udts=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.expiryDate = _cast(None, expiryDate)
        self.expiryPeriod = _cast(None, expiryPeriod)
        self.steps = steps
        self.notes = notes
        self.references = references
        self.source = source
        self.udts = udts
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, testLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if testLibraryType.subclass:
            return testLibraryType.subclass(*args_, **kwargs_)
        else:
            return testLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_steps(self):
        return self.steps
    def set_steps(self, steps):
        self.steps = steps
    def get_notes(self):
        return self.notes
    def set_notes(self, notes):
        self.notes = notes
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_udts(self):
        return self.udts
    def set_udts(self, udts):
        self.udts = udts
    def get_expiryDate(self):
        return self.expiryDate
    def set_expiryDate(self, expiryDate):
        self.expiryDate = expiryDate
    def get_expiryPeriod(self):
        return self.expiryPeriod
    def set_expiryPeriod(self, expiryPeriod):
        self.expiryPeriod = expiryPeriod
    def hasContent_(self):
        if (
            self.steps is not None or
            self.notes is not None or
            self.references is not None or
            self.source is not None or
            self.udts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='testLibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('testLibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='testLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='testLibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='testLibraryType'):
        if self.expiryDate is not None and 'expiryDate' not in already_processed:
            already_processed.add('expiryDate')
            outfile.write(' expiryDate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expiryDate), input_name='expiryDate')), ))
        if self.expiryPeriod is not None and 'expiryPeriod' not in already_processed:
            already_processed.add('expiryPeriod')
            outfile.write(' expiryPeriod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expiryPeriod), input_name='expiryPeriod')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='testLibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.steps is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssteps>%s</%ssteps>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.steps), input_name='steps')), namespaceprefix_ , eol_))
        if self.notes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        if self.references is not None:
            self.references.export(outfile, level, namespaceprefix_, namespacedef_, name_='references', pretty_print=pretty_print)
        if self.source is not None:
            self.source.export(outfile, level, namespaceprefix_, name_='source', pretty_print=pretty_print)
        if self.udts is not None:
            self.udts.export(outfile, level, namespaceprefix_, namespacedef_, name_='udts', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('expiryDate', node)
        if value is not None and 'expiryDate' not in already_processed:
            already_processed.add('expiryDate')
            self.expiryDate = value
        value = find_attr_value_('expiryPeriod', node)
        if value is not None and 'expiryPeriod' not in already_processed:
            already_processed.add('expiryPeriod')
            self.expiryPeriod = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'steps':
            steps_ = child_.text
            steps_ = self.gds_validate_string(steps_, node, 'steps')
            self.steps = steps_
        elif nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
        elif nodeName_ == 'references':
            obj_ = referencesType.factory(parent_object_=self)
            obj_.build(child_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
        elif nodeName_ == 'source':
            obj_ = sourceType.factory(parent_object_=self)
            obj_.build(child_)
            self.source = obj_
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'udts':
            obj_ = udtsType.factory(parent_object_=self)
            obj_.build(child_)
            self.udts = obj_
            obj_.original_tagname_ = 'udts'
# end class testLibraryType


class sourceType(GeneratedsSuper):
    member_data_items_ = {
        'filename': MemberSpec_('filename', 'xs:string', 0, 0, {'use': 'required'}),
        'args': MemberSpec_('args', 'xs:string', 0, 0, {'use': 'required'}),
        'type_': MemberSpec_('type_', 'xs:string', 0, 0, {'use': 'required'}),
        'result': MemberSpec_('result', 'xs:string', 0, 0, {'use': 'required'}),
        'enabled': MemberSpec_('enabled', 'xs:boolean', 0, 0, {'use': 'required'}),
        'timestamp': MemberSpec_('timestamp', 'xs:dateTime', 0, 0, {'use': 'required'}),
        'output': MemberSpec_('output', 'xs:string', 0, 0, {'type': 'xs:string', 'name': 'output'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, filename=None, args=None, type_=None, result=None, enabled=None, timestamp=None, output=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.filename = _cast(None, filename)
        self.args = _cast(None, args)
        self.type_ = _cast(None, type_)
        self.result = _cast(None, result)
        self.enabled = _cast(bool, enabled)
        if isinstance(timestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timestamp
        self.timestamp = initvalue_
        self.output = output
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sourceType.subclass:
            return sourceType.subclass(*args_, **kwargs_)
        else:
            return sourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_output(self):
        return self.output
    def set_output(self, output):
        self.output = output
    def get_filename(self):
        return self.filename
    def set_filename(self, filename):
        self.filename = filename
    def get_args(self):
        return self.args
    def set_args(self, args):
        self.args = args
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_result(self):
        return self.result
    def set_result(self, result):
        self.result = result
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def hasContent_(self):
        if (
            self.output is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sourceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sourceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='sourceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sourceType'):
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filename), input_name='filename')), ))
        if self.args is not None and 'args' not in already_processed:
            already_processed.add('args')
            outfile.write(' args=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.args), input_name='args')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.result is not None and 'result' not in already_processed:
            already_processed.add('result')
            outfile.write(' result=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.result), input_name='result')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp="%s"' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sourceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.output is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutput>%s</%soutput>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.output), input_name='output')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
        value = find_attr_value_('args', node)
        if value is not None and 'args' not in already_processed:
            already_processed.add('args')
            self.args = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('result', node)
        if value is not None and 'result' not in already_processed:
            already_processed.add('result')
            self.result = value
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            try:
                self.timestamp = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timestamp): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'output':
            output_ = child_.text
            output_ = self.gds_validate_string(output_, node, 'output')
            self.output = output_
# end class sourceType


class referencesType(GeneratedsSuper):
    member_data_items_ = {
        'reference': MemberSpec_('reference', 'referenceType', 1, 1, {'type': 'referenceType', 'name': 'reference', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, reference=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referencesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referencesType.subclass:
            return referencesType.subclass(*args_, **kwargs_)
        else:
            return referencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def hasContent_(self):
        if (
            self.reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='referencesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referencesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referencesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='referencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reference_ in self.reference:
            reference_.export(outfile, level, namespaceprefix_, name_='reference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reference':
            obj_ = referenceType.factory(parent_object_=self)
            obj_.build(child_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
# end class referencesType


class referenceType(GeneratedsSuper):
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'url': MemberSpec_('url', 'xs:string', 0, 0, {'use': 'required'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, url=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.url = _cast(None, url)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referenceType.subclass:
            return referenceType.subclass(*args_, **kwargs_)
        else:
            return referenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='referenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referenceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referenceType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.url), input_name='url')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='referenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class referenceType


class controlsLibraryType(GeneratedsSuper):
    member_data_items_ = {
        'control': MemberSpec_('control', 'controlLibraryType', 1, 1, {'type': 'controlLibraryType', 'name': 'control', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, control=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if control is None:
            self.control = []
        else:
            self.control = control
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, controlsLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if controlsLibraryType.subclass:
            return controlsLibraryType.subclass(*args_, **kwargs_)
        else:
            return controlsLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def hasContent_(self):
        if (
            self.control
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controlsLibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('controlsLibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='controlsLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='controlsLibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='controlsLibraryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controlsLibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            control_.export(outfile, level, namespaceprefix_, name_='control', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'control':
            obj_ = controlLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
# end class controlsLibraryType


class controlLibraryType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'issueId': MemberSpec_('issueId', 'xs:string', 0, 1, {'use': 'optional'}),
        'platform': MemberSpec_('platform', 'xs:string', 0, 1, {'use': 'optional'}),
        'cost': MemberSpec_('cost', 'xs:integer', 0, 0, {'use': 'required'}),
        'risk': MemberSpec_('risk', 'xs:integer', 0, 0, {'use': 'required'}),
        'state': MemberSpec_('state', 'xs:string', 0, 0, {'use': 'required'}),
        'owner': MemberSpec_('owner', 'xs:string', 0, 1, {'use': 'optional'}),
        'library': MemberSpec_('library', 'xs:string', 0, 1, {'use': 'optional'}),
        'source': MemberSpec_('source', 'xs:string', 0, 1, {'use': 'optional'}),
        'desc': MemberSpec_('desc', 'xs:string', 0, 0, {'type': 'xs:string', 'name': 'desc'}, None),
        'implementations': MemberSpec_('implementations', 'implementationsType', 0, 0, {'type': 'implementationsType', 'name': 'implementations'}, None),
        'references': MemberSpec_('references', 'referencesType', 0, 0, {'type': 'referencesType', 'name': 'references'}, None),
        'standards': MemberSpec_('standards', 'standardsType', 0, 0, {'type': 'standardsType', 'name': 'standards'}, None),
        'udts': MemberSpec_('udts', 'udtsType', 0, 0, {'type': 'udtsType', 'name': 'udts'}, None),
        'test': MemberSpec_('test', 'testLibraryType', 0, 0, {'type': 'testLibraryType', 'name': 'test'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, name=None, issueId=None, platform=None, cost=None, risk=None, state=None, owner=None, library=None, source=None, desc=None, implementations=None, references=None, standards=None, udts=None, test=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.name = _cast(None, name)
        self.issueId = _cast(None, issueId)
        self.platform = _cast(None, platform)
        self.cost = _cast(int, cost)
        self.risk = _cast(int, risk)
        self.state = _cast(None, state)
        self.owner = _cast(None, owner)
        self.library = _cast(None, library)
        self.source = _cast(None, source)
        self.desc = desc
        self.implementations = implementations
        self.references = references
        self.standards = standards
        self.udts = udts
        self.test = test
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, controlLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if controlLibraryType.subclass:
            return controlLibraryType.subclass(*args_, **kwargs_)
        else:
            return controlLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_implementations(self):
        return self.implementations
    def set_implementations(self, implementations):
        self.implementations = implementations
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_standards(self):
        return self.standards
    def set_standards(self, standards):
        self.standards = standards
    def get_udts(self):
        return self.udts
    def set_udts(self, udts):
        self.udts = udts
    def get_test(self):
        return self.test
    def set_test(self, test):
        self.test = test
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_issueId(self):
        return self.issueId
    def set_issueId(self, issueId):
        self.issueId = issueId
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def get_cost(self):
        return self.cost
    def set_cost(self, cost):
        self.cost = cost
    def get_risk(self):
        return self.risk
    def set_risk(self, risk):
        self.risk = risk
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def get_owner(self):
        return self.owner
    def set_owner(self, owner):
        self.owner = owner
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def hasContent_(self):
        if (
            self.desc is not None or
            self.implementations is not None or
            self.references is not None or
            self.standards is not None or
            self.udts is not None or
            self.test is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controlLibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('controlLibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='controlLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='controlLibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='controlLibraryType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.issueId is not None and 'issueId' not in already_processed:
            already_processed.add('issueId')
            outfile.write(' issueId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.issueId), input_name='issueId')), ))
        if self.platform is not None and 'platform' not in already_processed:
            already_processed.add('platform')
            outfile.write(' platform=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.platform), input_name='platform')), ))
        if self.cost is not None and 'cost' not in already_processed:
            already_processed.add('cost')
            outfile.write(' cost="%s"' % self.gds_format_integer(self.cost, input_name='cost'))
        if self.risk is not None and 'risk' not in already_processed:
            already_processed.add('risk')
            outfile.write(' risk="%s"' % self.gds_format_integer(self.risk, input_name='risk'))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')), ))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.owner), input_name='owner')), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.add('library')
            outfile.write(' library=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.library), input_name='library')), ))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controlLibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.desc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdesc>%s</%sdesc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.desc), input_name='desc')), namespaceprefix_ , eol_))
        if self.implementations is not None:
            self.implementations.export(outfile, level, namespaceprefix_, namespacedef_, name_='implementations', pretty_print=pretty_print)
        if self.references is not None:
            self.references.export(outfile, level, namespaceprefix_, namespacedef_, name_='references', pretty_print=pretty_print)
        if self.standards is not None:
            self.standards.export(outfile, level, namespaceprefix_, namespacedef_, name_='standards', pretty_print=pretty_print)
        if self.udts is not None:
            self.udts.export(outfile, level, namespaceprefix_, namespacedef_, name_='udts', pretty_print=pretty_print)
        if self.test is not None:
            self.test.export(outfile, level, namespaceprefix_, namespacedef_, name_='test', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('issueId', node)
        if value is not None and 'issueId' not in already_processed:
            already_processed.add('issueId')
            self.issueId = value
        value = find_attr_value_('platform', node)
        if value is not None and 'platform' not in already_processed:
            already_processed.add('platform')
            self.platform = value
        value = find_attr_value_('cost', node)
        if value is not None and 'cost' not in already_processed:
            already_processed.add('cost')
            try:
                self.cost = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('risk', node)
        if value is not None and 'risk' not in already_processed:
            already_processed.add('risk')
            try:
                self.risk = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.add('library')
            self.library = value
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'desc':
            desc_ = child_.text
            desc_ = self.gds_validate_string(desc_, node, 'desc')
            self.desc = desc_
        elif nodeName_ == 'implementations':
            obj_ = implementationsType.factory(parent_object_=self)
            obj_.build(child_)
            self.implementations = obj_
            obj_.original_tagname_ = 'implementations'
        elif nodeName_ == 'references':
            obj_ = referencesType.factory(parent_object_=self)
            obj_.build(child_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
        elif nodeName_ == 'standards':
            obj_ = standardsType.factory(parent_object_=self)
            obj_.build(child_)
            self.standards = obj_
            obj_.original_tagname_ = 'standards'
        elif nodeName_ == 'udts':
            obj_ = udtsType.factory(parent_object_=self)
            obj_.build(child_)
            self.udts = obj_
            obj_.original_tagname_ = 'udts'
        elif nodeName_ == 'test':
            obj_ = testLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.test = obj_
            obj_.original_tagname_ = 'test'
# end class controlLibraryType


class implementationsType(GeneratedsSuper):
    member_data_items_ = {
        'implementation': MemberSpec_('implementation', 'implementationType', 1, 1, {'type': 'implementationType', 'name': 'implementation', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, implementation=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if implementation is None:
            self.implementation = []
        else:
            self.implementation = implementation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, implementationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if implementationsType.subclass:
            return implementationsType.subclass(*args_, **kwargs_)
        else:
            return implementationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_implementation(self):
        return self.implementation
    def set_implementation(self, implementation):
        self.implementation = implementation
    def add_implementation(self, value):
        self.implementation.append(value)
    def add_implementation(self, value):
        self.implementation.append(value)
    def insert_implementation_at(self, index, value):
        self.implementation.insert(index, value)
    def replace_implementation_at(self, index, value):
        self.implementation[index] = value
    def hasContent_(self):
        if (
            self.implementation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='implementationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('implementationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='implementationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='implementationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='implementationsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='implementationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for implementation_ in self.implementation:
            implementation_.export(outfile, level, namespaceprefix_, name_='implementation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'implementation':
            obj_ = implementationType.factory(parent_object_=self)
            obj_.build(child_)
            self.implementation.append(obj_)
            obj_.original_tagname_ = 'implementation'
# end class implementationsType


class implementationType(GeneratedsSuper):
    member_data_items_ = {
        'platform': MemberSpec_('platform', 'xs:string', 0, 0, {'use': 'required'}),
        'desc': MemberSpec_('desc', 'xs:string', 0, 0, {'type': 'xs:string', 'name': 'desc'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, platform=None, desc=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.platform = _cast(None, platform)
        self.desc = desc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, implementationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if implementationType.subclass:
            return implementationType.subclass(*args_, **kwargs_)
        else:
            return implementationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def hasContent_(self):
        if (
            self.desc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='implementationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('implementationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='implementationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='implementationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='implementationType'):
        if self.platform is not None and 'platform' not in already_processed:
            already_processed.add('platform')
            outfile.write(' platform=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.platform), input_name='platform')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='implementationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.desc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdesc>%s</%sdesc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.desc), input_name='desc')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('platform', node)
        if value is not None and 'platform' not in already_processed:
            already_processed.add('platform')
            self.platform = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'desc':
            desc_ = child_.text
            desc_ = self.gds_validate_string(desc_, node, 'desc')
            self.desc = desc_
# end class implementationType


class standardsType(GeneratedsSuper):
    member_data_items_ = {
        'standard': MemberSpec_('standard', 'standardType', 1, 1, {'type': 'standardType', 'name': 'standard', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, standard=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if standard is None:
            self.standard = []
        else:
            self.standard = standard
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, standardsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if standardsType.subclass:
            return standardsType.subclass(*args_, **kwargs_)
        else:
            return standardsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_standard(self):
        return self.standard
    def set_standard(self, standard):
        self.standard = standard
    def add_standard(self, value):
        self.standard.append(value)
    def add_standard(self, value):
        self.standard.append(value)
    def insert_standard_at(self, index, value):
        self.standard.insert(index, value)
    def replace_standard_at(self, index, value):
        self.standard[index] = value
    def hasContent_(self):
        if (
            self.standard
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='standardsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('standardsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='standardsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='standardsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='standardsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='standardsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for standard_ in self.standard:
            standard_.export(outfile, level, namespaceprefix_, name_='standard', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'standard':
            obj_ = standardType.factory(parent_object_=self)
            obj_.build(child_)
            self.standard.append(obj_)
            obj_.original_tagname_ = 'standard'
# end class standardsType


class standardType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'supportedStandardRef': MemberSpec_('supportedStandardRef', 'xs:string', 0, 0, {'use': 'required'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, supportedStandardRef=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.supportedStandardRef = _cast(None, supportedStandardRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, standardType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if standardType.subclass:
            return standardType.subclass(*args_, **kwargs_)
        else:
            return standardType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_supportedStandardRef(self):
        return self.supportedStandardRef
    def set_supportedStandardRef(self, supportedStandardRef):
        self.supportedStandardRef = supportedStandardRef
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='standardType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('standardType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='standardType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='standardType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='standardType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.supportedStandardRef is not None and 'supportedStandardRef' not in already_processed:
            already_processed.add('supportedStandardRef')
            outfile.write(' supportedStandardRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supportedStandardRef), input_name='supportedStandardRef')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='standardType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('supportedStandardRef', node)
        if value is not None and 'supportedStandardRef' not in already_processed:
            already_processed.add('supportedStandardRef')
            self.supportedStandardRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class standardType


class usecasesLibraryType(GeneratedsSuper):
    member_data_items_ = {
        'usecase': MemberSpec_('usecase', 'usecaseLibraryType', 1, 1, {'type': 'usecaseLibraryType', 'name': 'usecase', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, usecase=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if usecase is None:
            self.usecase = []
        else:
            self.usecase = usecase
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, usecasesLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if usecasesLibraryType.subclass:
            return usecasesLibraryType.subclass(*args_, **kwargs_)
        else:
            return usecasesLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_usecase(self):
        return self.usecase
    def set_usecase(self, usecase):
        self.usecase = usecase
    def add_usecase(self, value):
        self.usecase.append(value)
    def add_usecase(self, value):
        self.usecase.append(value)
    def insert_usecase_at(self, index, value):
        self.usecase.insert(index, value)
    def replace_usecase_at(self, index, value):
        self.usecase[index] = value
    def hasContent_(self):
        if (
            self.usecase
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='usecasesLibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('usecasesLibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='usecasesLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='usecasesLibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='usecasesLibraryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='usecasesLibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for usecase_ in self.usecase:
            usecase_.export(outfile, level, namespaceprefix_, name_='usecase', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'usecase':
            obj_ = usecaseLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.usecase.append(obj_)
            obj_.original_tagname_ = 'usecase'
# end class usecasesLibraryType


class usecaseLibraryType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'desc': MemberSpec_('desc', 'xs:string', 0, 0, {'use': 'required'}),
        'library': MemberSpec_('library', 'xs:string', 0, 1, {'use': 'optional'}),
        'threats': MemberSpec_('threats', 'threatsLibraryType', 0, 0, {'type': 'threatsLibraryType', 'name': 'threats'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, name=None, desc=None, library=None, threats=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.name = _cast(None, name)
        self.desc = _cast(None, desc)
        self.library = _cast(None, library)
        self.threats = threats
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, usecaseLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if usecaseLibraryType.subclass:
            return usecaseLibraryType.subclass(*args_, **kwargs_)
        else:
            return usecaseLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_threats(self):
        return self.threats
    def set_threats(self, threats):
        self.threats = threats
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def hasContent_(self):
        if (
            self.threats is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='usecaseLibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('usecaseLibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='usecaseLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='usecaseLibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='usecaseLibraryType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.desc is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            outfile.write(' desc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.desc), input_name='desc')), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.add('library')
            outfile.write(' library=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.library), input_name='library')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='usecaseLibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.threats is not None:
            self.threats.export(outfile, level, namespaceprefix_, namespacedef_, name_='threats', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('desc', node)
        if value is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            self.desc = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.add('library')
            self.library = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'threats':
            obj_ = threatsLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.threats = obj_
            obj_.original_tagname_ = 'threats'
# end class usecaseLibraryType


class threatsLibraryType(GeneratedsSuper):
    member_data_items_ = {
        'threat': MemberSpec_('threat', 'threatLibraryType', 1, 1, {'type': 'threatLibraryType', 'name': 'threat', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, threat=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if threat is None:
            self.threat = []
        else:
            self.threat = threat
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, threatsLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if threatsLibraryType.subclass:
            return threatsLibraryType.subclass(*args_, **kwargs_)
        else:
            return threatsLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_threat(self):
        return self.threat
    def set_threat(self, threat):
        self.threat = threat
    def add_threat(self, value):
        self.threat.append(value)
    def add_threat(self, value):
        self.threat.append(value)
    def insert_threat_at(self, index, value):
        self.threat.insert(index, value)
    def replace_threat_at(self, index, value):
        self.threat[index] = value
    def hasContent_(self):
        if (
            self.threat
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='threatsLibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('threatsLibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='threatsLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='threatsLibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='threatsLibraryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='threatsLibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for threat_ in self.threat:
            threat_.export(outfile, level, namespaceprefix_, name_='threat', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'threat':
            obj_ = threatLibraryType.factory(parent_object_=self)
            obj_.build(child_)
            self.threat.append(obj_)
            obj_.original_tagname_ = 'threat'
# end class threatsLibraryType


class threatLibraryType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'state': MemberSpec_('state', 'xs:string', 0, 0, {'use': 'required'}),
        'source': MemberSpec_('source', 'xs:string', 0, 1, {'use': 'optional'}),
        'owner': MemberSpec_('owner', 'xs:string', 0, 1, {'use': 'optional'}),
        'library': MemberSpec_('library', 'xs:string', 0, 1, {'use': 'optional'}),
        'desc': MemberSpec_('desc', 'xs:string', 0, 0, {'type': 'xs:string', 'name': 'desc'}, None),
        'riskRating': MemberSpec_('riskRating', 'riskRatingType', 0, 0, {'type': 'riskRatingType', 'name': 'riskRating'}, None),
        'references': MemberSpec_('references', 'referencesType', 0, 0, {'type': 'referencesType', 'name': 'references'}, None),
        'controls': MemberSpec_('controls', 'controlsRefType', 0, 0, {'type': 'controlsRefType', 'name': 'controls'}, None),
        'weaknesses': MemberSpec_('weaknesses', 'weaknessesRefType', 0, 0, {'type': 'weaknessesRefType', 'name': 'weaknesses'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, name=None, state=None, source=None, owner=None, library=None, desc=None, riskRating=None, references=None, controls=None, weaknesses=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.name = _cast(None, name)
        self.state = _cast(None, state)
        self.source = _cast(None, source)
        self.owner = _cast(None, owner)
        self.library = _cast(None, library)
        self.desc = desc
        self.riskRating = riskRating
        self.references = references
        self.controls = controls
        self.weaknesses = weaknesses
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, threatLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if threatLibraryType.subclass:
            return threatLibraryType.subclass(*args_, **kwargs_)
        else:
            return threatLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_riskRating(self):
        return self.riskRating
    def set_riskRating(self, riskRating):
        self.riskRating = riskRating
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_controls(self):
        return self.controls
    def set_controls(self, controls):
        self.controls = controls
    def get_weaknesses(self):
        return self.weaknesses
    def set_weaknesses(self, weaknesses):
        self.weaknesses = weaknesses
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_owner(self):
        return self.owner
    def set_owner(self, owner):
        self.owner = owner
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def hasContent_(self):
        if (
            self.desc is not None or
            self.riskRating is not None or
            self.references is not None or
            self.controls is not None or
            self.weaknesses is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='threatLibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('threatLibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='threatLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='threatLibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='threatLibraryType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')), ))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.owner), input_name='owner')), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.add('library')
            outfile.write(' library=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.library), input_name='library')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='threatLibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.desc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdesc>%s</%sdesc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.desc), input_name='desc')), namespaceprefix_ , eol_))
        if self.riskRating is not None:
            self.riskRating.export(outfile, level, namespaceprefix_, namespacedef_, name_='riskRating', pretty_print=pretty_print)
        if self.references is not None:
            self.references.export(outfile, level, namespaceprefix_, namespacedef_, name_='references', pretty_print=pretty_print)
        if self.controls is not None:
            self.controls.export(outfile, level, namespaceprefix_, namespacedef_, name_='controls', pretty_print=pretty_print)
        if self.weaknesses is not None:
            self.weaknesses.export(outfile, level, namespaceprefix_, namespacedef_, name_='weaknesses', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.add('library')
            self.library = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'desc':
            desc_ = child_.text
            desc_ = self.gds_validate_string(desc_, node, 'desc')
            self.desc = desc_
        elif nodeName_ == 'riskRating':
            obj_ = riskRatingType.factory(parent_object_=self)
            obj_.build(child_)
            self.riskRating = obj_
            obj_.original_tagname_ = 'riskRating'
        elif nodeName_ == 'references':
            obj_ = referencesType.factory(parent_object_=self)
            obj_.build(child_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
        elif nodeName_ == 'controls':
            obj_ = controlsRefType.factory(parent_object_=self)
            obj_.build(child_)
            self.controls = obj_
            obj_.original_tagname_ = 'controls'
        elif nodeName_ == 'weaknesses':
            obj_ = weaknessesRefType.factory(parent_object_=self)
            obj_.build(child_)
            self.weaknesses = obj_
            obj_.original_tagname_ = 'weaknesses'
# end class threatLibraryType


class riskRatingType(GeneratedsSuper):
    member_data_items_ = {
        'confidentiality': MemberSpec_('confidentiality', 'xs:integer', 0, 0, {'use': 'required'}),
        'integrity': MemberSpec_('integrity', 'xs:integer', 0, 0, {'use': 'required'}),
        'availability': MemberSpec_('availability', 'xs:integer', 0, 0, {'use': 'required'}),
        'easeOfExploitation': MemberSpec_('easeOfExploitation', 'xs:integer', 0, 0, {'use': 'required'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, confidentiality=None, integrity=None, availability=None, easeOfExploitation=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.confidentiality = _cast(int, confidentiality)
        self.integrity = _cast(int, integrity)
        self.availability = _cast(int, availability)
        self.easeOfExploitation = _cast(int, easeOfExploitation)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, riskRatingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if riskRatingType.subclass:
            return riskRatingType.subclass(*args_, **kwargs_)
        else:
            return riskRatingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_confidentiality(self):
        return self.confidentiality
    def set_confidentiality(self, confidentiality):
        self.confidentiality = confidentiality
    def get_integrity(self):
        return self.integrity
    def set_integrity(self, integrity):
        self.integrity = integrity
    def get_availability(self):
        return self.availability
    def set_availability(self, availability):
        self.availability = availability
    def get_easeOfExploitation(self):
        return self.easeOfExploitation
    def set_easeOfExploitation(self, easeOfExploitation):
        self.easeOfExploitation = easeOfExploitation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='riskRatingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('riskRatingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='riskRatingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='riskRatingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='riskRatingType'):
        if self.confidentiality is not None and 'confidentiality' not in already_processed:
            already_processed.add('confidentiality')
            outfile.write(' confidentiality="%s"' % self.gds_format_integer(self.confidentiality, input_name='confidentiality'))
        if self.integrity is not None and 'integrity' not in already_processed:
            already_processed.add('integrity')
            outfile.write(' integrity="%s"' % self.gds_format_integer(self.integrity, input_name='integrity'))
        if self.availability is not None and 'availability' not in already_processed:
            already_processed.add('availability')
            outfile.write(' availability="%s"' % self.gds_format_integer(self.availability, input_name='availability'))
        if self.easeOfExploitation is not None and 'easeOfExploitation' not in already_processed:
            already_processed.add('easeOfExploitation')
            outfile.write(' easeOfExploitation="%s"' % self.gds_format_integer(self.easeOfExploitation, input_name='easeOfExploitation'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='riskRatingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('confidentiality', node)
        if value is not None and 'confidentiality' not in already_processed:
            already_processed.add('confidentiality')
            try:
                self.confidentiality = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('integrity', node)
        if value is not None and 'integrity' not in already_processed:
            already_processed.add('integrity')
            try:
                self.integrity = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('availability', node)
        if value is not None and 'availability' not in already_processed:
            already_processed.add('availability')
            try:
                self.availability = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('easeOfExploitation', node)
        if value is not None and 'easeOfExploitation' not in already_processed:
            already_processed.add('easeOfExploitation')
            try:
                self.easeOfExploitation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class riskRatingType


class weaknessesRefType(GeneratedsSuper):
    member_data_items_ = {
        'weakness': MemberSpec_('weakness', 'weaknessRefType', 1, 1, {'type': 'weaknessRefType', 'name': 'weakness', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, weakness=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if weakness is None:
            self.weakness = []
        else:
            self.weakness = weakness
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, weaknessesRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if weaknessesRefType.subclass:
            return weaknessesRefType.subclass(*args_, **kwargs_)
        else:
            return weaknessesRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weakness(self):
        return self.weakness
    def set_weakness(self, weakness):
        self.weakness = weakness
    def add_weakness(self, value):
        self.weakness.append(value)
    def add_weakness(self, value):
        self.weakness.append(value)
    def insert_weakness_at(self, index, value):
        self.weakness.insert(index, value)
    def replace_weakness_at(self, index, value):
        self.weakness[index] = value
    def hasContent_(self):
        if (
            self.weakness
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='weaknessesRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('weaknessesRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='weaknessesRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='weaknessesRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='weaknessesRefType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='weaknessesRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for weakness_ in self.weakness:
            weakness_.export(outfile, level, namespaceprefix_, name_='weakness', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weakness':
            obj_ = weaknessRefType.factory(parent_object_=self)
            obj_.build(child_)
            self.weakness.append(obj_)
            obj_.original_tagname_ = 'weakness'
# end class weaknessesRefType


class weaknessRefType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'controls': MemberSpec_('controls', 'controlsRefType', 0, 0, {'type': 'controlsRefType', 'name': 'controls'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, controls=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.controls = controls
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, weaknessRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if weaknessRefType.subclass:
            return weaknessRefType.subclass(*args_, **kwargs_)
        else:
            return weaknessRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_controls(self):
        return self.controls
    def set_controls(self, controls):
        self.controls = controls
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def hasContent_(self):
        if (
            self.controls is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='weaknessRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('weaknessRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='weaknessRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='weaknessRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='weaknessRefType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='weaknessRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.controls is not None:
            self.controls.export(outfile, level, namespaceprefix_, namespacedef_, name_='controls', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'controls':
            obj_ = controlsRefType.factory(parent_object_=self)
            obj_.build(child_)
            self.controls = obj_
            obj_.original_tagname_ = 'controls'
# end class weaknessRefType


class controlsRefType(GeneratedsSuper):
    member_data_items_ = {
        'control': MemberSpec_('control', 'controlRefType', 1, 1, {'type': 'controlRefType', 'name': 'control', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, control=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if control is None:
            self.control = []
        else:
            self.control = control
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, controlsRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if controlsRefType.subclass:
            return controlsRefType.subclass(*args_, **kwargs_)
        else:
            return controlsRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def hasContent_(self):
        if (
            self.control
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controlsRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('controlsRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='controlsRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='controlsRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='controlsRefType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controlsRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            control_.export(outfile, level, namespaceprefix_, name_='control', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'control':
            obj_ = controlRefType.factory(parent_object_=self)
            obj_.build(child_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
# end class controlsRefType


class controlRefType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'mitigation': MemberSpec_('mitigation', 'xs:integer', 0, 0, {'use': 'required'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, mitigation=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.mitigation = _cast(int, mitigation)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, controlRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if controlRefType.subclass:
            return controlRefType.subclass(*args_, **kwargs_)
        else:
            return controlRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_mitigation(self):
        return self.mitigation
    def set_mitigation(self, mitigation):
        self.mitigation = mitigation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controlRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('controlRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='controlRefType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='controlRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='controlRefType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.mitigation is not None and 'mitigation' not in already_processed:
            already_processed.add('mitigation')
            outfile.write(' mitigation="%s"' % self.gds_format_integer(self.mitigation, input_name='mitigation'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='controlRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('mitigation', node)
        if value is not None and 'mitigation' not in already_processed:
            already_processed.add('mitigation')
            try:
                self.mitigation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class controlRefType


class categoryComponentsType(GeneratedsSuper):
    member_data_items_ = {
        'categoryComponent': MemberSpec_('categoryComponent', 'categoryComponentType', 1, 1, {'type': 'categoryComponentType', 'name': 'categoryComponent', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, categoryComponent=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if categoryComponent is None:
            self.categoryComponent = []
        else:
            self.categoryComponent = categoryComponent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, categoryComponentsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if categoryComponentsType.subclass:
            return categoryComponentsType.subclass(*args_, **kwargs_)
        else:
            return categoryComponentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_categoryComponent(self):
        return self.categoryComponent
    def set_categoryComponent(self, categoryComponent):
        self.categoryComponent = categoryComponent
    def add_categoryComponent(self, value):
        self.categoryComponent.append(value)
    def add_categoryComponent(self, value):
        self.categoryComponent.append(value)
    def insert_categoryComponent_at(self, index, value):
        self.categoryComponent.insert(index, value)
    def replace_categoryComponent_at(self, index, value):
        self.categoryComponent[index] = value
    def hasContent_(self):
        if (
            self.categoryComponent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='categoryComponentsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('categoryComponentsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='categoryComponentsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='categoryComponentsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='categoryComponentsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='categoryComponentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for categoryComponent_ in self.categoryComponent:
            categoryComponent_.export(outfile, level, namespaceprefix_, name_='categoryComponent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'categoryComponent':
            obj_ = categoryComponentType.factory(parent_object_=self)
            obj_.build(child_)
            self.categoryComponent.append(obj_)
            obj_.original_tagname_ = 'categoryComponent'
# end class categoryComponentsType


class categoryComponentType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, name=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, categoryComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if categoryComponentType.subclass:
            return categoryComponentType.subclass(*args_, **kwargs_)
        else:
            return categoryComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='categoryComponentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('categoryComponentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='categoryComponentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='categoryComponentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='categoryComponentType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='categoryComponentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class categoryComponentType


class componentDefinitionsType(GeneratedsSuper):
    member_data_items_ = {
        'componentDefinition': MemberSpec_('componentDefinition', 'componentDefinitionType', 1, 1, {'type': 'componentDefinitionType', 'name': 'componentDefinition', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, componentDefinition=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if componentDefinition is None:
            self.componentDefinition = []
        else:
            self.componentDefinition = componentDefinition
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentDefinitionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentDefinitionsType.subclass:
            return componentDefinitionsType.subclass(*args_, **kwargs_)
        else:
            return componentDefinitionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentDefinition(self):
        return self.componentDefinition
    def set_componentDefinition(self, componentDefinition):
        self.componentDefinition = componentDefinition
    def add_componentDefinition(self, value):
        self.componentDefinition.append(value)
    def open(self, value):
        self.componentDefinition.append(value)
    def insert_componentDefinition_at(self, index, value):
        self.componentDefinition.insert(index, value)
    def replace_componentDefinition_at(self, index, value):
        self.componentDefinition[index] = value
    def hasContent_(self):
        if (
            self.componentDefinition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='componentDefinitionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentDefinitionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='componentDefinitionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='componentDefinitionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='componentDefinitionsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='componentDefinitionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for componentDefinition_ in self.componentDefinition:
            componentDefinition_.export(outfile, level, namespaceprefix_, name_='componentDefinition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'componentDefinition':
            obj_ = componentDefinitionType.factory(parent_object_=self)
            obj_.build(child_)
            self.componentDefinition.append(obj_)
            obj_.original_tagname_ = 'componentDefinition'
# end class componentDefinitionsType


class componentDefinitionType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'desc': MemberSpec_('desc', 'xs:string', 0, 0, {'use': 'required'}),
        'categoryRef': MemberSpec_('categoryRef', 'xs:string', 0, 0, {'use': 'required'}),
        'riskPatterns': MemberSpec_('riskPatterns', 'riskPatternsType', 0, 0, {'type': 'riskPatternsType', 'name': 'riskPatterns'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, name=None, desc=None, categoryRef=None, riskPatterns=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.name = _cast(None, name)
        self.desc = _cast(None, desc)
        self.categoryRef = _cast(None, categoryRef)
        self.riskPatterns = riskPatterns
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentDefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentDefinitionType.subclass:
            return componentDefinitionType.subclass(*args_, **kwargs_)
        else:
            return componentDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_riskPatterns(self):
        return self.riskPatterns
    def set_riskPatterns(self, riskPatterns):
        self.riskPatterns = riskPatterns
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_categoryRef(self):
        return self.categoryRef
    def set_categoryRef(self, categoryRef):
        self.categoryRef = categoryRef
    def hasContent_(self):
        if (
            self.riskPatterns is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='componentDefinitionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentDefinitionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='componentDefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='componentDefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='componentDefinitionType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.desc is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            outfile.write(' desc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.desc), input_name='desc')), ))
        if self.categoryRef is not None and 'categoryRef' not in already_processed:
            already_processed.add('categoryRef')
            outfile.write(' categoryRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.categoryRef), input_name='categoryRef')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='componentDefinitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.riskPatterns is not None:
            self.riskPatterns.export(outfile, level, namespaceprefix_, namespacedef_, name_='riskPatterns', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('desc', node)
        if value is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            self.desc = value
        value = find_attr_value_('categoryRef', node)
        if value is not None and 'categoryRef' not in already_processed:
            already_processed.add('categoryRef')
            self.categoryRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'riskPatterns':
            obj_ = riskPatternsType.factory(parent_object_=self)
            obj_.build(child_)
            self.riskPatterns = obj_
            obj_.original_tagname_ = 'riskPatterns'
# end class componentDefinitionType


class riskPatternsType(GeneratedsSuper):
    member_data_items_ = {
        'riskPattern': MemberSpec_('riskPattern', 'riskPatternType', 1, 1, {'type': 'riskPatternType', 'name': 'riskPattern', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, riskPattern=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if riskPattern is None:
            self.riskPattern = []
        else:
            self.riskPattern = riskPattern
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, riskPatternsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if riskPatternsType.subclass:
            return riskPatternsType.subclass(*args_, **kwargs_)
        else:
            return riskPatternsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_riskPattern(self):
        return self.riskPattern
    def set_riskPattern(self, riskPattern):
        self.riskPattern = riskPattern
    def add_riskPattern(self, value):
        self.riskPattern.append(value)
    def add_riskPattern(self, value):
        self.riskPattern.append(value)
    def insert_riskPattern_at(self, index, value):
        self.riskPattern.insert(index, value)
    def replace_riskPattern_at(self, index, value):
        self.riskPattern[index] = value
    def hasContent_(self):
        if (
            self.riskPattern
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='riskPatternsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('riskPatternsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='riskPatternsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='riskPatternsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='riskPatternsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='riskPatternsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for riskPattern_ in self.riskPattern:
            riskPattern_.export(outfile, level, namespaceprefix_, name_='riskPattern', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'riskPattern':
            obj_ = riskPatternType.factory(parent_object_=self)
            obj_.build(child_)
            self.riskPattern.append(obj_)
            obj_.original_tagname_ = 'riskPattern'
# end class riskPatternsType


class riskPatternType(GeneratedsSuper):
    member_data_items_ = {
        'ref': MemberSpec_('ref', 'xs:string', 0, 0, {'use': 'required'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, ref=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ref = _cast(None, ref)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, riskPatternType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if riskPatternType.subclass:
            return riskPatternType.subclass(*args_, **kwargs_)
        else:
            return riskPatternType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='riskPatternType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('riskPatternType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='riskPatternType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='riskPatternType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='riskPatternType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='riskPatternType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class riskPatternType


class rulesType(GeneratedsSuper):
    member_data_items_ = {
        'rule': MemberSpec_('rule', 'ruleType', 1, 1, {'type': 'ruleType', 'name': 'rule', 'maxOccurs': 'unbounded', 'minOccurs': '0'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, rule=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if rule is None:
            self.rule = []
        else:
            self.rule = rule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rulesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rulesType.subclass:
            return rulesType.subclass(*args_, **kwargs_)
        else:
            return rulesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rule(self):
        return self.rule
    def set_rule(self, rule):
        self.rule = rule
    def add_rule(self, value):
        self.rule.append(value)
    def add_rule(self, value):
        self.rule.append(value)
    def insert_rule_at(self, index, value):
        self.rule.insert(index, value)
    def replace_rule_at(self, index, value):
        self.rule[index] = value
    def hasContent_(self):
        if (
            self.rule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='rulesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rulesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rulesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='rulesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rulesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='rulesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rule_ in self.rule:
            rule_.export(outfile, level, namespaceprefix_, name_='rule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rule':
            obj_ = ruleType.factory(parent_object_=self)
            obj_.build(child_)
            self.rule.append(obj_)
            obj_.original_tagname_ = 'rule'
# end class rulesType


class ruleType(GeneratedsSuper):
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'module': MemberSpec_('module', 'xs:string', 0, 0, {'use': 'required'}),
        'generatedByGui': MemberSpec_('generatedByGui', 'xs:boolean', 0, 1, {'use': 'optional'}),
        'condition': MemberSpec_('condition', 'conditionType', 1, 1, {'type': 'conditionType', 'name': 'condition', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
        'action': MemberSpec_('action', 'actionType', 1, 1, {'type': 'actionType', 'name': 'action', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
        'content': MemberSpec_('content', 'xs:string', 1, 1, {'type': 'xs:string', 'name': 'content', 'minOccurs': '0', 'maxOccurs': 'unbounded'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, module=None, generatedByGui=None, condition=None, action=None, content=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.module = _cast(None, module)
        self.generatedByGui = _cast(bool, generatedByGui)
        if condition is None:
            self.condition = []
        else:
            self.condition = condition
        if action is None:
            self.action = []
        else:
            self.action = action
        if content is None:
            self.content = []
        else:
            self.content = content
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ruleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ruleType.subclass:
            return ruleType.subclass(*args_, **kwargs_)
        else:
            return ruleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_condition(self):
        return self.condition
    def set_condition(self, condition):
        self.condition = condition
    def add_condition(self, value):
        self.condition.append(value)
    def add_condition(self, value):
        self.condition.append(value)
    def insert_condition_at(self, index, value):
        self.condition.insert(index, value)
    def replace_condition_at(self, index, value):
        self.condition[index] = value
    def get_action(self):
        return self.action
    def set_action(self, action):
        self.action = action
    def add_action(self, value):
        self.action.append(value)
    def add_action(self, value):
        self.action.append(value)
    def insert_action_at(self, index, value):
        self.action.insert(index, value)
    def replace_action_at(self, index, value):
        self.action[index] = value
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_module(self):
        return self.module
    def set_module(self, module):
        self.module = module
    def get_generatedByGui(self):
        return self.generatedByGui
    def set_generatedByGui(self, generatedByGui):
        self.generatedByGui = generatedByGui
    def hasContent_(self):
        if (
            self.condition or
            self.action or
            self.content
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ruleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ruleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ruleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ruleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ruleType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.module is not None and 'module' not in already_processed:
            already_processed.add('module')
            outfile.write(' module=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.module), input_name='module')), ))
        if self.generatedByGui is not None and 'generatedByGui' not in already_processed:
            already_processed.add('generatedByGui')
            outfile.write(' generatedByGui="%s"' % self.gds_format_boolean(self.generatedByGui, input_name='generatedByGui'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ruleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for condition_ in self.condition:
            condition_.export(outfile, level, namespaceprefix_, name_='condition', pretty_print=pretty_print)
        for action_ in self.action:
            action_.export(outfile, level, namespaceprefix_, name_='action', pretty_print=pretty_print)
        for content_ in self.content:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontent>%s</%scontent>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(content_), input_name='content')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('module', node)
        if value is not None and 'module' not in already_processed:
            already_processed.add('module')
            self.module = value
        value = find_attr_value_('generatedByGui', node)
        if value is not None and 'generatedByGui' not in already_processed:
            already_processed.add('generatedByGui')
            if value in ('true', '1'):
                self.generatedByGui = True
            elif value in ('false', '0'):
                self.generatedByGui = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'condition':
            obj_ = conditionType.factory(parent_object_=self)
            obj_.build(child_)
            self.condition.append(obj_)
            obj_.original_tagname_ = 'condition'
        elif nodeName_ == 'action':
            obj_ = actionType.factory(parent_object_=self)
            obj_.build(child_)
            self.action.append(obj_)
            obj_.original_tagname_ = 'action'
        elif nodeName_ == 'content':
            content_ = child_.text
            content_ = self.gds_validate_string(content_, node, 'content')
            self.content.append(content_)
# end class ruleType


class conditionType(GeneratedsSuper):
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'type_': MemberSpec_('type_', 'xs:string', 0, 0, {'use': 'required'}),
        'field': MemberSpec_('field', 'xs:string', 0, 0, {'use': 'required'}),
        'value': MemberSpec_('value', 'xs:string', 0, 0, {'use': 'required'}),
        'pattern': MemberSpec_('pattern', 'patternType', 0, 0, {'type': 'patternType', 'name': 'pattern'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, type_=None, field=None, value=None, pattern=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.type_ = _cast(None, type_)
        self.field = _cast(None, field)
        self.value = _cast(None, value)
        self.pattern = pattern
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, conditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if conditionType.subclass:
            return conditionType.subclass(*args_, **kwargs_)
        else:
            return conditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pattern(self):
        return self.pattern
    def set_pattern(self, pattern):
        self.pattern = pattern
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            self.pattern is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='conditionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('conditionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='conditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='conditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='conditionType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='conditionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pattern is not None:
            self.pattern.export(outfile, level, namespaceprefix_, namespacedef_, name_='pattern', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pattern':
            obj_ = patternType.factory(parent_object_=self)
            obj_.build(child_)
            self.pattern = obj_
            obj_.original_tagname_ = 'pattern'
# end class conditionType


class patternType(GeneratedsSuper):
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'pattern': MemberSpec_('pattern', 'xs:string', 0, 0, {'use': 'required'}),
        'valueOf_': MemberSpec_('valueOf_', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, pattern=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.pattern = _cast(None, pattern)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, patternType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if patternType.subclass:
            return patternType.subclass(*args_, **kwargs_)
        else:
            return patternType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_pattern(self):
        return self.pattern
    def set_pattern(self, pattern):
        self.pattern = pattern
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='patternType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('patternType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='patternType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='patternType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='patternType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.pattern is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            outfile.write(' pattern=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pattern), input_name='pattern')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='patternType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('pattern', node)
        if value is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            self.pattern = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class patternType


class actionType(GeneratedsSuper):
    member_data_items_ = {
        'project': MemberSpec_('project', 'xs:string', 0, 0, {'use': 'required'}),
        'value': MemberSpec_('value', 'xs:string', 0, 0, {'use': 'required'}),
        'name': MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        'type_': MemberSpec_('type_', 'xs:string', 0, 0, {'use': 'required'}),
        'pattern': MemberSpec_('pattern', 'patternType', 0, 0, {'type': 'patternType', 'name': 'pattern'}, None),
    }
    subclass = None
    superclass = None
    def __init__(self, project=None, value=None, name=None, type_=None, pattern=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.project = _cast(None, project)
        self.value = _cast(None, value)
        self.name = _cast(None, name)
        self.type_ = _cast(None, type_)
        self.pattern = pattern
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, actionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if actionType.subclass:
            return actionType.subclass(*args_, **kwargs_)
        else:
            return actionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pattern(self):
        return self.pattern
    def set_pattern(self, pattern):
        self.pattern = pattern
    def get_project(self):
        return self.project
    def set_project(self, project):
        self.project = project
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def hasContent_(self):
        if (
            self.pattern is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='actionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('actionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='actionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='actionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='actionType'):
        if self.project is not None and 'project' not in already_processed:
            already_processed.add('project')
            outfile.write(' project=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.project), input_name='project')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='actionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pattern is not None:
            self.pattern.export(outfile, level, namespaceprefix_, namespacedef_, name_='pattern', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('project', node)
        if value is not None and 'project' not in already_processed:
            already_processed.add('project')
            self.project = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pattern':
            obj_ = patternType.factory(parent_object_=self)
            obj_.build(child_)
            self.pattern = obj_
            obj_.original_tagname_ = 'pattern'
# end class actionType


GDSClassesMapping = {
    'project': libraryType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'libraryType'
        rootClass = libraryType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'libraryType'
        rootClass = libraryType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'libraryType'
        rootClass = libraryType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'libraryType'
        rootClass = libraryType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from sample_lib import *\n\n')
        sys.stdout.write('import sample_lib as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "actionType",
    "assetRefType",
    "assetsRefType",
    "categoryComponentType",
    "categoryComponentsType",
    "componentDefinitionType",
    "componentDefinitionsType",
    "componentLibraryType",
    "componentsLibraryType",
    "conditionType",
    "controlLibraryType",
    "controlRefType",
    "controlsLibraryType",
    "controlsRefType",
    "dataflowType",
    "dataflowsType",
    "implementationType",
    "implementationsType",
    "libraryType",
    "patternType",
    "referenceType",
    "referencesType",
    "riskPatternType",
    "riskPatternsType",
    "riskRatingType",
    "ruleType",
    "rulesType",
    "sourceType",
    "standardType",
    "standardsType",
    "supportedStandardType",
    "supportedStandardsType",
    "testLibraryType",
    "threatLibraryType",
    "threatsLibraryType",
    "udtType",
    "udtsType",
    "usecaseLibraryType",
    "usecasesLibraryType",
    "weaknessLibraryType",
    "weaknessRefType",
    "weaknessesLibraryType",
    "weaknessesRefType"
]
