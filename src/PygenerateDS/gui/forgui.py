#!/usr/bin/env python
# -*- coding: utf-8 -*-

##VERSION##
VERSION = '2.22a'
##VERSION##

"""
FILE TRANSLATOR *.GLADE FOR GENERATEDS_GUI.

Usage:
    python forgui.py <The fully qualified name of the base file.glade> -c <The fully qualified name of the base file.dictionary>

    python forgui.py <The fully qualified name of the base file.glade> -d  <The fully qualified name of the language file.dictionary>
    
Example:
    Step1: Create a base file dictionary interface based on generateds_gui.glade
        >>>python forgui.py d:\Python33\Scripts\generateds_gui.glade -c d:\Python33\Scripts\en.dictionary
        
    Step2: Open the resulting file <..\en.dictionary> and translate into Russian language. Keep under the name <..\rus.dictionary>.
    
               <English key> [<-|->] <Language value>
               
           ... User methods module:<-|->Пользовательский модуль методов:
           ... Validator bodies path:<-|->Путь корпусов контрольного устройства:
           ... _Capture CL<-|->_Capture CL
           ... _File<-|->_Файл
           ... _Generate<-|->_Произвести
           ... _Help<-|->_Помощь
           ... _Tools<-|->_Инструменты
           ............................
    
    Step3: Create a new file based on glade generateds_gui. glade using dictionary Eng. dictionary. At the output of the get file .glade generateds_gui_rus.
        >>>python forgui.py d:\Python33\Scripts\generateds_gui.glade -d  d:\Python33\Scripts\rus.dictionary 
"""
#
# Generated Tue Apr 19 17:15:20 2016 by generateDS.py version 2.22a.
#
# Command line options:
#   ('--no-questions', '')
#   ('-f', '')
#   ('-o', 'D:\\Python33\\Scripts\\forGUI.py')
#   ('--external-encoding', 'utf-8')
#
# Command line arguments:
#   D:\Python33\Scripts\forGUI.xsd
#
# Command line:
#   d:\Python33\Scripts\generateDS.py --no-questions -f -o "D:\Python33\Scripts\forGUI.py" --external-encoding="utf-8" D:\Python33\Scripts\forGUI.xsd
#
# Current working directory (os.getcwd()):
#   Scripts
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_

#----------------------------------USER FUNCTION----------------------------------------------
import os.path 
LIST_HELPNAMES = {}

def create_dictfiles(args):
    s = list(LIST_HELPNAMES.keys())
    s.sort()
    start_dictfile = open(str(args[2]), 'w', encoding='utf-8')
    for e in s:
        print('''%s<-|->%s''' % (e.replace('\n', ' '),e), file=start_dictfile)
    start_dictfile.close()
        
def read_dictfiles(args):
    dict_file = open(args[2], 'r', encoding='utf-8')
    d = {}
    list_d = dict_file.readlines()
    for s in list_d:
        e = s.split("<-|->")
        d[e[0].replace('\\n', ' ')] = d.get(e[0].replace('\\n', ' '), re_.sub(r'\n$','',e[1]))
    dict_file.close()
    return d

def appLIST_HELPNAMES(inst):
    re_n = re_.compile(r'(.*\n.*)')
    if len(inst.valueOf_) > 0:
        rs = inst.valueOf_.replace('\n', '\\n')
        rkey = rs.replace('\\n', ' ')
        LIST_HELPNAMES[rkey] = LIST_HELPNAMES.get(rkey, rs)
        inst.valueOf_ = re_.sub(r'\n$','', LIST_HELPNAMES[rkey].replace('\\n', '\n')) 

#----------------------------------------------------------------------------------------------

Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class interface(GeneratedsSuper):
    """Generated with glade 3.18.3"""
    subclass = None
    superclass = None
    def __init__(self, requires=None, object=None):
        self.original_tagname_ = None
        self.requires = requires
        if object is None:
            self.object = []
        else:
            self.object = object
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interface.subclass:
            return interface.subclass(*args_, **kwargs_)
        else:
            return interface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_requires(self): return self.requires
    def set_requires(self, requires): self.requires = requires
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def add_object(self, value): self.object.append(value)
    def insert_object_at(self, index, value): self.object.insert(index, value)
    def replace_object_at(self, index, value): self.object[index] = value
    def hasContent_(self):
        if (
            self.requires is not None or
            self.object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='interface', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interface')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='interface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='interface'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='interface', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.requires is not None:
            self.requires.export(outfile, level, namespace_, name_='requires', pretty_print=pretty_print)
        for object_ in self.object:
            object_.export(outfile, level, namespace_, name_='object', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'requires':
            obj_ = requiresType.factory()
            obj_.build(child_)
            self.requires = obj_
            obj_.original_tagname_ = 'requires'
        elif nodeName_ == 'object':
            obj_ = objectType.factory()
            obj_.build(child_)
            self.object.append(obj_)
            obj_.original_tagname_ = 'object'
# end class interface


class requiresType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lib=None, version=None, valueOf_=None):
        self.original_tagname_ = None
        self.lib = _cast(None, lib)
        self.version = _cast(float, version)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, requiresType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if requiresType.subclass:
            return requiresType.subclass(*args_, **kwargs_)
        else:
            return requiresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lib(self): return self.lib
    def set_lib(self, lib): self.lib = lib
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='requiresType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='requiresType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='requiresType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='requiresType'):
        if self.lib is not None and 'lib' not in already_processed:
            already_processed.add('lib')
            outfile.write(' lib=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lib), input_name='lib')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_float(self.version, input_name='version'))
    def exportChildren(self, outfile, level, namespace_='', name_='requiresType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lib', node)
        if value is not None and 'lib' not in already_processed:
            already_processed.add('lib')
            self.lib = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (version): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class requiresType


class objectType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, class_=None, id=None, property=None, accel_groups=None, signal=None, child=None, action_widgets=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.class_ = _cast(None, class_)
        self.id = _cast(None, id)
        if property is None:
            self.property = []
        else:
            self.property = property
        self.accel_groups = accel_groups
        self.signal = signal
        self.child = child
        self.action_widgets = action_widgets
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, objectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if objectType.subclass:
            return objectType.subclass(*args_, **kwargs_)
        else:
            return objectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def get_accel_groups(self): return self.accel_groups
    def set_accel_groups(self, accel_groups): self.accel_groups = accel_groups
    def get_signal(self): return self.signal
    def set_signal(self, signal): self.signal = signal
    def get_child(self): return self.child
    def set_child(self, child): self.child = child
    def get_action_widgets(self): return self.action_widgets
    def set_action_widgets(self, action_widgets): self.action_widgets = action_widgets
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.property or
            self.accel_groups is not None or
            self.signal is not None or
            self.child is not None or
            self.action_widgets is not None or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='objectType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='objectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='objectType'):
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='objectType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = propertyType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'property', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_property'):
              self.add_property(obj_.value)
            elif hasattr(self, 'set_property'):
              self.set_property(obj_.value)
        elif nodeName_ == 'accel-groups':
            obj_ = accel_groupsType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'accel-groups', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_accel-groups'):
              self.add_accel-groups(obj_.value)
            elif hasattr(self, 'set_accel-groups'):
              self.set_accel-groups(obj_.value)
        elif nodeName_ == 'signal':
            obj_ = signalType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'signal', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_signal'):
              self.add_signal(obj_.value)
            elif hasattr(self, 'set_signal'):
              self.set_signal(obj_.value)
        elif nodeName_ == 'child':
            obj_ = childType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'child', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_child'):
              self.add_child(obj_.value)
            elif hasattr(self, 'set_child'):
              self.set_child(obj_.value)
        elif nodeName_ == 'action-widgets':
            obj_ = action_widgetsType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'action-widgets', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_action-widgets'):
              self.add_action-widgets(obj_.value)
            elif hasattr(self, 'set_action-widgets'):
              self.set_action-widgets(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class objectType


class propertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, translatable=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.translatable = _cast(None, translatable)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType.subclass:
            return propertyType.subclass(*args_, **kwargs_)
        else:
            return propertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_translatable(self): return self.translatable
    def set_translatable(self, translatable): self.translatable = translatable
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='propertyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, rv_isbool(namespacedef_) and ' ' + rv_isbool(namespacedef_) or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='propertyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propertyType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.translatable is not None and 'translatable' not in already_processed:
            already_processed.add('translatable')

            appLIST_HELPNAMES(self)
            outfile.write(' translatable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.translatable), input_name='translatable')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='propertyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('translatable', node)
        if value is not None and 'translatable' not in already_processed:
            already_processed.add('translatable')

            self.translatable = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass

def rv_isbool(namespacedef_):
    if isinstance(namespacedef_, bool):
        namespacedef_ = ''
    return namespacedef_

# end class propertyType


class accel_groupsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, group=None):
        self.original_tagname_ = None
        self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accel_groupsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accel_groupsType.subclass:
            return accel_groupsType.subclass(*args_, **kwargs_)
        else:
            return accel_groupsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def hasContent_(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='accel-groupsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, rv_isbool(namespacedef_) and ' ' + rv_isbool(namespacedef_) or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accel-groupsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='accel-groupsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='accel-groupsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='accel-groupsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            self.group.export(outfile, level, namespace_, name_='group', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            obj_ = groupType.factory()
            obj_.build(child_)
            self.group = obj_
            obj_.original_tagname_ = 'group'
# end class accel_groupsType


class groupType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupType.subclass:
            return groupType.subclass(*args_, **kwargs_)
        else:
            return groupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='groupType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='groupType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='groupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='groupType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='groupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class groupType


class signalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, handler=None, swapped=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.handler = _cast(None, handler)
        self.swapped = _cast(None, swapped)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signalType.subclass:
            return signalType.subclass(*args_, **kwargs_)
        else:
            return signalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_handler(self): return self.handler
    def set_handler(self, handler): self.handler = handler
    def get_swapped(self): return self.swapped
    def set_swapped(self, swapped): self.swapped = swapped
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='signalType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, rv_isbool(namespacedef_) and ' ' + rv_isbool(namespacedef_) or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='signalType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='signalType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='signalType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.handler is not None and 'handler' not in already_processed:
            already_processed.add('handler')
            outfile.write(' handler=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.handler), input_name='handler')), ))
        if self.swapped is not None and 'swapped' not in already_processed:
            already_processed.add('swapped')
            outfile.write(' swapped=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.swapped), input_name='swapped')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='signalType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('handler', node)
        if value is not None and 'handler' not in already_processed:
            already_processed.add('handler')
            self.handler = value
        value = find_attr_value_('swapped', node)
        if value is not None and 'swapped' not in already_processed:
            already_processed.add('swapped')
            self.swapped = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class signalType


class childType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, internal_child=None, object=None):
        self.original_tagname_ = None
        self.internal_child = _cast(None, internal_child)
        self.object = object
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, childType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if childType.subclass:
            return childType.subclass(*args_, **kwargs_)
        else:
            return childType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_internal_child(self): return self.internal_child
    def set_internal_child(self, internal_child): self.internal_child = internal_child
    def hasContent_(self):
        if (
            self.object is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='childType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, rv_isbool(namespacedef_) and ' ' + rv_isbool(namespacedef_) or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='childType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='childType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='childType'):
        if self.internal_child is not None and 'internal_child' not in already_processed:
            already_processed.add('internal_child')
            outfile.write(' internal-child=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.internal_child), input_name='internal-child')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='childType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object is not None:
            self.object.export(outfile, level, namespace_, name_='object', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('internal-child', node)
        if value is not None and 'internal-child' not in already_processed:
            already_processed.add('internal-child')
            self.internal_child = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object':
            obj_ = objectType1.factory()
            obj_.build(child_)
            self.object = obj_
            obj_.original_tagname_ = 'object'
# end class childType


class objectType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, class_=None, id=None, property=None, child=None):
        self.original_tagname_ = None
        self.class_ = _cast(None, class_)
        self.id = _cast(None, id)
        if property is None:
            self.property = []
        else:
            self.property = property
        if child is None:
            self.child = []
        else:
            self.child = child
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, objectType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if objectType1.subclass:
            return objectType1.subclass(*args_, **kwargs_)
        else:
            return objectType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def get_child(self): return self.child
    def set_child(self, child): self.child = child
    def add_child(self, value): self.child.append(value)
    def insert_child_at(self, index, value): self.child.insert(index, value)
    def replace_child_at(self, index, value): self.child[index] = value
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.property or
            self.child
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='objectType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objectType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='objectType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='objectType1'):
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='objectType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
        for child_ in self.child:
            child_.export(outfile, level, namespace_, name_='child', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = propertyType2.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
        elif nodeName_ == 'child':
            obj_ = childType3.factory()
            obj_.build(child_)
            self.child.append(obj_)
            obj_.original_tagname_ = 'child'
# end class objectType1


class propertyType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType2.subclass:
            return propertyType2.subclass(*args_, **kwargs_)
        else:
            return propertyType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='propertyType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyType2')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='propertyType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propertyType2'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='propertyType2', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyType2


class childType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, internal_child=None, object=None, packing=None, placeholder=None):
        self.original_tagname_ = None
        self.internal_child = _cast(None, internal_child)
        self.object = object
        self.packing = packing
        self.placeholder = placeholder
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, childType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if childType3.subclass:
            return childType3.subclass(*args_, **kwargs_)
        else:
            return childType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_packing(self): return self.packing
    def set_packing(self, packing): self.packing = packing
    def get_placeholder(self): return self.placeholder
    def set_placeholder(self, placeholder): self.placeholder = placeholder
    def get_internal_child(self): return self.internal_child
    def set_internal_child(self, internal_child): self.internal_child = internal_child
    def hasContent_(self):
        if (
            self.object is not None or
            self.packing is not None or
            self.placeholder is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='childType3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='childType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='childType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='childType3'):
        if self.internal_child is not None and 'internal_child' not in already_processed:
            already_processed.add('internal_child')
            outfile.write(' internal-child=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.internal_child), input_name='internal-child')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='childType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object is not None:
            self.object.export(outfile, level, namespace_, name_='object', pretty_print=pretty_print)
        if self.packing is not None:
            self.packing.export(outfile, level, namespace_, name_='packing', pretty_print=pretty_print)
        if self.placeholder is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splaceholder>%s</%splaceholder>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.placeholder), input_name='placeholder')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('internal-child', node)
        if value is not None and 'internal-child' not in already_processed:
            already_processed.add('internal-child')
            self.internal_child = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object':
            obj_ = objectType4.factory()
            obj_.build(child_)
            self.object = obj_
            obj_.original_tagname_ = 'object'
        elif nodeName_ == 'packing':
            obj_ = packingType21.factory()
            obj_.build(child_)
            self.packing = obj_
            obj_.original_tagname_ = 'packing'
        elif nodeName_ == 'placeholder':
            placeholder_ = child_.text
            placeholder_ = self.gds_validate_string(placeholder_, node, 'placeholder')
            self.placeholder = placeholder_
# end class childType3


class objectType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, class_=None, id=None, property=None, child=None):
        self.original_tagname_ = None
        self.class_ = _cast(None, class_)
        self.id = _cast(None, id)
        if property is None:
            self.property = []
        else:
            self.property = property
        if child is None:
            self.child = []
        else:
            self.child = child
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, objectType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if objectType4.subclass:
            return objectType4.subclass(*args_, **kwargs_)
        else:
            return objectType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def get_child(self): return self.child
    def set_child(self, child): self.child = child
    def add_child(self, value): self.child.append(value)
    def insert_child_at(self, index, value): self.child.insert(index, value)
    def replace_child_at(self, index, value): self.child[index] = value
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.property or
            self.child
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='objectType4', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objectType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='objectType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='objectType4'):
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='objectType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
        for child_ in self.child:
            child_.export(outfile, level, namespace_, name_='child', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = propertyType5.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
        elif nodeName_ == 'child':
            obj_ = childType6.factory()
            obj_.build(child_)
            self.child.append(obj_)
            obj_.original_tagname_ = 'child'
# end class objectType4


class propertyType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType5.subclass:
            return propertyType5.subclass(*args_, **kwargs_)
        else:
            return propertyType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='propertyType5', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyType5')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='propertyType5', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propertyType5'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='propertyType5', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyType5


class childType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, object=None, packing=None):
        self.original_tagname_ = None
        self.object = object
        self.packing = packing
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, childType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if childType6.subclass:
            return childType6.subclass(*args_, **kwargs_)
        else:
            return childType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_packing(self): return self.packing
    def set_packing(self, packing): self.packing = packing
    def hasContent_(self):
        if (
            self.object is not None or
            self.packing is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='childType6', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='childType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='childType6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='childType6'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='childType6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object is not None:
            self.object.export(outfile, level, namespace_, name_='object', pretty_print=pretty_print)
        if self.packing is not None:
            self.packing.export(outfile, level, namespace_, name_='packing', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object':
            obj_ = objectType7.factory()
            obj_.build(child_)
            self.object = obj_
            obj_.original_tagname_ = 'object'
        elif nodeName_ == 'packing':
            obj_ = packingType19.factory()
            obj_.build(child_)
            self.packing = obj_
            obj_.original_tagname_ = 'packing'
# end class childType6


class objectType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, class_=None, id=None, property=None, child=None, signal=None):
        self.original_tagname_ = None
        self.class_ = _cast(None, class_)
        self.id = _cast(None, id)
        if property is None:
            self.property = []
        else:
            self.property = property
        self.child = child
        self.signal = signal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, objectType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if objectType7.subclass:
            return objectType7.subclass(*args_, **kwargs_)
        else:
            return objectType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def get_child(self): return self.child
    def set_child(self, child): self.child = child
    def get_signal(self): return self.signal
    def set_signal(self, signal): self.signal = signal
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.property or
            self.child is not None or
            self.signal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='objectType7', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objectType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='objectType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='objectType7'):
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='objectType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
        if self.child is not None:
            self.child.export(outfile, level, namespace_, name_='child', pretty_print=pretty_print)
        if self.signal is not None:
            self.signal.export(outfile, level, namespace_, name_='signal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = propertyType8.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
        elif nodeName_ == 'child':
            obj_ = childType9.factory()
            obj_.build(child_)
            self.child = obj_
            obj_.original_tagname_ = 'child'
        elif nodeName_ == 'signal':
            obj_ = signalType18.factory()
            obj_.build(child_)
            self.signal = obj_
            obj_.original_tagname_ = 'signal'
# end class objectType7


class propertyType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, translatable=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.translatable = _cast(None, translatable)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType8.subclass:
            return propertyType8.subclass(*args_, **kwargs_)
        else:
            return propertyType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_translatable(self): return self.translatable
    def set_translatable(self, translatable): self.translatable = translatable
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='propertyType8', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyType8')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='propertyType8', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propertyType8'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.translatable is not None and 'translatable' not in already_processed:
            already_processed.add('translatable')
            appLIST_HELPNAMES(self)
            outfile.write(' translatable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.translatable), input_name='translatable')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='propertyType8', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('translatable', node)
        if value is not None and 'translatable' not in already_processed:
            already_processed.add('translatable')
            
            self.translatable = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyType8


class childType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, object=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.object = object
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, childType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if childType9.subclass:
            return childType9.subclass(*args_, **kwargs_)
        else:
            return childType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.object is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='childType9', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='childType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='childType9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='childType9'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='childType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object is not None:
            self.object.export(outfile, level, namespace_, name_='object', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object':
            obj_ = objectType10.factory()
            obj_.build(child_)
            self.object = obj_
            obj_.original_tagname_ = 'object'
# end class childType9


class objectType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, class_=None, id=None, property=None, child=None):
        self.original_tagname_ = None
        self.class_ = _cast(None, class_)
        self.id = _cast(None, id)
        if property is None:
            self.property = []
        else:
            self.property = property
        if child is None:
            self.child = []
        else:
            self.child = child
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, objectType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if objectType10.subclass:
            return objectType10.subclass(*args_, **kwargs_)
        else:
            return objectType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def get_child(self): return self.child
    def set_child(self, child): self.child = child
    def add_child(self, value): self.child.append(value)
    def insert_child_at(self, index, value): self.child.insert(index, value)
    def replace_child_at(self, index, value): self.child[index] = value
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.property or
            self.child
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='objectType10', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objectType10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='objectType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='objectType10'):
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='objectType10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
        for child_ in self.child:
            child_.export(outfile, level, namespace_, name_='child', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = propertyType11.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
        elif nodeName_ == 'child':
            obj_ = childType12.factory()
            obj_.build(child_)
            self.child.append(obj_)
            obj_.original_tagname_ = 'child'
# end class objectType10


class propertyType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType11.subclass:
            return propertyType11.subclass(*args_, **kwargs_)
        else:
            return propertyType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='propertyType11', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyType11')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='propertyType11', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propertyType11'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='propertyType11', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyType11


class childType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, placeholder=None, object=None, packing=None):
        self.original_tagname_ = None
        self.placeholder = placeholder
        self.object = object
        self.packing = packing
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, childType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if childType12.subclass:
            return childType12.subclass(*args_, **kwargs_)
        else:
            return childType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_placeholder(self): return self.placeholder
    def set_placeholder(self, placeholder): self.placeholder = placeholder
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_packing(self): return self.packing
    def set_packing(self, packing): self.packing = packing
    def hasContent_(self):
        if (
            self.placeholder is not None or
            self.object is not None or
            self.packing is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='childType12', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='childType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='childType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='childType12'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='childType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.placeholder is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splaceholder>%s</%splaceholder>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.placeholder), input_name='placeholder')), namespace_, eol_))
        if self.object is not None:
            self.object.export(outfile, level, namespace_, name_='object', pretty_print=pretty_print)
        if self.packing is not None:
            self.packing.export(outfile, level, namespace_, name_='packing', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'placeholder':
            placeholder_ = child_.text
            placeholder_ = self.gds_validate_string(placeholder_, node, 'placeholder')
            self.placeholder = placeholder_
        elif nodeName_ == 'object':
            obj_ = objectType13.factory()
            obj_.build(child_)
            self.object = obj_
            obj_.original_tagname_ = 'object'
        elif nodeName_ == 'packing':
            obj_ = packingType.factory()
            obj_.build(child_)
            self.packing = obj_
            obj_.original_tagname_ = 'packing'
# end class childType12


class objectType13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, class_=None, id=None, property=None, signal=None, accelerator=None, child=None):
        self.original_tagname_ = None
        self.class_ = _cast(None, class_)
        self.id = _cast(None, id)
        if property is None:
            self.property = []
        else:
            self.property = property
        self.signal = signal
        self.accelerator = accelerator
        self.child = child
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, objectType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if objectType13.subclass:
            return objectType13.subclass(*args_, **kwargs_)
        else:
            return objectType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def get_signal(self): return self.signal
    def set_signal(self, signal): self.signal = signal
    def get_accelerator(self): return self.accelerator
    def set_accelerator(self, accelerator): self.accelerator = accelerator
    def get_child(self): return self.child
    def set_child(self, child): self.child = child
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.property or
            self.signal is not None or
            self.accelerator is not None or
            self.child is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='objectType13', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objectType13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='objectType13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='objectType13'):
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='objectType13', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
        if self.signal is not None:
            self.signal.export(outfile, level, namespace_, name_='signal', pretty_print=pretty_print)
        if self.accelerator is not None:
            self.accelerator.export(outfile, level, namespace_, name_='accelerator', pretty_print=pretty_print)
        if self.child is not None:
            self.child.export(outfile, level, namespace_, name_='child', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = propertyType14.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
        elif nodeName_ == 'signal':
            obj_ = signalType15.factory()
            obj_.build(child_)
            self.signal = obj_
            obj_.original_tagname_ = 'signal'
        elif nodeName_ == 'accelerator':
            obj_ = acceleratorType.factory()
            obj_.build(child_)
            self.accelerator = obj_
            obj_.original_tagname_ = 'accelerator'
        elif nodeName_ == 'child':
            obj_ = childType16.factory()
            obj_.build(child_)
            self.child = obj_
            obj_.original_tagname_ = 'child'
# end class objectType13


class propertyType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, translatable=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.translatable = _cast(None, translatable)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType14.subclass:
            return propertyType14.subclass(*args_, **kwargs_)
        else:
            return propertyType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_translatable(self): return self.translatable
    def set_translatable(self, translatable): self.translatable = translatable
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='propertyType14', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyType14')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='propertyType14', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propertyType14'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.translatable is not None and 'translatable' not in already_processed:
            already_processed.add('translatable')
            appLIST_HELPNAMES(self)
            outfile.write(' translatable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.translatable), input_name='translatable')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='propertyType14', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('translatable', node)
        if value is not None and 'translatable' not in already_processed:
            already_processed.add('translatable')
            self.translatable = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyType14


class signalType15(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, handler=None, swapped=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.handler = _cast(None, handler)
        self.swapped = _cast(None, swapped)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signalType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signalType15.subclass:
            return signalType15.subclass(*args_, **kwargs_)
        else:
            return signalType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_handler(self): return self.handler
    def set_handler(self, handler): self.handler = handler
    def get_swapped(self): return self.swapped
    def set_swapped(self, swapped): self.swapped = swapped
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='signalType15', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='signalType15')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='signalType15', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='signalType15'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.handler is not None and 'handler' not in already_processed:
            already_processed.add('handler')
            outfile.write(' handler=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.handler), input_name='handler')), ))
        if self.swapped is not None and 'swapped' not in already_processed:
            already_processed.add('swapped')
            outfile.write(' swapped=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.swapped), input_name='swapped')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='signalType15', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('handler', node)
        if value is not None and 'handler' not in already_processed:
            already_processed.add('handler')
            self.handler = value
        value = find_attr_value_('swapped', node)
        if value is not None and 'swapped' not in already_processed:
            already_processed.add('swapped')
            self.swapped = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class signalType15


class acceleratorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, key=None, signal=None, modifiers=None, valueOf_=None):
        self.original_tagname_ = None
        self.key = _cast(None, key)
        self.signal = _cast(None, signal)
        self.modifiers = _cast(None, modifiers)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, acceleratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if acceleratorType.subclass:
            return acceleratorType.subclass(*args_, **kwargs_)
        else:
            return acceleratorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_signal(self): return self.signal
    def set_signal(self, signal): self.signal = signal
    def get_modifiers(self): return self.modifiers
    def set_modifiers(self, modifiers): self.modifiers = modifiers
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='acceleratorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='acceleratorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='acceleratorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='acceleratorType'):
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.key), input_name='key')), ))
        if self.signal is not None and 'signal' not in already_processed:
            already_processed.add('signal')
            outfile.write(' signal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.signal), input_name='signal')), ))
        if self.modifiers is not None and 'modifiers' not in already_processed:
            already_processed.add('modifiers')
            outfile.write(' modifiers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modifiers), input_name='modifiers')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='acceleratorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
        value = find_attr_value_('signal', node)
        if value is not None and 'signal' not in already_processed:
            already_processed.add('signal')
            self.signal = value
        value = find_attr_value_('modifiers', node)
        if value is not None and 'modifiers' not in already_processed:
            already_processed.add('modifiers')
            self.modifiers = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class acceleratorType


class childType16(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, placeholder=None):
        self.original_tagname_ = None
        self.placeholder = placeholder
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, childType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if childType16.subclass:
            return childType16.subclass(*args_, **kwargs_)
        else:
            return childType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_placeholder(self): return self.placeholder
    def set_placeholder(self, placeholder): self.placeholder = placeholder
    def hasContent_(self):
        if (
            self.placeholder is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='childType16', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='childType16')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='childType16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='childType16'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='childType16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.placeholder is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splaceholder>%s</%splaceholder>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.placeholder), input_name='placeholder')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'placeholder':
            placeholder_ = child_.text
            placeholder_ = self.gds_validate_string(placeholder_, node, 'placeholder')
            self.placeholder = placeholder_
# end class childType16


class packingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None):
        self.original_tagname_ = None
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, packingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if packingType.subclass:
            return packingType.subclass(*args_, **kwargs_)
        else:
            return packingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def hasContent_(self):
        if (
            self.property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='packingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='packingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='packingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='packingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='packingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = propertyType17.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
# end class packingType


class propertyType17(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType17.subclass:
            return propertyType17.subclass(*args_, **kwargs_)
        else:
            return propertyType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='propertyType17', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyType17')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='propertyType17', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propertyType17'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='propertyType17', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyType17


class signalType18(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, handler=None, swapped=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.handler = _cast(None, handler)
        self.swapped = _cast(None, swapped)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signalType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signalType18.subclass:
            return signalType18.subclass(*args_, **kwargs_)
        else:
            return signalType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_handler(self): return self.handler
    def set_handler(self, handler): self.handler = handler
    def get_swapped(self): return self.swapped
    def set_swapped(self, swapped): self.swapped = swapped
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='signalType18', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='signalType18')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='signalType18', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='signalType18'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.handler is not None and 'handler' not in already_processed:
            already_processed.add('handler')
            outfile.write(' handler=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.handler), input_name='handler')), ))
        if self.swapped is not None and 'swapped' not in already_processed:
            already_processed.add('swapped')
            outfile.write(' swapped=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.swapped), input_name='swapped')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='signalType18', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('handler', node)
        if value is not None and 'handler' not in already_processed:
            already_processed.add('handler')
            self.handler = value
        value = find_attr_value_('swapped', node)
        if value is not None and 'swapped' not in already_processed:
            already_processed.add('swapped')
            self.swapped = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class signalType18


class packingType19(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None):
        self.original_tagname_ = None
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, packingType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if packingType19.subclass:
            return packingType19.subclass(*args_, **kwargs_)
        else:
            return packingType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def hasContent_(self):
        if (
            self.property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='packingType19', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='packingType19')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='packingType19', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='packingType19'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='packingType19', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = propertyType20.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
# end class packingType19


class propertyType20(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType20.subclass:
            return propertyType20.subclass(*args_, **kwargs_)
        else:
            return propertyType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='propertyType20', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyType20')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='propertyType20', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propertyType20'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='propertyType20', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyType20


class packingType21(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None):
        self.original_tagname_ = None
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, packingType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if packingType21.subclass:
            return packingType21.subclass(*args_, **kwargs_)
        else:
            return packingType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def hasContent_(self):
        if (
            self.property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='packingType21', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='packingType21')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='packingType21', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='packingType21'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='packingType21', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = propertyType22.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
# end class packingType21


class propertyType22(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType22.subclass:
            return propertyType22.subclass(*args_, **kwargs_)
        else:
            return propertyType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='propertyType22', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyType22')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='propertyType22', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propertyType22'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='propertyType22', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyType22


class action_widgetsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, action_widget=None):
        self.original_tagname_ = None
        self.action_widget = action_widget
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, action_widgetsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if action_widgetsType.subclass:
            return action_widgetsType.subclass(*args_, **kwargs_)
        else:
            return action_widgetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action_widget(self): return self.action_widget
    def set_action_widget(self, action_widget): self.action_widget = action_widget
    def hasContent_(self):
        if (
            self.action_widget is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='action-widgetsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, rv_isbool(namespacedef_) and ' ' + rv_isbool(namespacedef_) or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='action-widgetsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='action-widgetsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='action-widgetsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='action-widgetsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.action_widget is not None:
            self.action_widget.export(outfile, level, namespace_, name_='action-widget', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'action-widget':
            obj_ = action_widgetType.factory()
            obj_.build(child_)
            self.action_widget = obj_
            obj_.original_tagname_ = 'action-widget'
# end class action_widgetsType


class action_widgetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, response=None, valueOf_=None):
        self.original_tagname_ = None
        self.response = _cast(int, response)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, action_widgetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if action_widgetType.subclass:
            return action_widgetType.subclass(*args_, **kwargs_)
        else:
            return action_widgetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_response(self): return self.response
    def set_response(self, response): self.response = response
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='action-widgetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='action-widgetType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='', name_='action-widgetType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='action-widgetType'):
        if self.response is not None and 'response' not in already_processed:
            already_processed.add('response')
            outfile.write(' response="%s"' % self.gds_format_integer(self.response, input_name='response'))
    def exportChildren(self, outfile, level, namespace_='', name_='action-widgetType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('response', node)
        if value is not None and 'response' not in already_processed:
            already_processed.add('response')
            try:
                self.response = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class action_widgetType


GDSClassesMapping = {
    'accel-groups': accel_groupsType,
    'accelerator': acceleratorType,
    'action-widget': action_widgetType,
    'action-widgets': action_widgetsType,
    'child': childType16,
    'group': groupType,
    'object': objectType13,
    'packing': packingType,
    'property': propertyType22,
    'requires': requiresType,
    'signal': signalType15,
}


USAGE_TEXT = """
Usage:
    python forgui.py <The fully qualified name of the base file.glade> -c <The fully qualified name of the base file.dictionary>

    python forgui.py <The fully qualified name of the base file.glade> -d  <The fully qualified name of the language file.dictionary>
    
Example:
    Step1: Create a base file dictionary interface based on generateds_gui.glade
        >>>python forgui.py d:\Python33\Scripts\generateds_gui.glade -c d:\Python33\Scripts\en.dictionary
        
    Step2: Open the resulting file en. dictionary and translate into Russian language. Keep under the name rus. dictionary.
    
               <English key> [<-|->] <Language value>
               
           ... User methods module:<-|->Пользовательский модуль методов:
           ... Validator bodies path:<-|->Путь корпусов контрольного устройства:
           ... _Capture CL<-|->_Capture CL
           ... _File<-|->_Файл
           ... _Generate<-|->_Произвести
           ... _Help<-|->_Помощь
           ... _Tools<-|->_Инструменты
           ............................
    
    Step3: Create a new file based on glade generateds_gui. glade using dictionary Eng. dictionary. At the output of the get file .glade generateds_gui_rus.
        >>>python forgui.py d:\Python33\Scripts\generateds_gui.glade -d  d:\Python33\Scripts\rus.dictionary 
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'interface'
        rootClass = interface
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'interface'
        rootClass = interface
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'interface'
        rootClass = interface
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'interface'
        rootClass = interface
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from forGUI import *\n\n')
        sys.stdout.write('import forGUI as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) > 0:
        # python forgui.py d:\Python33\Scripts\generateds_gui.glade -d  d:\Python33\Scripts\rus.dictionary 
        if args[1] == '-d':
            global LIST_HELPNAMES
            LIST_HELPNAMES = read_dictfiles(args)
            root = parse(args[0], silence=True)
            path_glade, filename_glade = os.path.split(args[0]) 
            basename_glade, extension_glade = os.path.splitext(filename_glade)
            path_dictionary , filename_dictionary  = os.path.split(args[2])
            export_file_name = os.path.join(path_glade, basename_glade+'_'+os.path.splitext(filename_dictionary)[0]+extension_glade)
            export_file = open(export_file_name, 'w', encoding='utf-8')
            #export_file = sys.stdout
            export_file.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            root.export(export_file, 0)
            export_file.close()
        # python forgui.py d:\Python33\Scripts\generateds_gui.glade -c d:\Python33\Scripts\en.dictionary
        elif args[1] == '-c':
            parse(args[0], silence=False)
            create_dictfiles(args)
    else:
        usage()
        


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "accel_groupsType",
    "acceleratorType",
    "action_widgetType",
    "action_widgetsType",
    "childType",
    "childType12",
    "childType16",
    "childType3",
    "childType6",
    "childType9",
    "groupType",
    "interface",
    "objectType",
    "objectType1",
    "objectType10",
    "objectType13",
    "objectType4",
    "objectType7",
    "packingType",
    "packingType19",
    "packingType21",
    "propertyType",
    "propertyType11",
    "propertyType14",
    "propertyType17",
    "propertyType2",
    "propertyType20",
    "propertyType22",
    "propertyType5",
    "propertyType8",
    "requiresType",
    "signalType",
    "signalType15",
    "signalType18"
]
