<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright (c) 2012-2019 Continuum Security.  All rights reserved.The content of this library is the property of Continuum Security SL and may only be used in whole or in part with a valid license for IriusRisk.-->
<project ref='OWASP MASVS v1.0' name='OWASP MASVS v1.0' revision='8' type='LIBRARY' status='OPEN' enabled='true'
         priority='0' tags=''>
  <desc>This library provides a baseline set of risks for anyone implementing a mobile component and want to follow
        the MASVS standard of OWASP. It covers foundation operating systems such as Android and iOS.
    </desc>
  <categoryComponents>
    <categoryComponent ref='client-side' name='Client-side' />
  </categoryComponents>
  <componentDefinitions>
    <componentDefinition ref='mobile-device-client' name='Mobile Device Client' desc='Any type of client that runs on a mobile device' categoryRef='client-side'>
      <riskPatterns>
        <riskPattern ref='MOBILE-CLIENT' />
      </riskPatterns>
    </componentDefinition>
  </componentDefinitions>
  <supportedStandards>
    <supportedStandard ref='OWASP-MASVS-L1+R' name='OWASP-MASVS-L1+R' />
    <supportedStandard ref='OWASP-MASVS-L2+R' name='OWASP-MASVS-L2+R' />
    <supportedStandard ref='OWASP-MASVS-L1' name='OWASP-MASVS-L1' />
    <supportedStandard ref='OWASP-MASVS-L2' name='OWASP-MASVS-L2' />
  </supportedStandards>
  <udts />
  <components>
    <component ref='ANDROID-CLIENT' name='Android Client' desc='A device running Android. This risk pattern is imported when we have a mobile device, and the client application runs in an android operating system.' groupName='' tags='' position='1' library='' diagramPositionX='0' diagramPositionY='0' componentDefinitionRef=''>
      <weaknesses>
        <weakness ref='CWE-732' name='Incorrect Permission Assignment for Critical Resource' state='0' impact='100'>
          <desc>The software specifies permissions for a security-critical resource in a way which allows that
                        resource to be read or modified by unintended actors.

                        When a resource is given a permissions setting that provides access to a wider range of actions
                        than required, it could lead to the exposure of sensitive information, or the modification of
                        that resource by unintended parties. This is especially dangerous when the resource is related
                        to program configuration, execution or sensitive user data.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:57.789'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-732: Incorrect Permission Assignment for Critical Resource' url='https://cwe.mitre.org/data/definitions/732.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-215' name='Information Exposure Through Debug Information' state='0' impact='100'>
          <desc>The application contains debugging code that can expose
                        sensitive information to untrusted parties.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-06-01T07:21:08.985'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-20' name='Input to exported activities, intents or content providers is not validated' state='0' impact='100'>
          <desc>The product does not validate or incorrectly validates input that can affect the control flow
                        or data flow of a program.

                        When software does not validate input properly, an attacker is able to craft the input in a form
                        that is not expected by the rest of the application. This will lead to parts of the system
                        receiving unintended input, which may result in altered control flow, arbitrary control of a
                        resource, or arbitrary code execution.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:57.803'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-20: Input to exported activities, intents or content providers is not validated' url='https://cwe.mitre.org/data/definitions/20.html' />
            </references>
              <udts/>
          </test>
        </weakness>
          <weakness ref='CWE-489' name='Leftover Debug Code' state='0' impact='100'>
              <desc>The application can be deployed with active debugging code that can create unintended entry
                  points.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2019-04-25T15:26:35.518'>
                      <output/>
                  </source>
                  <references>
                      <reference name='CWE-489: Leftover Debug Code'
                                 url='https://cwe.mitre.org/data/definitions/489.html'/>
                  </references>
                  <udts/>
              </test>
          </weakness>
          <weakness ref='CWE-656' name='Reliance on Security Through Obscurity' state='0' impact='100'>
              <desc>The software uses a protection mechanism whose strength depends heavily on its obscurity, such
                  that knowledge of its algorithms or key data is sufficient to defeat the mechanism.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2019-04-25T15:26:44.061'>
                      <output/>
                  </source>
                  <references>
                      <reference name='CWE-656: Reliance on Security Through Obscurity'
                                 url='https://cwe.mitre.org/data/definitions/656.html'/>
                  </references>
                  <udts />
              </test>
          </weakness>
      </weaknesses>
      <controls>
        <control ref='CAPEC-1-ANDROID-CONT' name='Access to a Content Provider should be restricted' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Malicious applications on the mobile device may be able to access a Content Provider, and
                        sensitive data it has access to, if it is not properly restricted to only the expected
                        applications.
                        Explicitly restrict access to Content Providers to expected applications.
                        Note that prior to Android 4.2, the Content Provider was automatically exported unless
                        explicitly declared as NOT exported.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Testing For Sensitive Functionality Exposure Through IPC' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-for-sensitive-functionality-exposure-through-ipc' />
            <reference name='OWASP MASVS - Testing Whether Sensitive Data Is Exposed via IPC Mechanisms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#determining-whether-sensitive-stored-data-has-been-exposed-via-ipc-mechanisms' />
          </references>
          <standards>
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.4' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.4' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check AndrodManifest.xml for Content Providers:
                            - Every &lt;provider&gt; tag exposed in the file should have the following minimum set of
                            permissions to work with the attributes:
                            - &lt;a
                            href="https://developer.android.com/guide/topics/manifest/provider-element.html#gprmsn"&gt;android:grantUriPermssions&lt;/a&gt;:
                            Temporary permission flag.
                            - &lt;a
                            href="https://developer.android.com/guide/topics/manifest/provider-element.html#prmsn"&gt;android:permission&lt;/a&gt;:
                            Single provider-wide read/write permission.
                            - &lt;a
                            href="https://developer.android.com/guide/topics/manifest/provider-element.html#rprmsn"&gt;android:readPermission&lt;/a&gt;:
                            Provider-wide read permission.
                            - &lt;a
                            href="https://developer.android.com/guide/topics/manifest/provider-element.html#wprmsn"&gt;android:writePermission&lt;/a&gt;:
                            Provider-wide write permission.


                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='CAPEC-1-ANDROID' name='Access to an exported Activity should be restricted' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Any application on the mobile device will be able to launch an exported Activity if it is not
                        explicitly restricted. This may allow a malicious application to gain access to sensitive
                        information, modify the internal state of the application, or trick a user into interacting with
                        the victim application whilst they are still interacting with the malicious application
                        (comparable to framing or clickjacking attacks).
                        Access to an exported Activity must be restricted.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Testing For Sensitive Functionality Exposure Through IPC' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-for-sensitive-functionality-exposure-through-ipc' />
            <reference name='OWASP MASVS - Testing Whether Sensitive Data Is Exposed via IPC Mechanisms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#determining-whether-sensitive-stored-data-has-been-exposed-via-ipc-mechanisms' />
          </references>
          <standards>
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.4' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.4' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check AndrodManifest.xml for exported activities. - Exported activities will NOT have the
                            attribute &lt;i&gt;android:exported = "false".&lt;/i&gt;
                            - If there is no justification for an Activity to be exported, add the&lt;i&gt;android:exported
                            = "false"&lt;/i&gt;attribute.
                            - If the export is needed, then code can access control within the Activity, (see control's
                            code samples).
                            Note that any Android developer can arbitrarily choose a package name, and masquerade as
                            that package. However, only one application with each package name can exist on Google Play,
                            and two applications cannot coexist with the same package name on a device, partly
                            mitigating the threat.

                            Optionally, check the developer's signature for the package.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='CAPEC-1-ANDROID-SRV' name='Access to an exported Service should be restricted' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Malicious applications on the mobile device may be able to start and bind to an exported
                        Service if access is not properly restricted. Depending on the exposed functionality, this may
                        allow a malicious application to perform unauthorized actions, gain access to sensitive
                        information, or corrupt the internal state of the application.
                        Restrict access to start and bind to an exported Service to authorized applications only
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Testing For Sensitive Functionality Exposure Through IPC' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-for-sensitive-functionality-exposure-through-ipc' />
            <reference name='OWASP MASVS - Testing Whether Sensitive Data Is Exposed via IPC Mechanisms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#determining-whether-sensitive-stored-data-has-been-exposed-via-ipc-mechanisms' />
          </references>
          <standards>
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.4' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.4' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check AndrodManifest.xml for exported services:
                            - Check all the existing server tags.
                            - Look for the attribute &lt;i&gt;android:permission=""&lt;/i&gt; and check it has the
                            appropriate permissions
                            - Those permissions should be as restrictive as possible.
                            - e.g. Single provider-wide read/write permission.
                            - If this attribute is not present for the server tag, inspect the &lt;application&gt;
                            element's permission attribute that will be applied to the service.
                            - If neither attribute is set, the service is not protected by a permission.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
          <control ref='MASVS-7.8' name='Activate the Free Security Features' platform='' cost='1' risk='0'
                   state='Recommended' owner='' library='' source='MANUAL'>
              <desc>For Android:&amp;nbsp;
                  &lt;div&gt;
                  &lt;ul&gt;
                  &lt;li&gt;We shall activate the Obfuscation of the code and strip unneeded debugging information.&amp;nbsp;&lt;/li&gt;
                  &lt;/ul&gt;For iOS:&amp;nbsp;
                  &lt;/div&gt;
                  &lt;div&gt;
                  &lt;ul&gt;
                  &lt;li&gt;We shall activate:&amp;nbsp;&lt;/li&gt;
                  &lt;ul&gt;
                  &lt;li&gt;ARC (Automatic Reference Counting): memory management feature, adds retain and release
                  messages when required.&amp;nbsp;&lt;/li&gt;
                  &lt;li&gt;Stack Canary: helps prevent buffer overflow attacks.&amp;nbsp;&lt;/li&gt;
                  &lt;li&gt;PIE (Position Independent Executable): enables full ASLR for binary.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/ul&gt;
                  &lt;/div&gt;
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Verifying Compiler Settings'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05i-Testing-Code-Quality-and-Build-Settings.html#verifying-compiler-settings'/>
                  <reference name='OWASP MASVS - iOS - Verifying Compiler Settings'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06i-Testing-Code-Quality-and-Build-Settings.html#testing-compiler-settings'/>
              </references>
              <standards>
                  <standard ref='7.8' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='7.8' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='7.8' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='7.8' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
        <control ref='MASVS-7.2' name='Disable the debug flags in the release mode' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
            <desc>The android:debuggable attribute in the Application element in the manifest determines whether or not
                the app can be debugged when running on a user mode build of Android. This attribute shall be set to
                false to disable the debug mode.
            </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing If the App is Debuggable' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05i-Testing-Code-Quality-and-Build-Settings.html#testing-if-the-app-is-debuggable' />
          </references>
          <standards>
            <standard ref='7.2' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='7.2' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='7.2' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='7.2' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check in AndroidManifest.xml whether the android:debuggable attribute is set to false:
                            &lt;?xml version="1.0" encoding="utf-8" standalone="no"?&gt;
                            &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
                            package="com.android.owasp"&gt;

                            ...

                            &lt;application android:allowBackup="true" android:debuggable="true"
                            android:icon="@drawable/ic_launcher" android:label="@string/app_name"
                            android:theme="@style/AppTheme"&gt;
                            &lt;meta-data android:name="com.owasp.main" android:value=".Hook"/&gt;
                            &lt;/application&gt;
                            &lt;/manifest&gt;
                            In a release build, this attribute should always be set to "false" (the default value).
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
          <control ref='MASVS-8.8' name='Encrypt and pack all executable files and libraries belonging to the app'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Ensure that all executable files and libraries belonging to the app are encrypted on the file level
                  and/or important code and data segments inside the executables are encrypted or packed.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Simple Obfuscation'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-obfuscation'/>
                  <reference name='OWASP MASVS - iOS - Testing Simple Obfuscation'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-simple-obfuscation'/>
              </references>
              <standards>
                  <standard ref='8.8' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.8' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check that all executable files and libraries belonging to the app are encrypted or
                      packed.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-8.2'
                   name='Implement functionality to notify when anti-debugging mechanisms are presented within the app'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Implement anti-debugging mechanisms to prohibit debug mode being activated. Anti-debugging features
                  can be preventive or reactive. As the name implies, preventive anti-debugging techniques prevent the
                  debugger from attaching in the first place, while reactive techniques attempt to detect whether a
                  debugger is present and react to it in some way (e.g. terminating the app, or triggering some kind of
                  hidden behavior).&amp;nbsp;
                  &lt;div&gt;
                  &lt;br /&gt;
                  &lt;/div&gt;
                  &lt;div&gt;
                  The &amp;quot;more-is-better&amp;quot; rule applies: To maximize effectiveness, defenders combine
                  multiple methods of prevention and detection which operate on different API layers and are distributed
                  throughout the app.
                  &lt;/div&gt;
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Debugging Defenses'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#ttesting-anti-debugging'/>
                  <reference name='OWASP MASVS - iOS - Testing Debugging Defenses'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-debugging-defenses'/>
              </references>
              <standards>
                  <standard ref='8.2' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.2' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check for the presence of anti-debugging mechanisms and verify if with the following
                      criteria the anti-debugging mechanisms are bypassed:&amp;nbsp;
                      &lt;div&gt;
                      &lt;ul&gt;
                      &lt;li&gt;Attaching JDB and ptrace based debuggers either fails or causes the app to
                      terminate or malfunction&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Multiple detection methods are scattered throughout the app (as opposed to putting
                      everything into a single method or function);&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;The anti-debugging defenses operate on multiple API layers (Java, native library
                      functions, Assembler/system calls);&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;The mechanisms show some level of originality (vs. copy/paste from StackOverflow
                      or other sources);&lt;/li&gt;
                      &lt;/ul&gt;
                      &lt;/div&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-7.4'
                   name='Insert the condition DEVELOPER-MODE to remove the debugging code, log verbose errors or debugging messages in the production version'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Insert the policy in the if statement with DEVELOPER_MODE as condition. The DEVELOPER_MODE has to be
                  disabled for release build in order to disable StrictMode too.&amp;nbsp;
                  &lt;div&gt;
                  &lt;br /&gt;
                  &lt;/div&gt;
                  &lt;div&gt;
                  Remove the debugging code, log verbose errors or debugging messages in the production version.
                  &lt;/div&gt;
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing for Debugging Code and Verbose Error Logging'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05i-Testing-Code-Quality-and-Build-Settings.html#testing-for-debugging-code-and-verbose-error-logging'/>
                  <reference name='OWASP MASVS - iOS - Testing for Debugging Code and Verbose Error Logging'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06i-Testing-Code-Quality-and-Build-Settings.html#testing-for-debugging-code-and-verbose-error-logging'/>
              </references>
              <standards>
                  <standard ref='7.4' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='7.4' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='7.4' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='7.4' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>&lt;ul&gt;
                      &lt;li&gt;Check that there is only one method to activate the DEVELOPMENT_MODE.&lt;/li&gt;
                      &lt;li&gt;Check that the debugging code was removed.&lt;/li&gt;
                      &lt;/ul&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-8.9' name='Obfuscate all executable files, libraries, important code and data segments'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Obfuscation is the process of transforming code and data in order to make it more difficult to
                  comprehend. It is an integral part of every software protection scheme.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Advanced Obfuscation'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-obfuscation'/>
                  <reference name='OWASP MASVS - iOS - Testing Advanced Obfuscation'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-simple-obfuscation'/>
              </references>
              <standards>
                  <standard ref='8.12' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.13' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check that the code is unreadable.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-7.3' name='Remove or obfuscate the debugging symbols from native binaries' platform=''
                   cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>As a general rule of thumb, as little explanative information as possible should be provided along
                  with the compiled code. Some metadata such as debugging information, line numbers and descriptive
                  function or method names make the binary or bytecode easier to understand for the reverse engineer,
                  but isn't actually needed in a release build and can therefore be safely discarded without impacting
                  the functionality of the app. This data shall be removed from the release version or shall be
                  obfuscated in order to be inaccessible to the reverse engineer.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing for Debugging Symbols'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05i-Testing-Code-Quality-and-Build-Settings.html#testing-for-debugging-symbols'/>
                  <reference name='OWASP MASVS - iOS - Testing for Debugging Symbols'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06i-Testing-Code-Quality-and-Build-Settings.html#testing-for-debugging-symbols'/>
              </references>
              <standards>
                  <standard ref='7.3' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='7.3' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='7.3' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='7.3' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>For Android:&amp;nbsp;
                      &lt;blockquote&gt;
                      &lt;div&gt;
                      Symbols are usually stripped during the build process, so you need the compiled byte-code
                      and libraries to verify whether any unnecessary metadata has been discarded. First find the
                      nm binary in your Android NDK and export it (or create an alias).
                      &lt;/div&gt;
                      &lt;div&gt;
                      &lt;br /&gt;
                      &lt;/div&gt;
                      &lt;/blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;div&gt;
                      export $NM =
                      $ANDROID_NDK_DIR/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-nm&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      &lt;br /&gt;
                      &lt;/div&gt;
                      &lt;/blockquote&gt;
                      &lt;/blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;div&gt;
                      To display debug symbols:
                      &lt;/div&gt;
                      &lt;/blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;div&gt;
                      $ $NM -a
                      libfoo.so/tmp/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-nm:
                      libfoo.so: no symbols&amp;nbsp;
                      &lt;/div&gt;
                      &lt;/blockquote&gt;To display dynamic symbols:
                      &lt;/blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;blockquote&gt;
                      $ $NM -D libfoo.so&amp;nbsp;
                      &lt;/blockquote&gt;Alternatively, open the file in your favorite disassembler and check the
                      symbol tables manually. Dynamic symbols can be stripped using the visibility compiler flag.
                      Adding this flag causes gcc to discard the function names while still preserving the names
                      of functions declared as JNIEXPORT.&amp;nbsp;
                      &lt;/blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;br /&gt;
                      &lt;/blockquote&gt;
                      &lt;blockquote&gt;
                      Check if the following was added to build.gradle:&amp;nbsp;
                      &lt;/blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;blockquote&gt;
                      externalNativeBuild { cmake { cppFlags &amp;quot;-fvisibility=hidden&amp;quot; } }&amp;nbsp;
                      &lt;/blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;br /&gt;
                      &lt;/blockquote&gt;
                      &lt;/blockquote&gt;For iOS:&amp;nbsp;
                      &lt;blockquote&gt;
                      &lt;div&gt;
                      Use gobjdump to inspect the main binary and any included dylibs for Stabs and DWARF symbols.
                      &lt;/div&gt;
                      &lt;/blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;div&gt;
                      $ gobjdump --stabs --dwarf TargetApp&amp;nbsp;
                      &lt;/div&gt;
                      &lt;/blockquote&gt;In archive MyTargetApp:&amp;nbsp;
                      &lt;/blockquote&gt;
                      &lt;blockquote&gt;
                      &lt;blockquote&gt;
                      - armv5te: file format mach-o-arm - aarch64: file format mach-o-arm64 Gobjdump is part of
                      binutils and can be installed via Homebrew on Mac OS X.
                      &lt;/blockquote&gt;
                      &lt;/blockquote&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
        <control ref='CWE-20' name='Validate all input data sent to exported activities, intents or content providers' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>All data received from the client-side should be considered tainted and a potential risk,
                        regardless of the source or transport method. This affects all application platforms, including
                        mobile. All data from the client side must be subjected to strict validation, sanitization, and
                        encoding against expected syntactic and semantic criteria.&amp;nbsp;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        Define a specification of the data that is expected at each input; both the syntax (e.g.
                        alphanumeric only) and semantics (e.g. a word of between 1 and 25 characters, or a specific
                        list). As an example of business rule logic, &amp;quot;boat&amp;quot; may be syntactically valid
                        because it only contains alphanumeric characters, but it is not valid if the input is only
                        expected to contain colors such as &amp;quot;red&amp;quot; or &amp;quot;blue.&amp;quot;&amp;nbsp;
                        &lt;/div&gt;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        Implement a 'known good' or white-list approach, where only inputs that meet the strict criteria
                        for each input are accepted, and reject, transform, or encapsulate any non-compliant data. While
                        useful for identifying malicious content, do not rely on looking for specific malformed or
                        attack payloads (blacklists). It is almost impossible to maintain a comprehensive and accurate
                        blacklist due to the complexity and evolving nature of attacks, opportunities to obfuscate
                        payloads, and changes to the code's execution environment. As noted, blacklists can be useful
                        for detecting and logging potential attacks, or determining which inputs are so malformed that
                        they should be rejected outright. Validate all data received from the client, including values
                        such as HTTP headers and cookie values if these are used as input on the server side, X-
                        headers, and other platform specific data objects passed between the client and server.&amp;nbsp;
                        &lt;/div&gt;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        This validation and sanitization must be performed in context, for example, data sent to an SQL
                        database must be escaped for SQL special characters whereas data sent as part of a shell command
                        must be escaped for shell special characters.
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Custom URL Schemes' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-custom-url-schemes' />
            <reference name='OWASP MASVS - Android - Testing Input Validation and Sanitization' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-input-validation-and-sanitization' />
            <reference name='OWASP MASVS - iOS - Testing Custom URL Schemes' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-custom-url-schemes' />
            <reference name='OWASP MASVS - iOS - Testing Input Validation and Sanitization' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-input-validation-and-sanitization' />
          </references>
          <standards>
            <standard ref='6.2' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.3' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.2' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.3' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.2' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='6.2' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>- Identify exported activities, intents and contents providers.
                            - For every input, define accepted input (both syntactic and semantic criteria)
                            - Where possible, define a white-list of accepted input or characters
                            - For each of the inputs, ensure the data is validated against the defined whitelists (for
                            example with a regular expression) before being processed.
                            - Check the code to look for input validation methods and input restrictions.
                            - Test they are effective by fuzzing the identified features.
                            - Tools such as&lt;a href="https://labs.mwrinfosecurity.com/tools/drozer/"&gt;Drozer&lt;/a&gt;can
                            help with this task.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
      </controls>
      <usecases>
        <usecase ref='GENERAL' name='General' desc='' library=''>
          <threats>
            <threat ref='CAPEC-133' name='An attacker attempts to invoke all common switches and options to discover weaknesses ' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker attempts to invoke all common switches and options in the target
                                application for the purpose of discovering weaknesses in the target. For example, in
                                some applications, adding the --debug switch causes debugging information to be
                                displayed, which can sometimes reveal sensitive processing or configuration information
                                to an attacker.&amp;nbsp;
                                &lt;div&gt;
                                &lt;br /&gt;
                                &lt;/div&gt;
                                &lt;div&gt;
                                This attack differs from other forms of API abuse in that the attacker is blindly
                                attempting to invoke options in the hope that one of them will work rather than
                                specifically targeting a known option. Nonetheless, even if the attacker is familiar
                                with the published options of a targeted application this attack method may still be
                                fruitful as it might discover unpublicized functionality.
                                &lt;/div&gt;
                            </desc>
              <riskRating confidentiality='50' integrity='50' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-215'>
                  <controls>
                      <control ref='MASVS-7.2' mitigation='14'/>
                      <control ref='MASVS-7.3' mitigation='14'/>
                      <control ref='MASVS-7.4' mitigation='16'/>
                      <control ref='MASVS-8.2' mitigation='14'/>
                  </controls>
                </weakness>
                  <weakness ref='CWE-489'>
                      <controls>
                          <control ref='MASVS-7.4' mitigation='16'/>
                      </controls>
                  </weakness>
                  <weakness ref='CWE-656'>
                      <controls>
                          <control ref='MASVS-7.8' mitigation='14'/>
                          <control ref='MASVS-8.8' mitigation='14'/>
                          <control ref='MASVS-8.9' mitigation='14'/>
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                  <control ref='MASVS-7.2' mitigation='14'/>
                  <control ref='MASVS-7.3' mitigation='14'/>
                  <control ref='MASVS-7.4' mitigation='16'/>
                  <control ref='MASVS-7.8' mitigation='14'/>
                  <control ref='MASVS-8.2' mitigation='14'/>
                  <control ref='MASVS-8.8' mitigation='14'/>
                  <control ref='MASVS-8.9' mitigation='14'/>
              </controls>
            </threat>
          </threats>
        </usecase>
        <usecase ref='PROVIDE MOBILE ACCESS TO SERVICES' name='Provide mobile access to services' desc='' library=''>
          <threats>
            <threat ref='CAPEC-1-ANDROID' name='Malicious applications gain access to unauthorised data or perform unauthorised actions' state='Expose' source='MANUAL' owner='' library=''>
              <desc>Attackers could use malicious mobile applications to attack legitimate applications
                                that export their components improperly. The attacks and consequences of improperly
                                exporting a component may depend on the exported component: If access to an exported
                                Activity is not restricted, any application will be able to launch the activity.&amp;nbsp;
                                &lt;div&gt;
                                &lt;br /&gt;
                                &lt;/div&gt;
                                &lt;div&gt;
                                This may allow a malicious application to gain access to sensitive information, modify
                                the internal state of the application, or trick a user into interacting with the victim
                                application whilst believing they are still interacting with the malicious application.
                                If access to an exported Service is not restricted, any application may start and bind
                                to the Service.&amp;nbsp;
                                &lt;/div&gt;
                                &lt;div&gt;
                                &lt;br /&gt;
                                &lt;/div&gt;
                                &lt;div&gt;
                                Depending on the exposed functionality, this may allow a malicious application to
                                perform unauthorized actions, gain access to sensitive information, or corrupt the
                                internal state of the application. If access to a Content Provider is not restricted to
                                only the expected applications, then malicious applications might be able to access the
                                sensitive data. Note that in Android before 4.2, the Content Provider is automatically
                                exported unless it has been explicitly declared as NOT exported.
                                &lt;/div&gt;
                            </desc>
              <riskRating confidentiality='75' integrity='75' availability='1' easeOfExploitation='75' />
              <references />
              <weaknesses>
                <weakness ref='CWE-732'>
                  <controls>
                    <control ref='CAPEC-1-ANDROID' mitigation='25' />
                    <control ref='CAPEC-1-ANDROID-CONT' mitigation='25' />
                    <control ref='CAPEC-1-ANDROID-SRV' mitigation='25' />
                  </controls>
                </weakness>
                <weakness ref='CWE-20'>
                  <controls>
                    <control ref='CWE-20' mitigation='25' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='CAPEC-1-ANDROID' mitigation='25' />
                <control ref='CAPEC-1-ANDROID-CONT' mitigation='25' />
                <control ref='CAPEC-1-ANDROID-SRV' mitigation='25' />
                <control ref='CWE-20' mitigation='25' />
              </controls>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </component>
    <component ref='ANDROID-CLIENT: SENS-DATA' name='Android Client: Sensitive data' desc='A device running Android. This risk pattern is imported when we have a mobile device, and the client application runs in an android operating system and the application reads, stores and sends sensitive data.' groupName='' tags='' position='2' library='' diagramPositionX='0' diagramPositionY='0' componentDefinitionRef=''>
      <weaknesses>
        <weakness ref='CWE-502' name='Deserialization of Untrusted Data' state='0' impact='100'>
          <desc>The application deserializes untrusted data without sufficiently verifying that the resulting
                        data will be valid.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.113'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-502: Deserialization of Untrusted Data' url='https://cwe.mitre.org/data/definitions/502.html' />
            </references>
            <udts />
          </test>
        </weakness>
          <weakness ref='CWE-749' name='Exposed Dangerous Method or Function' state='0' impact='100'>
              <desc>The software provides an Applications Programming Interface (API) or similar interface for
                  interaction with external actors, but the interface includes a dangerous method or function that
                  is not properly restricted.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2019-04-25T15:33:00.592'>
                      <output/>
                  </source>
                  <references>
                      <reference name='CWE-749: Exposed Dangerous Method or Function'
                                 url='https://cwe.mitre.org/data/definitions/749.html'/>
                  </references>
                  <udts/>
              </test>
          </weakness>
        <weakness ref='CWE-79' name='Improper Neutralization of Input During Web Page Generation (&apos;Cross-site Scripting&apos;)' state='0' impact='100'>
          <desc>The software does not neutralize or incorrectly neutralizes user-controllable input before it
                        is placed in output that is used as a web page which is served to other users.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.122'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-79: Improper Neutralization of Input During Web Page Generation (&apos;Cross-site Scripting&apos;)' url='https://cwe.mitre.org/data/definitions/79.html' />
            </references>
            <udts />
          </test>
        </weakness>
          <weakness ref='CWE-83' name='Improper Neutralization of Script in Attributes in a Web Page' state='0'
                    impact='100'>
              <desc>The software does not neutralize or incorrectly neutralizes "javascript:" or other URIs from
                  dangerous attributes within tags, such as onmouseover, onload, onerror, or style.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2019-04-25T15:32:55.623'>
                      <output/>
                  </source>
                  <references>
                      <reference name='CWE-83: Improper Neutralization of Script in Attributes in a Web Page'
                                 url='https://cwe.mitre.org/data/definitions/83.html'/>
                  </references>
                  <udts/>
              </test>
          </weakness>
      </weaknesses>
      <controls>
          <control ref='MASVS-6.6' name='Allow only the minimum set of protocol handlers required' platform='' cost='1'
                   risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Configure the WebViews to allow only the minimum set of protocol handlers required (ideally, only
                  https). Potentially dangerous handlers, such as file, tel and app-id, are disabled.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing WebView Protocol Handlers'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-webview-protocol-handlers'/>
                  <reference name='OWASP MASVS - iOS - Testing WebView Protocol Handlers'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-ios-webviews'/>
              </references>
              <standards>
                  <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check that the set of protocol handlers are deactivated.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-6.5' name='Disable JavaScript by default in a WebView if it is not necessary' platform=''
                   cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>JavaScript is disabled by default in a WebView and if not needed shouldn't be enabled. This reduces
                  the attack surface and potential threats to the app.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing JavaScript Execution in WebViews'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-javascript-execution-in-webviews'/>
                  <reference name='OWASP MASVS - iOS - Testing JavaScript Execution in WebViews'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-ios-webviews'/>
              </references>
              <standards>
                  <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>For Android:&amp;nbsp;
                      &lt;div&gt;
                      &lt;ul&gt;
                      &lt;li&gt;Search in the code the following instruction:
                      webview.getSettings().setJavaScriptEnabled(true);&lt;/li&gt;
                      &lt;li&gt;Check that this instruction doesn't exist in the code.&amp;nbsp;&lt;/li&gt;
                      &lt;/ul&gt;For iOS:&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      &lt;ul&gt;
                      &lt;li&gt;Check that the JavaScript is disabled and configured as following:&amp;nbsp;&lt;/li&gt;
                      &lt;/ul&gt;
                      &lt;/div&gt;
                      &lt;blockquote&gt;
                      &lt;div&gt;
                      #import &amp;quot;ViewController.h&amp;quot;&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      #import @interface ViewController () @property(strong,nonatomic) WKWebView *webView;
                      &lt;/div&gt;
                      &lt;div&gt;
                      @end @implementation ViewController - (void)viewDidLoad { NSURL *url = [NSURL
                      URLWithString:@&amp;quot;http://www.example.com/&amp;quot;];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      NSURLRequest *request = [NSURLRequest requestWithURL:url];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      WKPreferences *pref = [[WKPreferences alloc] init]; //Disable javascript execution: [pref
                      setJavaScriptEnabled:NO];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      [pref setJavaScriptCanOpenWindowsAutomatically:NO];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      WKWebViewConfiguration *conf = [[WKWebViewConfiguration alloc] init];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      [conf setPreferences:pref]; _webView = [[WKWebView
                      alloc]initWithFrame:CGRectMake(self.view.frame.origin.x,85, self.view.frame.size.width,
                      self.view.frame.size.height-85) configuration:conf] ;&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      [_webView loadRequest:request];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      [self.view addSubview:_webView]; }
                      &lt;/div&gt;
                      &lt;/blockquote&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-6.7' name='Do not load user-supplied local resources into WebViews' platform='' cost='1'
                   risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>WebViews can load content remotely and locally from the app data directory. If the content is loaded
                  locally, users should not be able to change the filename or path from which the file is loaded, and
                  they shouldn't be able to edit the loaded file. To avoid this you shall not allow the loading of local
                  resources into the Webviews.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing for Local File Inclusion in WebViews'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-javascript-execution-in-webviews'/>
                  <reference name='OWASP MASVS - iOS - Testing for Local File Inclusion in WebViews'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-ios-webviews'/>
              </references>
              <standards>
                  <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check if you can identify and change the url of local or remote files and if you can
                      access those files.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
        <control ref='MASVS-6.8' name='Only JavaScript provided with the app code is allowed' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
            <desc>Only JavaScript provided with the APK should be allowed to call it but no JavaScript loaded from
                remote endpoints.
            </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Whether Java Objects Are Exposed Through WebViews' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-whether-java-objects-are-exposed-through-webviews' />
          </references>
          <standards>
            <standard ref='6.8' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.8' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.8' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='6.8' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>- Produce a JavaScript payload.
                            - Inject it into the file that the app is requesting. The injection could be done either
                            through a MITM attack or by directly modifying the file in case it is stored on external
                            storage. The whole process could be done through Drozer that uses weasel (MWR's advanced
                            exploitation payload) which is able to install a full agent, injecting a limited agent into
                            a running process, or connecting a reverse shell to act as a Remote Access Tool (RAT).
                            - Check that only the JavaScript provided with the app is allowed.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-6.9' name='Serialize the objects for the sensitive data with the Java Serialization API' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Serialize the objects for the sensitive data with the Java Serialization API. After
                        serialization, the data shall be encrypted and HMACed/signed. The user and/or application
                        instance shall be properly authenticated/authorized to obtain the keys to use the data.

                        The data within the deserialized object is carefully validated before you can actively use it
                        (e.g. no exploit of business/application logic).
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Object (De-)Serialization' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-object-persistence' />
          </references>
          <standards>
            <standard ref='6.9' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.9' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.9' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='6.9' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>- Check that the objects the sensitive data are serialized with the Java Serialization
                            API.
                            - Check that the data is encrypted and HMACed signed.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
      </controls>
      <usecases>
        <usecase ref='PROVIDE MOBILE ACCESS TO SERVICES' name='Provide mobile access to services' desc='' library=''>
          <threats>
            <threat ref='CAPEC-586' name='Attackers can gain access to the application with the serialized objects injection' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An adversary attempts to exploit an application by injecting additional, malicious
                                content during its processing of serialized objects. Developers leverage serialization
                                in order to convert data or state into a static, binary format for saving to disk or
                                transferring over a network. These objects are then deserialized when needed to recover
                                the data/state. By injecting a malformed object into a vulnerable application, an
                                adversary can potentially compromise the application by manipulating the deserialization
                                process. This can result in a number of unwanted outcomes, including remote code
                                execution.
                            </desc>
              <riskRating confidentiality='75' integrity='75' availability='75' easeOfExploitation='50' />
              <references />
              <weaknesses>
                <weakness ref='CWE-502'>
                  <controls>
                    <control ref='MASVS-6.9' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-6.9' mitigation='100' />
              </controls>
            </threat>
            <threat ref='ACCESS-WEBVIEW' name='Attackers gain access to the data through the WebView functionality' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker employs forceful browsing to access portions of a website that are
                                otherwise unreachable through direct URL entry.

                                Usually, a front controller or similar design pattern is employed to protect access to
                                portions of a web application.

                                Forceful browsing enables an attacker to access information, perform privileged
                                operations and otherwise reach sections of the web application that have been improperly
                                protected.
                            </desc>
              <riskRating confidentiality='75' integrity='50' availability='50' easeOfExploitation='75' />
              <references />
              <weaknesses>
                  <weakness ref='CWE-749'>
                      <controls>
                          <control ref='MASVS-6.6' mitigation='25'/>
                      </controls>
                  </weakness>
                <weakness ref='CWE-79'>
                  <controls>
                      <control ref='MASVS-6.7' mitigation='25'/>
                      <control ref='MASVS-6.8' mitigation='25'/>
                  </controls>
                </weakness>
                  <weakness ref='CWE-83'>
                      <controls>
                          <control ref='MASVS-6.5' mitigation='25'/>
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                  <control ref='MASVS-6.5' mitigation='25'/>
                  <control ref='MASVS-6.6' mitigation='25'/>
                  <control ref='MASVS-6.7' mitigation='25'/>
                  <control ref='MASVS-6.8' mitigation='25'/>
              </controls>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </component>
    <component ref='IOS-CLIENT' name='iOS Client' desc='This pattern is imported when we have a mobile device, and the client application runs in an iOS operating system.' groupName='' tags='' position='3' library='' diagramPositionX='0' diagramPositionY='0' componentDefinitionRef=''>
      <weaknesses>
        <weakness ref='CWE-83' name='Improper Neutralization of Script in Attributes in a Web Page' state='0' impact='100'>
          <desc>The software does not neutralize or incorrectly neutralizes "javascript:" or other URIs from
                        dangerous attributes within tags, such as onmouseover, onload, onerror, or style.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
              <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                      timestamp='2019-04-25T15:32:55.623'>
                  <output/>
            </source>
            <references>
              <reference name='CWE-83: Improper Neutralization of Script in Attributes in a Web Page' url='https://cwe.mitre.org/data/definitions/83.html' />
            </references>
            <udts />
          </test>
        </weakness>
          <weakness ref='CWE-749' name='Exposed Dangerous Method or Function' state='0' impact='100'>
              <desc>The software provides an Applications Programming Interface (API) or similar interface for
                  interaction with external actors, but the interface includes a dangerous method or function that
                  is not properly restricted.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2019-04-25T15:22:33.889'>
                      <output/>
                  </source>
                  <references>
                      <reference name='CWE-749: Exposed Dangerous Method or Function'
                                 url='https://cwe.mitre.org/data/definitions/749.html'/>
                  </references>
                  <udts/>
              </test>
          </weakness>
          <weakness ref='CWE-79'
                    name='Improper Neutralization of Input During Web Page Generation (&apos;Cross-site Scripting&apos;)'
                    state='0' impact='100'>
              <desc>The software does not neutralize or incorrectly neutralizes user-controllable input before it
                  is placed in output that is used as a web page which is served to other users.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2019-04-25T15:22:25.358'>
                      <output/>
                  </source>
                  <references>
                      <reference
                              name='CWE-79: Improper Neutralization of Input During Web Page Generation (&apos;Cross-site Scripting&apos;)'
                              url='https://cwe.mitre.org/data/definitions/79.html'/>
                  </references>
                  <udts/>
              </test>
          </weakness>
      </weaknesses>
      <controls>
          <control ref='MASVS-6.6' name='Allow only the minimum set of protocol handlers required' platform='' cost='1'
                   risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Configure the WebViews to allow only the minimum set of protocol handlers required (ideally, only
                  https). Potentially dangerous handlers, such as file, tel and app-id, are disabled.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing WebView Protocol Handlers'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-webview-protocol-handlers'/>
                  <reference name='OWASP MASVS - iOS - Testing WebView Protocol Handlers'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-ios-webviews'/>
              </references>
              <standards>
                  <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check that the set of protocol handlers are deactivated.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-6.5' name='Disable JavaScript by default in a WebView if it is not necessary' platform=''
                   cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>JavaScript is disabled by default in a WebView and if not needed shouldn't be enabled. This reduces
                  the attack surface and potential threats to the app.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing JavaScript Execution in WebViews'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-javascript-execution-in-webviews'/>
                  <reference name='OWASP MASVS - iOS - Testing JavaScript Execution in WebViews'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-ios-webviews'/>
              </references>
              <standards>
                  <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>For Android:&amp;nbsp;
                      &lt;div&gt;
                      &lt;ul&gt;
                      &lt;li&gt;Search in the code the following instruction:
                      webview.getSettings().setJavaScriptEnabled(true);&lt;/li&gt;
                      &lt;li&gt;Check that this instruction doesn't exist in the code.&amp;nbsp;&lt;/li&gt;
                      &lt;/ul&gt;For iOS:&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      &lt;ul&gt;
                      &lt;li&gt;Check that the JavaScript is disabled and configured as following:&amp;nbsp;&lt;/li&gt;
                      &lt;/ul&gt;
                      &lt;/div&gt;
                      &lt;blockquote&gt;
                      &lt;div&gt;
                      #import &amp;quot;ViewController.h&amp;quot;&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      #import @interface ViewController () @property(strong,nonatomic) WKWebView *webView;
                      &lt;/div&gt;
                      &lt;div&gt;
                      @end @implementation ViewController - (void)viewDidLoad { NSURL *url = [NSURL
                      URLWithString:@&amp;quot;http://www.example.com/&amp;quot;];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      NSURLRequest *request = [NSURLRequest requestWithURL:url];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      WKPreferences *pref = [[WKPreferences alloc] init]; //Disable javascript execution: [pref
                      setJavaScriptEnabled:NO];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      [pref setJavaScriptCanOpenWindowsAutomatically:NO];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      WKWebViewConfiguration *conf = [[WKWebViewConfiguration alloc] init];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      [conf setPreferences:pref]; _webView = [[WKWebView
                      alloc]initWithFrame:CGRectMake(self.view.frame.origin.x,85, self.view.frame.size.width,
                      self.view.frame.size.height-85) configuration:conf] ;&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      [_webView loadRequest:request];&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      [self.view addSubview:_webView]; }
                      &lt;/div&gt;
                      &lt;/blockquote&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
        <control ref='MASVS-6.6-IOS-UIWEBVIEW' name='Disable the UIWebView for iOS platform' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
            <desc>UIWebView is deprecated and should not be used. Make sure that either WKWebView or
                SafariViewController are used to embed web content:&amp;nbsp;
                &lt;div&gt;
                &lt;ul&gt;
                &lt;li&gt;WKWebView is the appropriate choice for extending app functionality, controlling displayed
                content (i.e., prevent the user from navigating to arbitrary URLs) and customizing. SafariViewController
                should be used to provide a generalized web viewing experience. Note that SafariViewController shares
                cookies and other website data with Safari.&amp;nbsp;&lt;/li&gt;
                &lt;li&gt;WKWebView comes with several security advantages over UIWebView:&amp;nbsp;&lt;/li&gt;
                &lt;ul&gt;
                &lt;li&gt;The JavaScriptEnabled property can be used to completely disable JavaScript in the WKWebView.
                This prevents all script injection flaws.&amp;nbsp;&lt;/li&gt;
                &lt;li&gt;The JavaScriptCanOpenWindowsAutomatically can be used to prevent JavaScript from opening new
                windows, such as pop-ups.&amp;nbsp;&lt;/li&gt;
                &lt;li&gt;The hasOnlySecureContent property can be used to verify resources loaded by the WebView are
                retrieved through encrypted connections.&amp;nbsp;&lt;/li&gt;
                &lt;li&gt;WKWebView implements out-of-process rendering, so memory corruption bugs won't affect the main
                app process.&lt;/li&gt;
                &lt;/ul&gt;
                &lt;/ul&gt;
                &lt;/div&gt;
            </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - iOS - Testing WebView Protocol Handlers' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-ios-webviews' />
          </references>
          <standards>
            <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that UIWebView is not used to embed web content.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
          <control ref='MASVS-6.7' name='Do not load user-supplied local resources into WebViews' platform='' cost='1'
                   risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>WebViews can load content remotely and locally from the app data directory. If the content is loaded
                  locally, users should not be able to change the filename or path from which the file is loaded, and
                  they shouldn't be able to edit the loaded file. To avoid this you shall not allow the loading of local
                  resources into the Webviews.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing for Local File Inclusion in WebViews'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-javascript-execution-in-webviews'/>
                  <reference name='OWASP MASVS - iOS - Testing for Local File Inclusion in WebViews'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-ios-webviews'/>
              </references>
              <standards>
                  <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check if you can identify and change the url of local or remote files and if you can
                      access those files.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
      </controls>
      <usecases>
        <usecase ref='PROVIDE MOBILE ACCESS TO SERVICES' name='Provide mobile access to services' desc='' library=''>
          <threats>
            <threat ref='ACCESS-WEBVIEW' name='Attackers gain access to the data through the WebView functionality' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker employs forceful browsing to access portions of a website that are
                                otherwise unreachable through direct URL entry.

                                Usually, a front controller or similar design pattern is employed to protect access to
                                portions of a web application.

                                Forceful browsing enables an attacker to access information, perform privileged
                                operations and otherwise reach sections of the web application that have been improperly
                                protected.
                            </desc>
              <riskRating confidentiality='75' integrity='50' availability='50' easeOfExploitation='75' />
              <references />
              <weaknesses>
                  <weakness ref='CWE-749'>
                      <controls>
                          <control ref='MASVS-6.6' mitigation='25'/>
                      </controls>
                  </weakness>
                  <weakness ref='CWE-79'>
                      <controls>
                          <control ref='MASVS-6.7' mitigation='25'/>
                      </controls>
                  </weakness>
                <weakness ref='CWE-83'>
                  <controls>
                      <control ref='MASVS-6.5' mitigation='25'/>
                      <control ref='MASVS-6.6-IOS-UIWEBVIEW' mitigation='25'/>
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                  <control ref='MASVS-6.5' mitigation='25'/>
                  <control ref='MASVS-6.6' mitigation='25'/>
                  <control ref='MASVS-6.6-IOS-UIWEBVIEW' mitigation='25'/>
                  <control ref='MASVS-6.7' mitigation='25'/>
              </controls>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </component>
    <component ref='MOBILE-CLIENT' name='Mobile Client' desc='A client component on a mobile device. This risk pattern is imported when we have a mobile device, and we don&apos;t know which operating system runs. This is a common risk pattern for all types of operating systems.' groupName='' tags='' position='4' library='' diagramPositionX='0' diagramPositionY='0' componentDefinitionRef=''>
      <weaknesses>
        <weakness ref='CWE-388' name='An error condition is not properly handled (Error Handling)' state='0' impact='100'>
          <desc>Errors and error handling represent a class of API. Errors related to error handling are so
                        common that they deserve a special kingdom of their own. As with “API Abuse,” there
                        are two ways
                        to introduce an error-related security vulnerability: the most common one is handling errors
                        poorly (or not at all). The second is producing errors that either give out too much information
                        (to possible attackers) or are difficult to handle
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.460'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-388: An error condition is not properly handled (Error Handling)' url='https://cwe.mitre.org/data/definitions/388.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-120' name='Buffer Copy without Checking Size of Input (&apos;Classic Buffer Overflow&apos;)' state='0' impact='100'>
          <desc>The program copies an input buffer to an output buffer without verifying the size of the input
                        buffer is less than the size of the output buffer, leading to a buffer overflow.
                        A buffer overflow condition exists when a program attempts to put more data in a buffer than it
                        can hold, or when a program attempts to put data in a memory area outside of the boundaries of a
                        buffer. The simplest type of error, and the most common cause of buffer overflows, is the
                        "classic" case in which the program copies the buffer without restricting how much is copied.
                        Other variants exist, but the existence of a classic overflow strongly suggests the programmer
                        is not considering even the most basic of security protections.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.447'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-120: Buffer Copy without Checking Size of Input (&apos;Classic Buffer Overflow&apos;)' url='https://cwe.mitre.org/data/definitions/120.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-494' name='Download of Code Without Integrity Check' state='0' impact='100'>
          <desc>The product downloads source code or an executable from a remote location and executes the
                        code without sufficiently verifying the origin and integrity of the code.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.381'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-494: Download of Code Without Integrity Check' url='https://cwe.mitre.org/data/definitions/494.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-250' name='Execution with Unnecessary Privileges' state='0' impact='100'>
          <desc>The software performs an operation at a privilege level that is higher than the minimum level
                        required, which creates new weaknesses or amplifies the consequences of other weaknesses.

                        New weaknesses can be exposed because running with extra privileges, such as root or
                        Administrator, can disable the normal security checks being performed by the operating system or
                        surrounding environment. Other pre-existing weaknesses can turn into security vulnerabilities if
                        they occur whilst operating at raised privileges. Privilege management functions can behave in
                        some less-than-obvious ways, and they have different quirks on different platforms. These
                        inconsistencies are particularly pronounced if you are transitioning from one non-root user to
                        another. Signal handlers and spawned processes run at the privilege of the owning process, so if
                        a process is running as root when a signal fires or a sub-process is executed, the signal
                        handler or sub-process will operate with root privileges.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.431'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-250: Execution with Unnecessary Privileges' url='https://cwe.mitre.org/data/definitions/250.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-749' name='Exposed Dangerous Method or Function' state='0' impact='100'>
          <desc>The software provides an Applications Programming Interface (API) or similar interface for
                        interaction with external actors, but the interface includes a dangerous method or function that
                        is not properly restricted.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.413'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-749: Exposed Dangerous Method or Function' url='https://cwe.mitre.org/data/definitions/749.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-79' name='Improper Neutralization of Input During Web Page Generation (&apos;Cross-site Scripting&apos;)' state='0' impact='100'>
          <desc>The software does not neutralize or incorrectly neutralizes user-controllable input before it
                        is placed in output that is used as a web page which is served to other users.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.422'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-79: Improper Neutralization of Input During Web Page Generation (&apos;Cross-site Scripting&apos;)' url='https://cwe.mitre.org/data/definitions/79.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-83' name='Improper Neutralization of Script in Attributes in a Web Page' state='0' impact='100'>
          <desc>The software does not neutralize or incorrectly neutralizes "javascript:" or other URIs from
                        dangerous attributes within tags, such as onmouseover, onload, onerror, or style.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.404'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-83: Improper Neutralization of Script in Attributes in a Web Page' url='https://cwe.mitre.org/data/definitions/83.html' />
            </references>
            <udts />
          </test>
        </weakness>
          <weakness ref='MASVS-EMULATION-TOOLS' name='Inappropriate use of emulation tools' state='0' impact='100'>
              <desc>The inappropriate use of emulation tools are not detected by the app, and attackers can
                  leverage them to obtain information about the app.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2018-05-29T09:15:59.915'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </weakness>
          <weakness ref='MASVS-REVERSE-ENGINEERING-TOOLS' name='Inappropriate use of reverse engineering tools'
                    state='0' impact='100'>
              <desc>The inappropriate use of the reverse engineering tools is not detected by the app, and
                  attackers can leverage them to obtain information about the app.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2018-05-29T09:15:59.893'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </weakness>
        <weakness ref='CWE-732' name='Incorrect Permission Assignment for Critical Resource' state='0' impact='100'>
          <desc>The software specifies permissions for a security-critical resource in a way which allows that
                        resource to be read or modified by unintended actors.

                        When a resource is given a permissions setting that provides access to a wider range of actions
                        than required, it could lead to the exposure of sensitive information, or the modification of
                        that resource by unintended parties. This is especially dangerous when the resource is related
                        to program configuration, execution or sensitive user data.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.394'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-732: Incorrect Permission Assignment for Critical Resource' url='https://cwe.mitre.org/data/definitions/732.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-215' name='Information Exposure Through Debug Information' state='0' impact='100'>
          <desc>The application contains debugging code that can expose sensitive information to untrusted
                        parties.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.335'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-215: Information Exposure Through Debug Information' url='https://cwe.mitre.org/data/definitions/215.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-489' name='Leftover Debug Code' state='0' impact='100'>
          <desc>The application can be deployed with active debugging code that can create unintended entry
                        points.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.362'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-489: Leftover Debug Code' url='https://cwe.mitre.org/data/definitions/489.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-656' name='Reliance on Security Through Obscurity' state='0' impact='100'>
          <desc>The software uses a protection mechanism whose strength depends heavily on its obscurity, such
                        that knowledge of its algorithms or key data is sufficient to defeat the mechanism.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:58.372'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-656: Reliance on Security Through Obscurity' url='https://cwe.mitre.org/data/definitions/656.html' />
            </references>
            <udts />
          </test>
        </weakness>
      </weaknesses>
      <controls>
        <control ref='MASVS-7.8' name='Activate the Free Security Features' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>For Android:&amp;nbsp;
                        &lt;div&gt;
                        &lt;ul&gt;
                        &lt;li&gt;We shall activate the Obfuscation of the code and strip unneeded debugging
                        information.&amp;nbsp;&lt;/li&gt;
                        &lt;/ul&gt;For iOS:&amp;nbsp;
                        &lt;/div&gt;
                        &lt;div&gt;
                        &lt;ul&gt;
                        &lt;li&gt;We shall activate:&amp;nbsp;&lt;/li&gt;
                        &lt;ul&gt;
                        &lt;li&gt;ARC (Automatic Reference Counting): memory management feature, adds retain and release
                        messages when required.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Stack Canary: helps prevent buffer overflow attacks.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;PIE (Position Independent Executable): enables full ASLR for binary.&lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;/ul&gt;
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Verifying Compiler Settings' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05i-Testing-Code-Quality-and-Build-Settings.html#verifying-compiler-settings' />
            <reference name='OWASP MASVS - iOS - Verifying Compiler Settings' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06i-Testing-Code-Quality-and-Build-Settings.html#testing-compiler-settings' />
          </references>
          <standards>
            <standard ref='7.8' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='7.8' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='7.8' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='7.8' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-6.6' name='Allow only the minimum set of protocol handlers required' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Configure the WebViews to allow only the minimum set of protocol handlers required (ideally,
                        only https). Potentially dangerous handlers, such as file, tel and app-id, are disabled.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing WebView Protocol Handlers' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-webview-protocol-handlers' />
            <reference name='OWASP MASVS - iOS - Testing WebView Protocol Handlers' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-ios-webviews' />
          </references>
          <standards>
            <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='6.6' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that the set of protocol handlers are deactivated.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-2.6' name='Anonymize all data that is sent to 3rd Party services' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>All data that is sent to 3rd Party services shall be anonymized, so no PII data is available
                        that would allow the 3rd party to identify the user account. Also all other data, like IDs in an
                        application that can be mapped to a user account or session should not be sent to a third party.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Whether Sensitive Data Is Exposed via IPC Mechanisms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#determining-whether-sensitive-stored-data-has-been-exposed-via-ipc-mechanisms' />
            <reference name='OWASP MASVS - iOS - Testing Whether Sensitive Data Is Exposed via IPC Mechanisms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-whether-sensitive-data-is-exposed-via-ipc-mechanisms' />
          </references>
          <standards>
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.6' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that all data that is sent to 3rd Party services is anonymized.

                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-7.5' name='Catch and handle the possible exceptions' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Implement a well-designed and unified scheme to handle exceptions. Make sure the application
                        has centralized handlers for exceptions that result in similar behavior. This can be a static
                        class for instance. For specific exceptions given the methods context, specific catch blocks
                        should be provided.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Exception Handling' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05i-Testing-Code-Quality-and-Build-Settings.html#testing-exception-handling' />
            <reference name='OWASP MASVS - iOS - Testing Exception Handling' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06i-Testing-Code-Quality-and-Build-Settings.html#testing-exception-handling' />
          </references>
          <standards>
            <standard ref='7.5' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='7.5' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='7.5' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='7.5' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that the exceptions are well-designed and are catched and handled well.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-2.11' name='Create the functionality to verify the app uses a minimum device-access-security policy' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
            <desc>Different checks on the Android device can be implemented by querying different system preferences
                from Settings.Secure. The Device Administration API offers different mechanisms to create security aware
                applications, that are able to enforce password policies or encryption of the device.
            </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing the Device-Access-Security Policy' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#testing-the-device-access-security-policy' />
            <reference name='OWASP MASVS - iOS - Testing the Device-Access-Security Policy' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-the-device-access-security-policy' />
          </references>
          <standards>
            <standard ref='2.11' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.11' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that the app verifies the mobile device complies with the minimum
                            device-access-security policy.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-7.6' name='Deny the access by default when an uncaught exception appears' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Deny the access by default to prevent the app crashing because of uncaught exception and to
                        avoid unauthorised access.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Error Handling in Security Controls' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05i-Testing-Code-Quality-and-Build-Settings.html#testing-exception-handling' />
            <reference name='OWASP MASVS - iOS - Testing Error Handling in Security Controls' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06i-Testing-Code-Quality-and-Build-Settings.html#testing-exception-handling' />
          </references>
          <standards>
            <standard ref='7.6' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='7.6' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='7.6' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='7.6' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that the application denies access to the session when the exceptions appear.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-6.5' name='Disable JavaScript by default in a WebView if it is not necessary' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>JavaScript is disabled by default in a WebView and if not needed shouldn't be enabled. This
                        reduces the attack surface and potential threats to the app.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing JavaScript Execution in WebViews' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-javascript-execution-in-webviews' />
            <reference name='OWASP MASVS - iOS - Testing JavaScript Execution in WebViews' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-ios-webviews' />
          </references>
          <standards>
            <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='6.5' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>For Android:&amp;nbsp;
                            &lt;div&gt;
                            &lt;ul&gt;
                            &lt;li&gt;Search in the code the following instruction:
                            webview.getSettings().setJavaScriptEnabled(true);&lt;/li&gt;
                            &lt;li&gt;Check that this instruction doesn't exist in the code.&amp;nbsp;&lt;/li&gt;
                            &lt;/ul&gt;For iOS:&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            &lt;ul&gt;
                            &lt;li&gt;Check that the JavaScript is disabled and configured as following:&amp;nbsp;&lt;/li&gt;
                            &lt;/ul&gt;
                            &lt;/div&gt;
                            &lt;blockquote&gt;
                            &lt;div&gt;
                            #import &amp;quot;ViewController.h&amp;quot;&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            #import @interface ViewController () @property(strong,nonatomic) WKWebView *webView;
                            &lt;/div&gt;
                            &lt;div&gt;
                            @end @implementation ViewController - (void)viewDidLoad { NSURL *url = [NSURL
                            URLWithString:@&amp;quot;http://www.example.com/&amp;quot;];&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            NSURLRequest *request = [NSURLRequest requestWithURL:url];&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            WKPreferences *pref = [[WKPreferences alloc] init]; //Disable javascript execution: [pref
                            setJavaScriptEnabled:NO];&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            [pref setJavaScriptCanOpenWindowsAutomatically:NO];&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            WKWebViewConfiguration *conf = [[WKWebViewConfiguration alloc] init];&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            [conf setPreferences:pref]; _webView = [[WKWebView
                            alloc]initWithFrame:CGRectMake(self.view.frame.origin.x,85, self.view.frame.size.width,
                            self.view.frame.size.height-85) configuration:conf] ;&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            [_webView loadRequest:request];&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            [self.view addSubview:_webView]; }
                            &lt;/div&gt;
                            &lt;/blockquote&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-6.7' name='Do not load user-supplied local resources into WebViews' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>WebViews can load content remotely and locally from the app data directory. If the content is
                        loaded locally, users should not be able to change the filename or path from which the file is
                        loaded, and they shouldn't be able to edit the loaded file.

                        To avoid this you shall not allow the loading of local resources into the Webviews.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing for Local File Inclusion in WebViews' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-javascript-execution-in-webviews' />
            <reference name='OWASP MASVS - iOS - Testing for Local File Inclusion in WebViews' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-ios-webviews' />
          </references>
          <standards>
            <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='6.7' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check if you can identify and change the url of local or remote files and if you can
                            access those files.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
          <control ref='MASVS-8.10' name='Do not use the SSAID for &apos;device binding&apos;' platform='' cost='1'
                   risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Do not use the SSAID for device binding because the behavior of the SSAID has changed since
                  Android O and the behavior of MAC addresses have changed in Android N.

                  Google has set a new set of recommendations in their SDK documentation regarding identifiers as
                  well. Because of this new behavior, we recommend developers not rely on the SSAID alone, as the
                  identifier has become less stable. For instance: The SSAID might change upon a factory reset or
                  when the app is reinstalled after the upgrade to Android O. Please note that there are a number
                  of devices which have the same ANDROID_ID and/or have an ANDROID_ID that can be overridden.
                  Also, the Build.Serial was often used but now apps targeting Android O will get "UNKNOWN" when
                  they request the Build.Serial.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Device Binding'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-device-binding'/>
                  <reference name='OWASP MASVS - iOS - Testing Device Binding'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#device-binding'/>
              </references>
              <standards>
                  <standard ref='8.10' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.10' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>&lt;ul&gt;
                      &lt;li&gt;Dynamic Analysis using an Emulator.&lt;/li&gt;
                      &lt;li&gt;Run the application on an Emulator.&lt;/li&gt;
                      &lt;li&gt;Make sure you can raise the trust in the instance of the application (e.g.
                      authenticate).&lt;/li&gt;
                      &lt;li&gt;Retrieve the data from the Emulator. This has a few steps:&amp;nbsp;&lt;/li&gt;
                      &lt;/ul&gt;
                      &lt;ol&gt;
                      &lt;ol&gt;
                      &lt;li&gt;ssh to your emulator using ADB shell&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;run-as&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;chmod 777 the contents of cache and shared-preferences&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;exit the current user&lt;/li&gt;
                      &lt;li&gt;copy the contents of /dat/data//cache &amp;amp; shared-preferences to the sdcard&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;use ADB or the DDMS to pull the contents&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Install the application on another Emulator&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;&amp;nbsp;Overwrite the data from step 3 in the data folder of the application.&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;copy the contents of step 3 to the sdcard of the second emulator.&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;ssh to your emulator using ADB shell&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;run-as&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;chmod 777 the folders cache and shared-preferences&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;copy the older contents of the sdcard to /dat/data//cache &amp;amp;
                      shared-preferences&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Can you continue in an authenticated state? If so, then binding might not be
                      working properly.&lt;/li&gt;
                      &lt;/ol&gt;
                      &lt;/ol&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-8.8' name='Encrypt and pack all executable files and libraries belonging to the app'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Ensure that all executable files and libraries belonging to the app are encrypted on the file
                  level and/or important code and data segments inside the executables are encrypted or packed.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Simple Obfuscation'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-obfuscation'/>
                  <reference name='OWASP MASVS - iOS - Testing Simple Obfuscation'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-simple-obfuscation'/>
              </references>
              <standards>
                  <standard ref='8.8' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.8' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check that all executable files and libraries belonging to the app are encrypted or
                      packed.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-8.7'
                   name='Ensure that the app responds correctly against tampering, debugging and emulation' platform=''
                   cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Ensure the app implements multiple different responses to tampering, debugging and emulation,
                  including stealthy responses that don't simply terminate the app.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Verifying the Variability of Tampering Responses'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#verifying-the-variablility-of-tampering-responses'/>
                  <reference name='OWASP MASVS - iOS - Verifying the Variability of Tampering Responses'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#verifying-variablility-of-tampering-responses'/>
              </references>
              <standards>
                  <standard ref='8.7' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.7' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check the app implements multiple different responses to tampering, debugging and
                      emulation, including stealthy responses that don't simply terminate the app.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-8.3' name='Implement functionality to alert when the app code changes' platform=''
                   cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Implement functionality to detect, notify and respond when the app is modified by executable
                  files or by anti-debugging tools. When the injection is detected the app shall alert the user
                  and terminate the session.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing File Integrity Checks'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content//0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-file-integrity-checks'/>
                  <reference name='OWASP MASVS - iOS - Testing File Integrity Checks'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#file-integrity-checks'/>
              </references>
              <standards>
                  <standard ref='8.3' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.3' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>&lt;ol&gt;
                      &lt;li&gt;For the application source integrity checks, run the app on the device in an
                      unmodified state and make sure that everything works.&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Then apply simple patches to the classes.dex and any .so libraries contained in
                      the app package. Re-package and re-sign the app.&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Check the app alerts the user and/or terminates the session.&lt;/li&gt;
                      &lt;/ol&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-8.6'
                   name='Implement functionality to detect and respond to, modifications of process memory' platform=''
                   cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Create functionality to detect &amp;quot;hostile&amp;quot; code in its memory and respond
                  accordingly. Controls in this category verify the integrity of the app's own memory space, with
                  the goal of protecting against memory patches applied during runtime. This includes unwanted
                  changes to binary code or bytecode, functions pointer tables, and important data structures, as
                  well as rogue code loaded into process memory.&amp;nbsp;
                  &lt;div&gt;
                  &lt;br /&gt;
                  &lt;div&gt;
                  Integrity can be verified either by:&amp;nbsp;
                  &lt;div&gt;
                  &lt;ul&gt;
                  &lt;li&gt;Comparing the contents of memory, or a checksum over the contents, with known good
                  values.&amp;nbsp;&lt;/li&gt;
                  &lt;li&gt;Searching memory for signatures of unwanted modifications.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/div&gt;
                  &lt;/div&gt;
                  &lt;/div&gt;
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Memory Integrity Checks'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-memory-integrity-checks'/>
                  <reference name='OWASP MASVS - iOS - Testing Memory Integrity Checks'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-memory-integrity-checks'/>
              </references>
              <standards>
                  <standard ref='8.6' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.6' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>&lt;ul&gt;
                      &lt;li&gt;Disable all file-based detection of reverse engineering tools.&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Then inject code using Xposed, Frida and Substrate, and attempt to install native
                      hooks and Java method hooks.&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Check that the app detects the &amp;quot;hostile&amp;quot; code in its memory and
                      responds accordingly.&lt;/li&gt;
                      &lt;/ul&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-8.5' name='Implement functionality to detect if the app is being run inside an emulator'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Create and implement functionality to detect when the app is being run inside an emulator. If
                  the app is running inside an emulator, the app shall terminate the session.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Simple Emulator Detection'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-emulator-detection'/>
                  <reference name='OWASP MASVS - iOS - Testing Simple Emulator Detection'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-simple-emulator-detection'/>
              </references>
              <standards>
                  <standard ref='8.5' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.5' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>&lt;ol&gt;
                      &lt;li&gt;Install and run the app within an emulator.&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Check the app detects this and terminates the session.&lt;/li&gt;
                      &lt;/ol&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-8.4'
                   name='Implement functionality to detect the presence of widely used reverse engineering tools'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Create functionality to detect the presence of widely used reverse engineering tools, such as
                  code injection tools, hooking frameworks and debugging servers. If any reverse engineering tool
                  is detected, the app shall force termination of the session.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Detection of Reverse Engineering Tools'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-detection-of-reverse-engineering-tools'/>
                  <reference name='OWASP MASVS - iOS - Testing Detection of Reverse Engineering Tools'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-detection-of-reverse-engineering-tools'/>
              </references>
              <standards>
                  <standard ref='8.4' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.4' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Launch the app systematically with various apps and frameworks installed, such as the
                      following:&amp;nbsp;
                      &lt;div&gt;
                      &lt;ul&gt;
                      &lt;li&gt;Substrate for Android&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Xposed&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Frida&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Introspy-Android&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Drozer&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;RootCloak&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Android SSL Trust Killer&amp;nbsp;&lt;/li&gt;
                      &lt;/ul&gt;The app should alert the user and/or terminate the app.
                      &lt;/div&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-8.2'
                   name='Implement functionality to notify when anti-debugging mechanisms are presented within the app'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Implement anti-debugging mechanisms to prohibit debug mode being activated. Anti-debugging
                  features can be preventive or reactive. As the name implies, preventive anti-debugging
                  techniques prevent the debugger from attaching in the first place, while reactive techniques
                  attempt to detect whether a debugger is present and react to it in some way (e.g. terminating
                  the app, or triggering some kind of hidden behavior).&amp;nbsp;
                  &lt;div&gt;
                  &lt;br /&gt;
                  &lt;/div&gt;
                  &lt;div&gt;
                  The &amp;quot;more-is-better&amp;quot; rule applies: To maximize effectiveness, defenders
                  combine multiple methods of prevention and detection which operate on different API layers and
                  are distributed throughout the app.
                  &lt;/div&gt;
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Debugging Defenses'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#ttesting-anti-debugging'/>
                  <reference name='OWASP MASVS - iOS - Testing Debugging Defenses'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-debugging-defenses'/>
              </references>
              <standards>
                  <standard ref='8.2' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.2' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check for the presence of anti-debugging mechanisms and verify if with the following
                      criteria the anti-debugging mechanisms are bypassed:&amp;nbsp;
                      &lt;div&gt;
                      &lt;ul&gt;
                      &lt;li&gt;Attaching JDB and ptrace based debuggers either fails or causes the app to
                      terminate or malfunction&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Multiple detection methods are scattered throughout the app (as opposed to putting
                      everything into a single method or function);&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;The anti-debugging defenses operate on multiple API layers (Java, native library
                      functions, Assembler/system calls);&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;The mechanisms show some level of originality (vs. copy/paste from StackOverflow
                      or other sources);&lt;/li&gt;
                      &lt;/ul&gt;
                      &lt;/div&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-8.11'
                   name='Implement two or more independent functionalities to detect the app is running inside an emulator.'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Implement two or more independent functionalities to detect when the app is running inside an
                  emulator in the context of the overall protection scheme. With this security protection in
                  place, the app forces the adversary to invest significantly more manual effort to run the app
                  within an emulator.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Advanced Anti-Emulation'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-emulator-detection'/>
                  <reference name='OWASP MASVS - iOS - Testing Advanced Anti-Emulation'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-advanced-anti-emulation'/>
              </references>
              <standards>
                  <standard ref='8.11' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.11' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check if there exists two or more functionalities to detect the app is running inside an
                      emulator.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-8.1' name='Implement two or more independent functionallies for root detection'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Implement two or more independent methods to detect rooted devices and if the device is rooted, the
                  app shall respond in two ways:&amp;nbsp;
                  &lt;div&gt;
                  &lt;ul&gt;
                  &lt;li&gt;The app notifies the user that their device is rooted and it's not secure to continue with
                  the app.&amp;nbsp;&lt;/li&gt;
                  &lt;li&gt;Terminate the session and the app, because sensitive data is vulnerable.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/div&gt;
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Advanced Root Detection'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-root-detection'/>
                  <reference name='OWASP MASVS - iOS - Testing Advanced Root Detection'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#jailbreak-detection'/>
              </references>
              <standards>
                  <standard ref='8.1' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.1' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>&lt;ul&gt;
                      &lt;li&gt;Check that the app has two or more functionalities with independent methods to
                      detect a rooted device.&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Check that if the device is rooted, the user is alerted or the app is terminated.&lt;/li&gt;
                      &lt;/ul&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
        <control ref='MASVS-7.4' name='Insert the condition DEVELOPER-MODE to remove the debugging code, log verbose errors or debugging messages in the production version' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Insert the policy in the if statement with DEVELOPER_MODE as condition. The DEVELOPER_MODE has
                        to be disabled for release build in order to disable StrictMode too.&amp;nbsp;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        Remove the debugging code, log verbose errors or debugging messages in the production version.
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing for Debugging Code and Verbose Error Logging' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05i-Testing-Code-Quality-and-Build-Settings.html#testing-for-debugging-code-and-verbose-error-logging' />
            <reference name='OWASP MASVS - iOS - Testing for Debugging Code and Verbose Error Logging' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06i-Testing-Code-Quality-and-Build-Settings.html#testing-for-debugging-code-and-verbose-error-logging' />
          </references>
          <standards>
            <standard ref='7.4' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='7.4' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='7.4' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='7.4' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>&lt;ul&gt;
                            &lt;li&gt;Check that there is only one method to activate the DEVELOPMENT_MODE.&lt;/li&gt;
                            &lt;li&gt;Check that the debugging code was removed.&lt;/li&gt;
                            &lt;/ul&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
          <control ref='MASVS-8.9' name='Obfuscate all executable files, libraries, important code and data segments'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Obfuscation is the process of transforming code and data in order to make it more difficult to
                  comprehend. It is an integral part of every software protection scheme.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Advanced Obfuscation'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-obfuscation'/>
                  <reference name='OWASP MASVS - iOS - Testing Advanced Obfuscation'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-simple-obfuscation'/>
              </references>
              <standards>
                  <standard ref='8.12' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.13' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check that the code is unreadable.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
        <control ref='MASVS-7.3' name='Remove or obfuscate the debugging symbols from native binaries' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>As a general rule of thumb, as little explanative information as possible should be provided
                        along with the compiled code. Some metadata such as debugging information, line numbers and
                        descriptive function or method names make the binary or bytecode easier to understand for the
                        reverse engineer, but isn't actually needed in a release build and can therefore be safely
                        discarded without impacting the functionality of the app.

                        This data shall be removed from the release version or shall be obfuscated in order to be
                        inaccessible to the reverse engineer.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing for Debugging Symbols' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05i-Testing-Code-Quality-and-Build-Settings.html#testing-for-debugging-symbols' />
            <reference name='OWASP MASVS - iOS - Testing for Debugging Symbols' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06i-Testing-Code-Quality-and-Build-Settings.html#testing-for-debugging-symbols' />
          </references>
          <standards>
            <standard ref='7.3' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='7.3' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='7.3' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='7.3' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>For Android:&amp;nbsp;
                            &lt;blockquote&gt;
                            &lt;div&gt;
                            Symbols are usually stripped during the build process, so you need the compiled byte-code
                            and libraries to verify whether any unnecessary metadata has been discarded. First find the
                            nm binary in your Android NDK and export it (or create an alias).
                            &lt;/div&gt;
                            &lt;div&gt;
                            &lt;br /&gt;
                            &lt;/div&gt;
                            &lt;/blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;div&gt;
                            export $NM =
                            $ANDROID_NDK_DIR/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-nm&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            &lt;br /&gt;
                            &lt;/div&gt;
                            &lt;/blockquote&gt;
                            &lt;/blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;div&gt;
                            To display debug symbols:
                            &lt;/div&gt;
                            &lt;/blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;div&gt;
                            $ $NM -a
                            libfoo.so/tmp/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-nm:
                            libfoo.so: no symbols&amp;nbsp;
                            &lt;/div&gt;
                            &lt;/blockquote&gt;To display dynamic symbols:
                            &lt;/blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;blockquote&gt;
                            $ $NM -D libfoo.so&amp;nbsp;
                            &lt;/blockquote&gt;Alternatively, open the file in your favorite disassembler and check the
                            symbol tables manually. Dynamic symbols can be stripped using the visibility compiler flag.
                            Adding this flag causes gcc to discard the function names while still preserving the names
                            of functions declared as JNIEXPORT.&amp;nbsp;
                            &lt;/blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;br /&gt;
                            &lt;/blockquote&gt;
                            &lt;blockquote&gt;
                            Check if the following was added to build.gradle:&amp;nbsp;
                            &lt;/blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;blockquote&gt;
                            externalNativeBuild { cmake { cppFlags &amp;quot;-fvisibility=hidden&amp;quot; } }&amp;nbsp;
                            &lt;/blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;br /&gt;
                            &lt;/blockquote&gt;
                            &lt;/blockquote&gt;For iOS:&amp;nbsp;
                            &lt;blockquote&gt;
                            &lt;div&gt;
                            Use gobjdump to inspect the main binary and any included dylibs for Stabs and DWARF symbols.
                            &lt;/div&gt;
                            &lt;/blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;div&gt;
                            $ gobjdump --stabs --dwarf TargetApp&amp;nbsp;
                            &lt;/div&gt;
                            &lt;/blockquote&gt;In archive MyTargetApp:&amp;nbsp;
                            &lt;/blockquote&gt;
                            &lt;blockquote&gt;
                            &lt;blockquote&gt;
                            - armv5te: file format mach-o-arm - aarch64: file format mach-o-arm64 Gobjdump is part of
                            binutils and can be installed via Homebrew on Mac OS X.
                            &lt;/blockquote&gt;
                            &lt;/blockquote&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='CWE-250-MOBILE' name='Request only the minimum required permissions from the mobile operating system' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
            <desc>Security best practice dictates the practice of least-privilege is followed, thereby reducing the
                attack surface and risk of compromise. By limiting the access an application has to the system,
                developers may reduce the impact a compromise may have.&amp;nbsp;
                &lt;div&gt;
                &lt;br /&gt;
                &lt;/div&gt;
                &lt;div&gt;
                Request only the minimum required permissions from the mobile operating system. For example, if there is
                no requirement to use the camera then the application should not request this permission.
                &lt;/div&gt;
                &lt;div&gt;
                &lt;br /&gt;
                &lt;/div&gt;
                &lt;div&gt;
                Review features and functionality present in the application, in particular legacy features, to
                determine if they are relevant and required, and if not remove them and associated OS permissions.
                &lt;/div&gt;
            </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing App Permissions' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-app-permissions' />
            <reference name='OWASP MASVS - iOS - Testing App Permissions' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-app-permissions' />
          </references>
          <standards>
            <standard ref='6.1' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='6.1' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='6.1' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='6.1' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>For Android applications:&amp;nbsp;
                            &lt;div&gt;
                            &lt;ol&gt;
                            &lt;li&gt;Install the application and review the permissions the application is asking for.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Check they are actually needed.&lt;/li&gt;
                            &lt;/ol&gt;For iOS applications:&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            &lt;ol&gt;
                            &lt;li&gt;Install the application and use its main functionality, iOS will ask for the
                            permission when it is needed.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Verify those permissions requests are in accordance with the minimum set of
                            permissions needed by the application.&lt;/li&gt;
                            &lt;/ol&gt;
                            &lt;/div&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-7.7' name='Secure in the unmanaged code, the allocated memory, freed memory and used memory' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Memory corruption bugs are a popular mainstay for hackers. This class of bug results from a
                        programming error that causes the program to access an unintended memory location. Under the
                        right conditions, attackers can capitalize on this behavior to hijack the execution flow of the
                        vulnerable program and execute arbitrary code.&amp;nbsp;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        This kind of vulnerability occurs in a number of ways:
                        &lt;div&gt;
                        &lt;ul&gt;
                        &lt;li&gt;&lt;b&gt;Buffer overflows:&lt;/b&gt; This describes a programming error where an app
                        writes beyond an allocated memory range for a particular operation. An attacker can use this
                        flaw to overwrite important control data located in adjacent memory, such as function pointers.
                        Buffer overflows were formerly the most common type of memory corruption flaw, but have become
                        less prevalent over the years due to a number of factors. Notably, awareness among developers of
                        the risks in using unsafe C library functions is now a common best practice plus, catching
                        buffer overflow bugs is relatively simple. However, it is still worth testing for such defects.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;&lt;b&gt;Out-of-bounds-access: &lt;/b&gt;Buggy pointer arithmetic may cause a pointer
                        or index to reference a position beyond the bounds of the intended memory structure (e.g. buffer
                        or list). When an app attempts to write to an out-of-bounds address, a crash or unintended
                        behavior occurs. If the attacker can control the target offset and manipulate the content
                        written to some extent, code execution exploit is likely possible.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;&lt;b&gt;Dangling pointers:&lt;/b&gt; These occur when an object with an incoming
                        reference to a memory location is deleted or deallocated, but the object pointer is not reset.
                        If the program later uses the dangling pointer to call a virtual function of the already
                        deallocated object, it is possible to hijack execution by overwriting the original vtable
                        pointer. Alternatively, it is possible to read or write object variables or other memory
                        structures referenced by a dangling pointer.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;&lt;b&gt;Use-after-free:&lt;/b&gt; This refers to a special case of dangling pointers
                        referencing released (deallocated) memory. After a memory address is cleared, all pointers
                        referencing the location become invalid, causing the memory manager to return the address to a
                        pool of available memory. When this memory location is eventually re-allocated, accessing the
                        original pointer will read or write the data contained in the newly allocated memory. This
                        usually leads to data corruption and undefined behavior, but crafty attackers can set up the
                        appropriate memory locations to leverage control of the instruction pointer.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;&lt;b&gt;Integer overflows: &lt;/b&gt;When the result of an arithmetic operation
                        exceeds the maximum value for the integer type defined by the programmer, this results in the
                        value &amp;quot;wrapping around&amp;quot; the maximum integer value, inevitably resulting in a
                        small value being stored. Conversely, when the result of an arithmetic operation is smaller than
                        the minimum value of the integer type, an integer underflow occurs where the result is larger
                        than expected. Whether a particular integer overflow/underflow bug is exploitable depends on how
                        the integer is used – for example, if the integer type were to represent the length of a
                        buffer,
                        this could create a buffer overflow vulnerability.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;&lt;b&gt;Format string vulnerabilities: &lt;/b&gt;When unchecked user input is passed
                        to the format string parameter of the printf() family of C functions, attackers may inject
                        format tokens such as ‘%c’ and ‘%n’ to access memory. Format string bugs
                        are convenient to
                        exploit due to their flexibility. Should a program output the result of the string formatting
                        operation, the attacker can read and write to memory arbitrarily, thus bypassing protection
                        features such as ASLR.&amp;nbsp;&lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;b&gt;Remediation:&amp;nbsp;&lt;/b&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        A best practice to fix the Memory Corruption Bugs are the following:&amp;nbsp;
                        &lt;/div&gt;
                        &lt;div&gt;
                        &lt;ul&gt;
                        &lt;li&gt;When using integer variables for array indexing, buffer length calculations, or any
                        other security-critical operation, verify that unsigned integer types are used and perform
                        precondition tests to prevent the possibility of integer wrapping.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Ensure the app does not use unsafe string functions such as strcpy, most other
                        functions beginning with the “str” prefix, sprint, vsprintf, gets, etc.; If the app
                        contains C++
                        code, ANSI C++ string classes are used; iOS apps written in Objective-C use NSString class. C
                        apps on iOS should use CFString, the Core Foundation representation of a string. No untrusted
                        data is concatenated into format strings.&lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;/div&gt;
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Testing for Memory Management Bugs' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x04h-Testing-Code-Quality.html#memory-corruption-bugs' />
          </references>
          <standards>
            <standard ref='7.7' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='7.7' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='7.7' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='7.7' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check if some of the different Memory Corruption bugs appear when you try to use them to
                            gain access to the system.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-7.1' name='Sign the app and provision with valid certificate' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Code signing your app assures users that it is from a known source and the app hasn’t
                        been
                        modified since it was last signed. This process can prevent an app from being tampered with, or
                        modified to include malicious code.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Verifying That the App is Properly Signed' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05i-Testing-Code-Quality-and-Build-Settings.html#verifying-that-the-app-is-properly-signed' />
            <reference name='OWASP MASVS - iOS - Verifying That the App is Properly Signed' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06i-Testing-Code-Quality-and-Build-Settings.html#verifying-that-the-app-is-properly-signed' />
          </references>
          <standards>
            <standard ref='7.1' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='7.1' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='7.1' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='7.1' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that the app is correctly signed.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
      </controls>
      <usecases>
        <usecase ref='GENERAL' name='General' desc='' library=''>
          <threats>
            <threat ref='CAPEC-133' name='An attacker attempts to invoke all common switches and options to discover weaknesses ' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker attempts to invoke all common switches and options in the target
                                application for the purpose of discovering weaknesses in the target. For example, in
                                some applications, adding the --debug switch causes debugging information to be
                                displayed, which can sometimes reveal sensitive processing or configuration information
                                to an attacker. This attack differs from other forms of API abuse in that the attacker
                                is blindly attempting to invoke options in the hope that one of them will work rather
                                than specifically targeting a known option. Nonetheless, even if the attacker is
                                familiar with the published options of a targeted application this attack method may
                                still be fruitful as it might discover unpublicized functionality.
                            </desc>
              <riskRating confidentiality='50' integrity='50' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-215'>
                  <controls>
                      <control ref='MASVS-7.3' mitigation='17'/>
                      <control ref='MASVS-7.4' mitigation='17'/>
                      <control ref='MASVS-8.2' mitigation='17'/>
                  </controls>
                </weakness>
                <weakness ref='CWE-489'>
                  <controls>
                      <control ref='MASVS-7.4' mitigation='17'/>
                  </controls>
                </weakness>
                <weakness ref='CWE-656'>
                  <controls>
                      <control ref='MASVS-7.8' mitigation='17'/>
                      <control ref='MASVS-8.8' mitigation='16'/>
                      <control ref='MASVS-8.9' mitigation='16'/>
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                  <control ref='MASVS-7.3' mitigation='17'/>
                  <control ref='MASVS-7.4' mitigation='17'/>
                  <control ref='MASVS-7.8' mitigation='17'/>
                  <control ref='MASVS-8.2' mitigation='17'/>
                  <control ref='MASVS-8.8' mitigation='16'/>
                  <control ref='MASVS-8.9' mitigation='16'/>
              </controls>
            </threat>
            <threat ref='CAPEC-184' name='An attacker initiates a series of events to perform actions which undermine the integrity of software code' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker initiates a series of events designed to cause a user, program, server, or
                                device to perform actions which undermine the integrity of software code, device data
                                structures, or device firmware, achieving the modification of the target's integrity to
                                achieve an insecure state.
                            </desc>
              <riskRating confidentiality='25' integrity='25' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-494'>
                  <controls>
                      <control ref='MASVS-7.1' mitigation='50'/>
                      <control ref='MASVS-8.3' mitigation='50'/>
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                  <control ref='MASVS-7.1' mitigation='50'/>
                  <control ref='MASVS-8.3' mitigation='50'/>
              </controls>
            </threat>
              <threat ref='CAPEC-188'
                      name='Attacker gains access to sensitive data by modifying the application&apos;s expected behavior'
                      state='Expose' source='MANUAL' owner='' library=''>
                  <desc>An attacker discovers the structure, function, and composition of an object, resource,
                      or system by using a variety of analysis techniques to effectively determine how the
                      analyzed entity was constructed or operates. The goal of reverse engineering is often to
                      duplicate the function, or a part of the function, of an object in order to duplicate or
                      &amp;quot;back engineer&amp;quot; some aspect of its functioning.&amp;nbsp;
                      &lt;div&gt;
                      &lt;br /&gt;
                      &lt;/div&gt;
                      &lt;div&gt;
                      Reverse engineering techniques can be applied to mechanical objects, electronic devices,
                      or software, although the methodology and techniques involved in each type of analysis
                      differ widely. When adversaries are reverse engineering software, methodologies fall
                      into two broad categories, 'white box' and 'black box.' White box techniques involve
                      methods which can be applied to a piece of software when an executable or some other
                      compiled object can be directly subjected to analysis, revealing at least a portion of
                      its machine instructions that can be observed upon execution.
                      &lt;/div&gt;
                      &lt;div&gt;
                      &lt;br /&gt;
                      &lt;/div&gt;
                      &lt;div&gt;
                      'Black Box' methods involve interacting with the software indirectly, in the absence of
                      the ability to measure, instrument, or analyze an executable object directly. Such
                      analysis typically involves interacting with the software at the boundaries of where the
                      software interfaces with a larger execution environment, such as input-output vectors,
                      libraries, or APIs.
                      &lt;/div&gt;
                  </desc>
                  <riskRating confidentiality='25' integrity='25' availability='100' easeOfExploitation='100'/>
                  <references/>
                  <weaknesses>
                      <weakness ref='MASVS-EMULATION-TOOLS'>
                          <controls>
                              <control ref='MASVS-8.11' mitigation='16'/>
                              <control ref='MASVS-8.5' mitigation='17'/>
                              <control ref='MASVS-8.7' mitigation='17'/>
                          </controls>
                      </weakness>
                      <weakness ref='MASVS-REVERSE-ENGINEERING-TOOLS'>
                          <controls>
                              <control ref='MASVS-8.10' mitigation='16'/>
                              <control ref='MASVS-8.4' mitigation='17'/>
                              <control ref='MASVS-8.6' mitigation='17'/>
                          </controls>
                      </weakness>
                  </weaknesses>
                  <controls>
                      <control ref='MASVS-8.10' mitigation='16'/>
                      <control ref='MASVS-8.11' mitigation='16'/>
                      <control ref='MASVS-8.4' mitigation='17'/>
                      <control ref='MASVS-8.5' mitigation='17'/>
                      <control ref='MASVS-8.6' mitigation='17'/>
                      <control ref='MASVS-8.7' mitigation='17'/>
                  </controls>
              </threat>
              <threat ref='CAPEC-122-MOBILE'
                      name='Users lose trust in the application because it requests unnecessary privileges'
                      state='Expose' source='MANUAL' owner='' library=''>
                  <desc>If the mobile application requests permissions or access to components that are not
                      strictly needed by the application, then users can lose trust in the security of the
                      application with an associated impact on the trust placed in the application provider.
                  </desc>
                  <riskRating confidentiality='50' integrity='50' availability='100' easeOfExploitation='100'/>
                  <references/>
                  <weaknesses>
                      <weakness ref='CWE-250'>
                          <controls>
                              <control ref='CWE-250-MOBILE' mitigation='33'/>
                              <control ref='MASVS-2.11' mitigation='33'/>
                              <control ref='MASVS-8.1' mitigation='34'/>
                          </controls>
                      </weakness>
                  </weaknesses>
                  <controls>
                      <control ref='CWE-250-MOBILE' mitigation='33'/>
                      <control ref='MASVS-2.11' mitigation='33'/>
                      <control ref='MASVS-8.1' mitigation='34'/>
              </controls>
            </threat>
          </threats>
        </usecase>
        <usecase ref='PROVIDE MOBILE ACCESS TO SERVICES' name='Provide mobile access to services' desc='' library=''>
          <threats>
            <threat ref='ACCESS-WEBVIEW' name='Attackers gain access to the data through the WebView functionality' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker employs forceful browsing to access portions of a website that are
                                otherwise unreachable through direct URL entry.

                                Usually, a front controller or similar design pattern is employed to protect access to
                                portions of a web application.

                                Forceful browsing enables an attacker to access information, perform privileged
                                operations and otherwise reach sections of the web application that have been improperly
                                protected.
                            </desc>
              <riskRating confidentiality='75' integrity='50' availability='50' easeOfExploitation='75' />
              <references />
              <weaknesses>
                <weakness ref='CWE-749'>
                  <controls>
                    <control ref='MASVS-6.6' mitigation='34' />
                  </controls>
                </weakness>
                <weakness ref='CWE-79'>
                  <controls>
                    <control ref='MASVS-6.7' mitigation='33' />
                  </controls>
                </weakness>
                <weakness ref='CWE-83'>
                  <controls>
                    <control ref='MASVS-6.5' mitigation='33' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-6.5' mitigation='33' />
                <control ref='MASVS-6.6' mitigation='34' />
                <control ref='MASVS-6.7' mitigation='33' />
              </controls>
            </threat>
            <threat ref='7k-CWE-ErrorH' name='Attackers gain unauthorised access to the application through an error handling flaw' state='Expose' source='MANUAL' owner='' library=''>
              <desc>Errors and error handling represent a class of API. Errors related to error handling
                                are so common that they deserve a special kingdom of their own. As with “API
                                Abuse,”
                                there are two ways to introduce an error-related security vulnerability: the most common
                                one is handling errors poorly (or not at all). The second is producing errors that
                                either give out too much information (to possible attackers) or are difficult to handle.
                            </desc>
              <riskRating confidentiality='100' integrity='100' availability='100' easeOfExploitation='50' />
              <references />
              <weaknesses>
                <weakness ref='CWE-388'>
                  <controls>
                    <control ref='MASVS-7.5' mitigation='50' />
                    <control ref='MASVS-7.6' mitigation='50' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-7.5' mitigation='50' />
                <control ref='MASVS-7.6' mitigation='50' />
              </controls>
            </threat>
            <threat ref='CAPEC-100' name='Attackers gain unauthorised access to the application through buffer overflow flaws' state='Expose' source='MANUAL' owner='' library=''>
              <desc>Buffer Overflow attacks target improper or missing bounds checking on buffer
                                operations, typically triggered by input injected by an attacker. As a consequence, an
                                attacker is able to write past the boundaries of allocated buffer regions in memory,
                                causing a program crash or potential redirection of execution as per the attackers'
                                choice.
                            </desc>
              <riskRating confidentiality='100' integrity='100' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-120'>
                  <controls>
                    <control ref='MASVS-7.7' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-7.7' mitigation='100' />
              </controls>
            </threat>
            <threat ref='CAPEC-1' name='Malicious applications gain access to unauthorised data or perform unauthorised actions' state='Expose' source='MANUAL' owner='' library=''>
              <desc>Attackers could use malicious mobile applications to attack legitimate applications
                                that export their components improperly.
                            </desc>
              <riskRating confidentiality='75' integrity='75' availability='1' easeOfExploitation='75' />
              <references />
              <weaknesses>
                <weakness ref='CWE-732'>
                  <controls>
                    <control ref='MASVS-2.6' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-2.6' mitigation='100' />
              </controls>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </component>
      <component ref='MOBILE-CLIENT:SENS-DATA-TRANSMIT' name='Mobile Client: Post sensitive data'
                 desc='Post sensitive data from the mobile client. This risk pattern is imported when we have a mobile device, and we don&apos;t know which  system runs and the mobile app sensitive data. It is a common risk pattern for all types of systems'
                 groupName='' tags='' position='8' library='' diagramPositionX='0' diagramPositionY='0'
                 componentDefinitionRef=''>
      <weaknesses>
        <weakness ref='CWE-525-MOBILE' name='Information Exposure Through Browser Caching' state='0' impact='100'>
          <desc>The application should have an appropriate caching policy specifying the extent to which data
                        and form fields should be cached.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:03.944'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-525: Information Exposure Through Browser Caching' url='https://cwe.mitre.org/data/definitions/525.html' />
            </references>
            <udts />
          </test>
        </weakness>
      </weaknesses>
      <controls>
        <control ref='CWE-525-MOBILE' name='Disable autocompletion of sensitive data' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Auto-completion or pre-filling of sensitive details by the mobile device or browser implies
                        that those details are stored in plaintext or a reversible format. This may be in violation of
                        security best-practice, or application security expectations. T
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        he application should attempt to mitigate this risk by requesting the browser does not cache or
                        store sensitive data such as credit card PANs and CV2s, personally identifiable information
                        (PII) or other secret data. All forms handling sensitive data should be protected using the
                        autocomplete=off HTML directive at the form or field level. Issue browser specific directives to
                        request auto-fill or completion is disabled; The AUTOCOMPLETE attribute should be set to &amp;quot;OFF&amp;quot;.&amp;nbsp;
                        &lt;/div&gt;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        Mobile applications must not store or offer to autocomplete sensitive data such as
                        authentication credentials, credit card numbers, or sensitive personal details. Where data is
                        stored locally, system provided stores should be used; for example, iOS and Android provide
                        password stores and digital wallets. It should be noted that compliance with these requests on
                        the client-side is optional, and many browsers and clients override these directives to use
                        operating system, browser, or third party password managers or key-safes to store secrets.
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Whether the Keyboard Cache Is Disabled for Text Input Fields' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#determining-whether-the-keyboard-cache-is-disabled-for-text-input-fields' />
            <reference name='OWASP MASVS - iOS - Testing Whether the Keyboard Cache Is Disabled for Text Input Fields' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-for-sensitive-data-in-the-keyboard-cache' />
          </references>
          <standards>
            <standard ref='2.4' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='2.4' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='2.4' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.4' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>&lt;ul&gt;
                            &lt;li&gt;The autocomplete attribute is restricted to WebViews being used within the mobile
                            client.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Check what WebViews the application uses.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Check if the form fields which contain sensitive data and are included in these
                            WebViews have the autocomplete='off' attribute. If this attribute is not set, then this test
                            should be regarded as having failed.&lt;/li&gt;
                            &lt;/ul&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
      </controls>
      <usecases>
        <usecase ref='POST SENSITIVE DATA' name='Post sensitive data' desc='' library=''>
          <threats>
            <threat ref='CAPEC-37-MOBILE' name='Sensitive data could be compromised through autocompletion' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker with permanent or temporary access to the users' mobile device could gain
                                access to sensitive data if the mobile application supports auto-completion of that
                                data.
                            </desc>
              <riskRating confidentiality='100' integrity='100' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-525-MOBILE'>
                  <controls>
                    <control ref='CWE-525-MOBILE' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='CWE-525-MOBILE' mitigation='100' />
              </controls>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </component>
    <component ref='MOBILE-CLIENT:SENS-DATA-RECEIVED' name='Mobile Client: Read sensitive data' desc='A mobile client that reads sensitive data from a service. This risk pattern is imported when we have a mobile device, and we don&apos;t know which operating system runs and the mobile app reads sensitive data. This is a common risk pattern for all types of operating systems.' groupName='' tags='' position='5' library='' diagramPositionX='0' diagramPositionY='0' componentDefinitionRef=''>
      <weaknesses>
          <weakness ref='MOB-INFO-LEAK' name='The application leaks sensitive information' state='0' impact='100'>
              <desc>Information leakage is an application weakness in which an application reveals sensitive data,
                  such as technical details of the web application, environment, or user-specific data. Sensitive
                  data may be used by an attacker to exploit the target web application, its hosting network, or
                  its users. Therefore, leakage of sensitive data should be limited or prevented whenever
                  possible. Information leakage, in its most common form, is the result of one or more of the
                  following conditions: A failure to scrub out HTML/Script comments containing sensitive
                  information, improper application or server configurations, or differences in page responses for
                  valid versus invalid data.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2018-05-29T09:15:59.473'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </weakness>
        <weakness ref='MOB-SECRET-STORED' name='API keys or secrets are stored on the device' state='0' impact='100'>
          <desc>API keys or global secrets stored on the device can be easily extracted by an attacker by
                        analyzing the application (reverse engineering).
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:59.413'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </weakness>
        <weakness ref='MOB-DATA' name='Data is stored into unprotected locations' state='0' impact='100'>
          <desc>When sensitive data is stored in unprotected locations, an attacker with access to the device
                        through physical access or a remote exploit, could gain access to it.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:59.423'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-524' name='Information Exposure Through Caching' state='0' impact='100'>
          <desc>The application uses a cache to maintain a pool of objects, threads, connections, pages, or
                        passwords to minimize the time it takes to access them or the resources to which they connect.
                        If implemented improperly, these caches can allow access to unauthorized information or cause a
                        denial of service vulnerability.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:59.448'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-524: Information Exposure Through Caching' url='https://cwe.mitre.org/data/definitions/524.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-226' name='Sensitive information is not cleared from memory' state='0' impact='100'>
          <desc>The software does not fully clear previously used information in a data structure, file, or
                        other resource, before making that resource available to a party in another control sphere.

                        This typically results from new data that is not as long as the old data, which leaves portions
                        of the old data still available. Equivalent errors can occur in other situations where the
                        length of data is variable but the associated data structure is not. If memory is not cleared
                        after use, it may allow unintended actors to read the data when the memory is reallocated.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:15:59.461'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-226: Sensitive information is not cleared from memory' url='https://cwe.mitre.org/data/definitions/226.html' />
            </references>
            <udts />
          </test>
        </weakness>
      </weaknesses>
      <controls>
        <control ref='MOB-API-DYN' name='API keys, tokens, and secrets should be generated dynamically to prevent disclosure' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Data hard-coded into the application may be exposed before installation. For example, API
                        keys, cryptographic keys, or other secrets shipped in the application may be retrieved by a
                        malicious party through examining the installer or its contents.&amp;nbsp;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        To prevent interception or disclosure, API keys, tokens, and other secrets should be generated
                        dynamically. If the secrets have to be agreed before the application is even run, a trusted
                        credential interchange should happen on the first run. After the initial trusted credential
                        interchange on the first run, the secrets should be saved to the OS provided secure stores, for
                        example the iOS Keychain or Android Secure Preferences).
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Session Management' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x04e-Testing-Authentication-and-Session-Management.html#testing-stateful-session-management' />
          </references>
          <standards>
            <standard ref='4.2' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='4.2' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='4.2' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='4.2' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>&lt;ol&gt;
                            &lt;li&gt;Check the application source code and configuration files to look for hardcoded
                            secrets, API keys or similar.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Set up a proxy and proxy all application traffic through it.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Inspect the traffic for disclosure of secret keys.&lt;/li&gt;
                            &lt;/ol&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='CWE-524' name='Clear caches of sensitive data' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Applications storing or caching data locally are at risk of attack and compromise of that
                        data. Local temporary storage, thumbnail images, and configuration files often contain excerpts
                        of sensitive information that may be left on the device during or after the application is used.
                        &lt;div&gt;
                        &lt;ul&gt;
                        &lt;li&gt;Ensure all temporary files, caches, and storage are purged after use and when the
                        application is closed.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Do not allow the application to cache sensitive information outside of OS provided
                        secure stores.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Use OS controls to restrict thumbnails of the application where any sensitive
                        information is displayed&lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Whether the Keyboard Cache Is Disabled for Text Input Fields' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#determining-whether-the-keyboard-cache-is-disabled-for-text-input-fields' />
            <reference name='OWASP MASVS - iOS - Testing Whether the Keyboard Cache Is Disabled for Text Input Fields' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-for-sensitive-data-in-the-keyboard-cache' />
          </references>
          <standards>
            <standard ref='2.4' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='2.4' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='2.4' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.4' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>&lt;ol&gt;
                            &lt;li&gt;Check the application for the use of caches.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Verify they are periodically emptied.&lt;/li&gt;
                            &lt;/ol&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MOB-LOG-BACK' name='Do not allow sensitive data to be written to log files or thumbnail/background images' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Applications storing or caching data locally are at risk of attack and compromise of that
                        data. Local temporary storage, thumbnail images, and configuration files often contain excerpts
                        of sensitive information that may be left on the device during or after the application is used.
                        Sensitive data should not be logged by the application.
                        Where the data is relevant from a support perspective, it should be masked or otherwise
                        obfuscated, in accordance with industry or legislative requirements where appropriate (e.g. PAN
                        masking dictated by the PCI DSS standards).
                        Use OS controls to restrict thumbnails of the application where any sensitive information is
                        displayed.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing for Sensitive Information in Auto-Generated Screenshots' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#finding-sensitive-information-in-auto-generated-screenshots' />
            <reference name='OWASP MASVS - iOS - Testing for Sensitive Information in Auto-Generated Screenshots' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-for-sensitive-information-in-auto-generated-screenshots' />
          </references>
          <standards>
            <standard ref='2.9' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.9' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>&lt;ol&gt;
                            &lt;li&gt;Browse the application focusing on the sections which handle sensitive data.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Obtain the log files from the device and check there is no sensitive data on them.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;For background images, force the application to go to the background and
                            foreground several times whilst managing sensitive information.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Look for the screenshots within the mobile file system and check if the screenshot
                            contains sensitive information. If so, the test should fail.&lt;/li&gt;
                            &lt;/ol&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='CWE-226' name='Overwrite data in memory before release' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Memory chunks released by an application are not actively overwritten, they are simply
                        de-referenced with the data left until the memory is reallocated and used by another process. As
                        such, sensitive data that is stored in memory may be exposed to an attacker with the ability to
                        inspect that memory; for example through use of an uninitialized variable or other process.&amp;nbsp;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        Overwrite memory with zeros or random data before release.&amp;nbsp;
                        &lt;/div&gt;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        Pay particular attention to sensitive data, such as passwords or other credentials, or sensitive
                        personal information.
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing for Sensitive Data in Memory' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#checking-memory-for-sensitive-data' />
            <reference name='OWASP MASVS - iOS - Testing for Sensitive Data in Memory' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-for-sensitive-data-in-memory' />
          </references>
          <standards>
            <standard ref='2.10' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.10' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>&lt;ol&gt;
                            &lt;li&gt;Identify the parts of the code that handles authentication and very sensitive data
                            (i.e. credit card data).&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Verify that the buffers holding that data are overwritten with zeros and freed as
                            soon as they are not needed anymore.&lt;/li&gt;
                            &lt;/ol&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MOB-DATA' name='Store sensitive data only in protected locations' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Applications storing or caching data locally are at risk of attack and compromise of that
                        data. Most mobile devices and operating systems offer built in API's to store data in their
                        encrypted stores, such as the Keychain on iOS. Data stored in shared memory, such as a removable
                        SD card, may be accessed by other applications on the device, or may be removed and accessed in
                        a third party system.&amp;nbsp;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        Do not store sensitive or private data on shared or removable storage, such as SD cards. Where
                        data is stored on shared but non removable storage, there is still a risk an attacker with
                        physical access may be able to access the device storage and therefore the data.&amp;nbsp;
                        &lt;/div&gt;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        Use OS provided secure storage for sensitive or private data.
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references />
          <standards />
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>&lt;ol&gt;
                            &lt;li&gt;Identify in which points the component is processing sensitive data.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Check for the sensitiveness of this data.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Check if this data is being stored at some point. This data should be kept to the
                            minimum set of data possible for the application to run appropriately and should be stored
                            on OS provided secure-means (i.e. iOS keychain).&lt;/li&gt;
                            &lt;/ol&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
      </controls>
      <usecases>
        <usecase ref='READ SENSITIVE DATA' name='Read sensitive data' desc='' library=''>
          <threats>
            <threat ref='CAPEC-204' name='Sensitive data is retrieved from the mobile device by an attacker' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker with access to the mobile device could inspect the cache to find sensitive
                                data.

                                Many applications that communicate with remote entities or which perform intensive
                                calculations utilize caches to improve efficiency. However, if the application computes
                                or receives sensitive information and the cache is not appropriately protected, an
                                attacker can browse the cache and retrieve this information. This can result in the
                                disclosure of sensitive information.

                                iOS in particular caches the active screen when an app is put into the background. This
                                screenshots is then stored on the file system.
                            </desc>
              <riskRating confidentiality='50' integrity='50' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='MOB-SECRET-STORED'>
                  <controls>
                    <control ref='MOB-API-DYN' mitigation='20' />
                  </controls>
                </weakness>
                <weakness ref='MOB-DATA'>
                  <controls>
                    <control ref='MOB-DATA' mitigation='20' />
                  </controls>
                </weakness>
                <weakness ref='CWE-524'>
                  <controls>
                    <control ref='CWE-524' mitigation='20' />
                  </controls>
                </weakness>
                <weakness ref='CWE-226'>
                  <controls>
                    <control ref='CWE-226' mitigation='20' />
                  </controls>
                </weakness>
                <weakness ref='MOB-INFO-LEAK'>
                  <controls>
                    <control ref='MOB-LOG-BACK' mitigation='20' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='CWE-226' mitigation='20' />
                <control ref='CWE-524' mitigation='20' />
                <control ref='MOB-API-DYN' mitigation='20' />
                <control ref='MOB-DATA' mitigation='20' />
                <control ref='MOB-LOG-BACK' mitigation='20' />
              </controls>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </component>
      <component ref='MOBILE-CLIENT:SENS-DATA' name='Mobile Client: Sensitive data'
                 desc='This risk pattern is imported when we have a mobile device, and we don&apos;t know which operating system runs and the mobile app uses sensitive data (all processes with sensitive data, i.e. read, post). This is a common risk pattern for all types of operating systems.'
                 groupName='' tags='' position='6' library='' diagramPositionX='0' diagramPositionY='0'
                 componentDefinitionRef=''>
      <weaknesses>
        <weakness ref='CWE-319' name='Cleartext Transmission of Sensitive Information' state='0' impact='100'>
          <desc>The software transmits sensitive or security-critical data in cleartext in a communication
                        channel that can be sniffed by unauthorized actors.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:00.898'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-319: Cleartext Transmission of Sensitive Information' url='https://cwe.mitre.org/data/definitions/319.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-937' name='Components, libraries, modules, frameworks, platform, and operating systems contain known security weaknesses' state='0' impact='100'>
          <desc>In theory, it ought to be easy to figure out if you are currently using any vulnerable
                        components or libraries. Unfortunately, vulnerability reports for commercial or open source
                        software do not always specify exactly which versions of a component are vulnerable in a
                        standard, searchable way. Further, not all libraries use an understandable version numbering
                        system. Worst of all, not all vulnerabilities are reported to a central clearing house that is
                        easy to search, although sites like CVE and NVD are becoming easier to search.

                        Determining if you are vulnerable requires searching these databases, as well as keeping abreast
                        of project mailing lists and announcements for anything that might be a vulnerability. If one of
                        your components does have a vulnerability, you should carefully evaluate whether you are
                        actually vulnerable by checking to see if your code uses the part of the component with the
                        vulnerability and whether the flaw could result in an impact you care about.

                        Component vulnerabilities can cause almost any type of risk imaginable, ranging from the trivial
                        to sophisticated malware designed to target a specific organization. Components almost always
                        run with the full privilege of the application, so flaws in any component can be serious.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:01.013'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-937: Components, libraries, modules, frameworks, platform, and operating systems contain known security weaknesses' url='https://cwe.mitre.org/data/definitions/937.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-250' name='Execution with Unnecessary Privileges' state='0' impact='100'>
          <desc>The software performs an operation at a privilege level that is higher than the minimum level
                        required, which creates new weaknesses or amplifies the consequences of other weaknesses.

                        New weaknesses can be exposed because running with extra privileges, such as root or
                        Administrator, can disable the normal security checks being performed by the operating system or
                        surrounding environment. Other pre-existing weaknesses can turn into security vulnerabilities if
                        they occur while operating at raised privileges. Privilege management functions can behave in
                        some less-than-obvious ways, and they have different quirks on different platforms. These
                        inconsistencies are particularly pronounced if you are transitioning from one non-root user to
                        another. Signal handlers and spawned processes run at the privilege of the owning process, so if
                        a process is running as root when a signal fires or a sub-process is executed, the signal
                        handler or sub-process will operate with root privileges.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:00.986'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-250: Execution with Unnecessary Privileges' url='https://cwe.mitre.org/data/definitions/250.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-530' name='Exposure of Backup File to an Unauthorized Control Sphere' state='0' impact='100'>
          <desc>A backup file is stored in a directory that is accessible to actors outside of the intended
                        control sphere.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:01.143'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-530: Exposure of Backup File to an Unauthorized Control Sphere' url='https://cwe.mitre.org/data/definitions/530.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-287' name='Improper Authentication' state='0' impact='100'>
          <desc>When an actor claims to have a given identity, the software does not prove or insufficiently
                        proves that the claim is correct.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:00.947'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-287: Improper Authentication' url='https://cwe.mitre.org/data/definitions/287.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-295' name='Improper Certificate Validation' state='0' impact='100'>
          <desc>The software does not validate, or incorrectly validates, a certificate.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:00.912'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-295: Improper Certificate Validation' url='https://cwe.mitre.org/data/definitions/295.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-326' name='Inadequate Encryption Strength' state='0' impact='100'>
          <desc>The software stores or transmits sensitive data using an encryption scheme that is
                        theoretically sound, but is not strong enough for the level of protection required.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:01.128'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-326: Inadequate Encryption Strength' url='https://cwe.mitre.org/data/definitions/326.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-200' name='Information Exposure' state='0' impact='100'>
          <desc>An information exposure is the intentional or unintentional disclosure of information to an
                        actor that is not explicitly authorized to have access to that information.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:00.999'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-200: Information Exposure' url='https://cwe.mitre.org/data/definitions/200.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-524' name='Information Exposure Through Caching' state='0' impact='100'>
          <desc>The application uses a cache to maintain a pool of objects, threads, connections, pages, or
                        passwords to minimize the time it takes to access them or the resources to which they connect.
                        If implemented improperly, these caches can allow access to unauthorized information or cause a
                        denial of service vulnerability.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:01.028'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-524: Information Exposure Through Caching' url='https://cwe.mitre.org/data/definitions/524.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-613' name='Insufficient Session Expiration' state='0' impact='100'>
          <desc>According to WASC, "Insufficient Session Expiration is when a web site permits an attacker to
                        reuse old session credentials or session IDs for authorization."
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:00.932'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-613: Insufficient Session Expiration' url='https://cwe.mitre.org/data/definitions/613.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-295-AUTH' name='Lack of TLS certificate validation' state='0' impact='100'>
          <desc>The software transmits sensitive or security-critical data in cleartext in a communication
                        channel that can be sniffed by unauthorized actors.
                        Many communication channels can be "sniffed" by attackers during data transmission. For example,
                        network traffic can often be sniffed by any attacker who has access to a network interface. This
                        significantly lowers the difficulty of exploitation by attackers.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:01.063'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-295: Lack of TLS certificate validation' url='https://cwe.mitre.org/data/definitions/295.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-329' name='Not Using a Random IV with CBC Mode' state='0' impact='100'>
          <desc>Not using a random initialization Vector (IV) with Cipher Block Chaining (CBC) Mode causes
                        algorithms to be susceptible to dictionary attacks.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:01.077'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-329: Not Using a Random IV with CBC Mode' url='https://cwe.mitre.org/data/definitions/329.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-323' name='Reusing a Nonce, Key Pair in Encryption' state='0' impact='100'>
          <desc>Nonces should be used for the present occasion and only once.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:01.159'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-323: Reusing a Nonce, Key Pair in Encryption' url='https://cwe.mitre.org/data/definitions/323.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-255' name='The application does not wipe used and not needed passwords or key material' state='0' impact='100'>
          <desc>When using password or key material within an application, these are copied in memory and can
                        be copied back to the disk depending on several factors.

                        If the application handles passwords or key material, an attacker with access to the system
                        could inspect the memory or the hard disk to retrieve back those secrets in their original form.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:00.972'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-255: The application does not wipe used and not needed passwords or key material' url='https://cwe.mitre.org/data/definitions/255.html' />
            </references>
            <udts />
          </test>
        </weakness>
          <weakness ref='MOB-INFO-LEAK' name='The application leaks sensitive information' state='0' impact='100'>
          <desc>Information leakage is an application weakness in which an application reveals sensitive data,
                        such as technical details of the web application, environment, or user-specific data. Sensitive
                        data may be used by an attacker to exploit the target web application, its hosting network, or
                        its users. Therefore, leakage of sensitive data should be limited or prevented whenever
                        possible. Information leakage, in its most common form, is the result of one or more of the
                        following conditions: A failure to scrub out HTML/Script comments containing sensitive
                        information, improper application or server configurations, or differences in page responses for
                        valid versus invalid data.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:01.051'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-327' name='Use of a Broken or Risky Cryptographic Algorithm' state='0' impact='100'>
          <desc>The use of a broken or risky cryptographic algorithm is an unnecessary risk that may result in
                        the exposure of sensitive information.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:01.113'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-327: Use of a Broken or Risky Cryptographic Algorithm' url='https://cwe.mitre.org/data/definitions/327.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-321' name='Use of Hard-coded Cryptographic Key' state='0' impact='100'>
          <desc>The use of a hard-coded cryptographic key significantly increases the possibility that
                        encrypted data may be recovered.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:01.175'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-321: Use of Hard-coded Cryptographic Key' url='https://cwe.mitre.org/data/definitions/321.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-330' name='Use of Insufficiently Random Values' state='0' impact='100'>
          <desc>The software may use insufficiently random numbers or values in a security context that
                        depends on unpredictable numbers.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:01.092'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-330: Use of Insufficiently Random Values' url='https://cwe.mitre.org/data/definitions/330.html' />
            </references>
            <udts />
          </test>
        </weakness>
        <weakness ref='CWE-308' name='Use of Single-factor Authentication' state='0' impact='100'>
          <desc>The use of single-factor authentication can lead to unnecessary risk of compromise when
                        compared with the benefits of a dual-factor authentication scheme.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:00.884'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-308: Use of Single-factor Authentication' url='https://cwe.mitre.org/data/definitions/308.html' />
            </references>
            <udts />
          </test>
        </weakness>
      </weaknesses>
      <controls>
        <control ref='MASVS-3.6' name='All random values are generated using a sufficiently secure random number generator' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Mobile SDKs offer standard implementations of RNG algorithms that produce numbers with
                        sufficient artificial randomness. We'll introduce the available APIs in the Android and iOS
                        specific sections.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Random Number Generation' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05e-Testing-Cryptography.html#testing-random-number-generation' />
            <reference name='OWASP MASVS - iOS - Testing Random Number Generation' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06e-Testing-Cryptography.html#random-number-generation-on-ios' />
          </references>
          <standards>
            <standard ref='3.6' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='3.6' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='3.6' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='3.6' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check if the random keys are generated with a sufficiently secure random number
                            generator.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-4.9' name='Apply a step-up authentication for Transaction Signing with Push Notifications and PKI' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Transaction signing requires authentication of the user's approval of critical transactions.
                        Asymmetric cryptography is the best way to implement transaction signing. The app will generate
                        a public/private key pair when the user signs up, then registers the public key on the back end.
                        The private key is securely stored in the device keystore.&amp;nbsp;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        To authorize a transaction, the back end sends the mobile app a push notification containing the
                        transaction data. The user is then asked to confirm or deny the transaction. After confirmation,
                        the user is prompted to unlock the Keychain (by entering the PIN or fingerprint), and the data
                        is signed with user's private key. The signed transaction is then sent to the server, which
                        verifies the signature with the user's public key.
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Testing Step-up Authentication' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x04e-Testing-Authentication-and-Session-Management.html#transaction-signing-with-push-notifications-and-pki' />
          </references>
          <standards>
            <standard ref='4.9' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='4.9' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that when transaction information is accessed, a second step-up authentication is
                            shown and is used to authenticate for access to the transaction data.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
          <control ref='MASVS-2.11'
                   name='Create the functionality to verify the app uses a minimum device-access-security policy'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Different checks on the Android device can be implemented by querying different system preferences
                  from Settings.Secure. The Device Administration API offers different mechanisms to create security
                  aware applications, that are able to enforce password policies or encryption of the device.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing the Device-Access-Security Policy'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#testing-the-device-access-security-policy'/>
                  <reference name='OWASP MASVS - iOS - Testing the Device-Access-Security Policy'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-the-device-access-security-policy'/>
              </references>
              <standards>
                  <standard ref='2.11' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='2.11' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check that the app verifies the mobile device complies with the minimum
                      device-access-security policy.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
        <control ref='MASVS-1.11' name='Create the mechanisms to control the lifecycle of cryptographic keys' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Create the mechanisms to control the lifecycle of the cryptographic keys as it's shown in the
                        key management standard as NIST SP 800-57. In this standard the usage period is determined as
                        follows:
                        &lt;div&gt;
                        &lt;ul&gt;
                        &lt;li&gt;Originator Usage Period (OUP)&amp;nbsp;&lt;/li&gt;
                        &lt;ul&gt;
                        &lt;li&gt;Private Signature Key: 1-3 years&lt;/li&gt;
                        &lt;li&gt;Public Signature Key: Several years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric Authentication Key: &amp;lt;= 2 years&lt;/li&gt;
                        &lt;li&gt;Private Authentication Key: 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Public Authentication Key: 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric Data Encryption Key: &amp;lt;= 2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric Key Wrapping Key: &amp;lt;= 2 years&lt;/li&gt;
                        &lt;li&gt;Symmetric RBG keys: Determined by design&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric Master Key: About 1 year&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Private Key Transport Key: &amp;lt;= 2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Public Key Transport Key: 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric Key Agreement Key 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Private Static Key Agreement Key: 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Public Static Key Agreement Key: 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Private Ephemeral Key Agreement Key: One key agreement transaction&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Public Ephemeral Key Agreement Key: One key agreement transaction&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric Authorization Key: &amp;lt;= 2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Private Authorization Key: &amp;lt;= 2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Public Authorization Key: &amp;lt;= 2 years&lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;/ul&gt;
                        &lt;ul&gt;
                        &lt;li&gt;Recipient Usage Period&lt;/li&gt;
                        &lt;ul&gt;
                        &lt;li&gt;Private Signature Key:&amp;nbsp; -&lt;/li&gt;
                        &lt;li&gt;Public Signature Key: Several years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric Authentication Key: &amp;lt;= OUP + 3 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Private Authentication Key: 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Public Authentication Key: 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric Data Encryption Key: &amp;lt;= OUP + 3 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric Key Wrapping Key: &amp;lt;= OUP + 3 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric RBG keys: -&lt;/li&gt;
                        &lt;li&gt;Symmetric Master Key: -&lt;/li&gt;
                        &lt;li&gt;Private Key Transport Key: &amp;lt;= 2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Public Key Transport Key: 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric Key Agreement Key 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Private Static Key Agreement Key: 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Public Static Key Agreement Key: 1-2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Private Ephemeral Key Agreement Key: One key agreement transaction&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Public Ephemeral Key Agreement Key: One key agreement transaction&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Symmetric Authorization Key: &amp;lt;= 2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Private Authorization Key: &amp;lt;= 2 years&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Public Authorization Key: &amp;lt;= 2 years&lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;/ul&gt;
                        &lt;ul&gt;
                        &lt;/ul&gt;
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='Cryptographic Key Length Recommendation' url='https://www.keylength.com/en/4/' />
          </references>
          <standards>
            <standard ref='1.11' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='1.11' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Verify if lifecycle of cryptographic key checks are done.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-2.12' name='Create warnings to educate personnel' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Create warning notifications to educate personnel who work with personally identifiable
                        information. These warnings are shown to the users when they use the app for first time.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Verifying User Education Controls' url='https://b-mueller.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#verifying-user-education-controls' />
          </references>
          <standards>
            <standard ref='6.10' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='6.10' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check when users access sensitive data, the app shows them security notifications with
                            tips on how to protect their personal data.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-2.8' name='Disable auto-backup for sensitive data' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>The auto backup attribute is enabled by default, this attribute shall be disabled for the
                        following cases:
                        Sensitive information should not be sent in clear text to the cloud.
                        Either, avoid storing the information in the first place, or encrypt the information at rest,
                        before sending it to the cloud.
                        Files can also be excluded from Auto Backup, in case they should not be shared in the Cloud.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing for Sensitive Data in Backups' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#finding-sensitive-information-in-auto-generated-screenshots' />
            <reference name='OWASP MASVS - iOS - Testing for Sensitive Data in Backups' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-for-sensitive-information-in-auto-generated-screenshots' />
          </references>
          <standards>
            <standard ref='2.8' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.8' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that sensitive data is not saved into a backup by the Auto-Backup functionality.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-2.5' name='Disable the clipboard for sensitive data' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
            <desc>A general best practice is overwriting different functions in the input field to disable the clipboard
                specifically for it. Also longclickable should be deactivated for the input field.
            </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing for Sensitive Data in the Clipboard' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#determining-whether-sensitive-stored-data-has-been-exposed-via-ipc-mechanisms' />
            <reference name='OWASP MASVS - iOS - Testing for Sensitive Data in the Clipboard' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-for-sensitive-data-in-the-clipboard' />
          </references>
          <standards>
            <standard ref='2.5' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='2.5' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='2.5' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.5' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check the clipboard is disabled when sensitive data is used.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-3.1' name='Do not hard-code encryption keys when using symmetric encryption' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>The security of symmetric encryption and keyed hashes (MACs) depends on the secrecy of the
                        key. If the key is disclosed, the security gained by encryption is lost. To prevent this, never
                        store secret keys in the same place as the encrypted data they helped create. Developers often
                        make the mistake of encrypting locally stored data with a static, hard-coded encryption key and
                        compiling that key into the app. This makes the key accessible to anyone who can use a
                        disassembler. Ensure that no keys or passwords are stored within the source code.&amp;nbsp;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        Note that hard-coded keys are problematic even if the source code is obfuscated since
                        obfuscation is easily bypassed by dynamic instrumentation. If the app is using two-way SSL (both
                        server and client certificates are validated), make sure that:&amp;nbsp;
                        &lt;/div&gt;
                        &lt;div&gt;
                        &lt;ul&gt;
                        &lt;li&gt;The password to the client certificate isn't stored locally or is locked in the device
                        Keychain.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;The client certificate isn't shared among all installations.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;If the app relies on additional encrypted containers stored in app data, check how the
                        encryption key is used.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;If a key-wrapping scheme is used, ensure that the master secret is initialized for
                        each user or the container is re-encrypted with new key.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;If you can use the master secret or previous password to decrypt the container, check
                        how password changes are handled.&lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Verifying Key Management' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05e-Testing-Cryptography.html#testing-key-management' />
            <reference name='OWASP MASVS - iOS - Verifying Key Management' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06e-Testing-Cryptography.html#verifing-key-management' />
          </references>
          <standards>
            <standard ref='3.1' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='3.1' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='3.1' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='3.1' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check the symmetric encryption key is not stored locally with a static, hard-coded
                            encryption key and compiling that key into the app.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-3.5' name='Do not re-use the same cryptographic key for multiple purposes' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc></desc>
          <implementations />
          <references />
          <standards>
            <standard ref='3.5' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='3.5' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='3.5' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='3.5' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that the same cryptographic key is not used for several purposes.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-2.3' name='Do not share sensitive data with third parties unless it is a necessary part of the architecture' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Do not share sensitive data with third parties unless it is a necessary part of the
                        architecture, because sensitive data such as credentials or Personal Identifiable Information
                        can be intercepted in transport.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Whether Sensitive Data Is Sent To Third Parties' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#determining-whether-sensitive-data-is-sent-to-third-parties' />
            <reference name='OWASP MASVS - iOS - Testing Whether Sensitive Data Is Sent To Third Parties' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-whether-sensitive-data-is-sent-to-third-parties' />
          </references>
          <standards>
            <standard ref='2.3' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='2.3' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='2.3' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.3' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that sensitive data is not shared with third parties when this data is not a part
                            of the architecture.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-5.5' name='Ensure that each critical operation requires at least one additional channel (e.g., SMS, e-mail, or token)' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Identify all of the tested application's critical operations (e.g., user enrollment, account
                        recovery, and money transfer) and make sure that critical operations enforce the use of at least
                        one additional channel to confirm user actions. These channels must not be bypassed when
                        executing critical operations. The following are examples of additional verification channels:&amp;nbsp;
                        &lt;div&gt;
                        &lt;ul&gt;
                        &lt;li&gt;Token (e.g., RSA token, yubikey);&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Push notification (e.g., Google Prompt);&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;SMS;&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;E-mail;&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Data from another website you visited or scanned;&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Data from a physical letter or physical entry point (e.g., data you receive only after
                        signing a document at a bank).&amp;nbsp;&lt;/li&gt;
                        &lt;/ul&gt;If you're going to implement an additional factor to verify the user's identity,
                        consider Infobip 2FA library or one-time passcodes (OTP) via Google Authenticator.
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Verifying that Critical Operations Use Secure Communication Channels' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05g-Testing-Network-Communication.html#verifying-that-critical-operations-use-secure-communication-channels' />
            <reference name='OWASP MASVS - iOS - Verifying that Critical Operations Use Secure Communication Channels' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06g-Testing-Network-Communication.html#verifying-that-critical-operations-use-secure-communication-channels' />
          </references>
          <standards>
            <standard ref='5.5' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='5.5' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-3.3-KEY-LENGTH' name='Ensure the key length fulfills accepted industry standards' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Even the most secure encryption algorithm becomes vulnerable to brute-force attacks when that
                        algorithm uses an insufficient key size. Ensure the key length fulfills accepted industry
                        standards.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Verifying the Configuration of Cryptographic Standard Algorithms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05e-Testing-Cryptography.html#verifying-the-configuration-of-cryptographic-standard-algorithms' />
            <reference name='OWASP MASVS - iOS - Verifying the Configuration of Cryptographic Standard Algorithms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06e-Testing-Cryptography.html#verifying-the-configuration-of-cryptographic-standard-algorithms' />
          </references>
          <standards>
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check the key length is accepted by industry standards.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-3.4' name='Frequently review the used cryptographic protocols and controls to ensure they are not deprecated ' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Ensure the cryptographic protocols or algorithms used are widely considered suitable for
                        security purposes. Frequently review all cryptographic protocols and algorithms to verify they
                        are not deprecated.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing for Insecure and/or Deprecated Cryptographic Algorithms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05e-Testing-Cryptography.html#testing-for-insecure-andor-deprecated-cryptographic-algorithms' />
            <reference name='OWASP MASVS - iOS - Testing for Insecure and/or Deprecated Cryptographic Algorithms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06e-Testing-Cryptography.html#testing-for-insecure-andor-deprecated-cryptographic-primitives' />
          </references>
          <standards>
            <standard ref='3.4' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='3.4' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='3.4' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='3.4' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check the cryptographic protocols or algorithms used are not deprecated for security
                            purposes.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-4.6' name='Implement biometric authentication' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Implement biometric authentication that is not event-bound (i.e. using an API that simply
                        returns "true" or "false"). Instead, ensure it is based on unlocking the keychain/keystore and
                        does not provide information about the methods and processes of authentication.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Biometric Authentication' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05f-Testing-Local-Authentication.html#testing-biometric-authentication' />
            <reference name='OWASP MASVS - iOS - Testing Biometric Authentication' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06f-Testing-Local-Authentication.html#testing-local-authentication' />
          </references>
          <standards>
            <standard ref='4.6' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='4.6' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Test for Android Device:
                            &lt;div&gt;
                            &lt;ul&gt;
                            &lt;li&gt;Use runtime instrumentation to bypass fingerprint authentication on the client.
                            For example, use Frida to call the onAuthenticationSucceeded callback method directly.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Check that the external instrumentation cannot bypass the authentication method.&amp;nbsp;&lt;/li&gt;
                            &lt;/ul&gt;Test for iOS Device:&amp;nbsp;
                            &lt;/div&gt;
                            &lt;div&gt;
                            &lt;ul&gt;
                            &lt;li&gt;On a jailbroken device tools like Swizzler2 can be used to bypass
                            LocalAuthentication.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Swizzler uses Frida to instrument the evaluatePolicy function so that it returns
                            True even if authentication was not successfully performed.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Install Swizzler2 and follow the steps below to activate this feature:&amp;nbsp;&lt;/li&gt;
                            &lt;ul&gt;
                            &lt;li&gt;Settings-&amp;gt;Swizzler&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Enable &amp;quot;Inject Swizzler into Apps&amp;quot;&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Enable &amp;quot;Log Everything to Syslog&amp;quot;&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Enable &amp;quot;Log Everything to File&amp;quot;&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Enter the submenu &amp;quot;iOS Frameworks&amp;quot;&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Enable &amp;quot;LocalAuthentication&amp;quot;&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Enter the submenu &amp;quot;Select Target Apps&amp;quot;&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Enable the target app&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Close the app and start it again&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;When the TouchID prompt shows click &amp;quot;cancel&amp;quot;&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;If the application flow continues without requiring the touchID then the bypass
                            has worked.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Alternatively, you can use objection to bypass TouchID (this also works on a
                            non-jailbroken device), patch the app, or use Cycript or similar tools to instrument the
                            process.&lt;/li&gt;
                            &lt;/ul&gt;
                            &lt;/ul&gt;
                            &lt;/div&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-5.4' name='Implement Certificate pinning' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Certificate pinning is the process of associating the backend server with a particular X509
                        certificate or public key, instead of accepting any certificate signed by a trusted certificate
                        authority. A mobile app that stores (&amp;quot;pins&amp;quot;) the server certificate or public
                        key will subsequently only establish connections to the known server. Verify that the server
                        certificate is pinned. Pinning can be implemented in multiple ways:&amp;nbsp;
                        &lt;div&gt;
                        &lt;ul&gt;
                        &lt;li&gt;Including server's certificate in the application bundle and performing verification
                        on each connection. This requires an update mechanism whenever the certificate on the server is
                        updated Limiting certificate issuer to e.g. one entity and bundling the intermediate CA's public
                        key into the application. In this way we limit the attack surface and have a valid certificate.&amp;nbsp;&lt;/li&gt;
                        &lt;li&gt;Owning and managing your own PKI. The application would contain the intermediate CA's
                        public key. This avoids updating the application every time you change the certificate on the
                        server, due to e.g. expiration.&amp;nbsp;&lt;/li&gt;
                        &lt;/ul&gt;Note that using your own CA would cause the certificate to be self-singed.
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Custom Certificate Stores and SSL Pinning' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05g-Testing-Network-Communication.html#testing-custom-certificate-stores-and-certificate-pinning' />
            <reference name='OWASP MASVS - iOS - Testing Custom Certificate Stores and SSL Pinning' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06g-Testing-Network-Communication.html#testing-custom-certificate-stores-and-certificate-pinning' />
          </references>
          <standards>
            <standard ref='5.4' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='5.4' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that the Certificate pinning is implemented correctly.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-4.7' name='Implement functionality to terminate the session at the remote endpoint after a predefined period of inactivity' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>In most popular frameworks, you can set the session timeout via configuration options. This
                        parameter should be set according to the best practices specified in the framework
                        documentation. The recommended timeout may be between 10 minutes and two hours, depending on the
                        app's sensitivity.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Testing the Session Timeout' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x04e-Testing-Authentication-and-Session-Management.html#session-timeout' />
          </references>
          <standards>
            <standard ref='4.7' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='4.7' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Verify that sessions are terminated at the remote endpoint after a predefined period of
                            inactivity.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-6.10' name='Implement root detection notification to inform the user about the threats of this action' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
            <desc>Implement root detection functionality within the Android app, libraries can be used like RootBeer.
                The root detection should either trigger a warning to the user after start, to remind him that the
                device is rooted and that the user can only proceed at his own risk. Alternatively, the app can
                terminate itself in case a rooted environment is detected. This decision is dependent on the business
                requirements and the risk appetite of the stakeholders.
            </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Root Detection' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-root-detection' />
            <reference name='OWASP MASVS - iOS - Testing Jailbreak Detection' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#jailbreak-detection' />
          </references>
          <standards>
            <standard ref='6.10' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='6.10' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>&lt;ol&gt;
                            &lt;li&gt;Open the app on a rooted device.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Check the app immediately terminates the session.&lt;/li&gt;
                            &lt;/ol&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
          <control ref='MASVS-8.1' name='Implement two or more independent functionallies for root detection'
                   platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Implement two or more independent methods to detect rooted devices and if the device is rooted, the
                  app shall respond in two ways:&amp;nbsp;
                  &lt;div&gt;
                  &lt;ul&gt;
                  &lt;li&gt;The app notifies the user that their device is rooted and it's not secure to continue with
                  the app.&amp;nbsp;&lt;/li&gt;
                  &lt;li&gt;Terminate the session and the app, because sensitive data is vulnerable.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/div&gt;
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing Advanced Root Detection'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05j-Testing-Resiliency-Against-Reverse-Engineering.html#testing-root-detection'/>
                  <reference name='OWASP MASVS - iOS - Testing Advanced Root Detection'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html#jailbreak-detection'/>
              </references>
              <standards>
                  <standard ref='8.1' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='8.1' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>&lt;ul&gt;
                      &lt;li&gt;Check that the app has two or more functionalities with independent methods to
                      detect a rooted device.&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Check that if the device is rooted, the user is alerted or the app is terminated.&lt;/li&gt;
                      &lt;/ul&gt;
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
        <control ref='MASVS-2.7' name='Mask sensitive data when the data is shown in the app' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
            <desc>Many apps require users to enter several kinds of data to, for example, register an account or make a
                payment. Sensitive data may be exposed if the app doesn't properly mask it, when displaying data in
                clear text. Masking of sensitive data, by showing asterisk or dots instead of clear text should be
                enforced within an app's activity to prevent disclosure and mitigate risks such as shoulder surfing.
            </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing for Sensitive Data Disclosure Through the User Interface' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#checking-for-sensitive-data-disclosure-through-the-user-interface' />
            <reference name='OWASP MASVS - iOS - Testing for Sensitive Data Disclosure Through the User Interface' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-for-sensitive-data-disclosure-through-the-user-interface' />
          </references>
          <standards>
            <standard ref='2.7' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='2.7' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='2.7' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.7' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check that when you introduce sensitive data into the app such as passwords or PIN, this
                            information is masked.
            </steps>
              <notes/>
              <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                      timestamp='2016-08-02T10:21:32.718'>
                  <output></output>
              </source>
              <references/>
              <udts/>
          </test>
        </control>
          <control ref='CWE-250-MOBILE'
                   name='Request only the minimum required permissions from the mobile operating system' platform=''
                   cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>Security best practice dictates the practice of least-privilege is followed, thereby reducing the
                  attack surface and risk of compromise. By limiting the access an application has to the system,
                  developers may reduce the impact a compromise may have.&amp;nbsp;
                  &lt;div&gt;
                  &lt;br /&gt;
                  &lt;/div&gt;
                  &lt;div&gt;
                  Request only the minimum required permissions from the mobile operating system. For example, if there
                  is no requirement to use the camera then the application should not request this permission.
                  &lt;/div&gt;
                  &lt;div&gt;
                  &lt;br /&gt;
                  &lt;/div&gt;
                  &lt;div&gt;
                  Review features and functionality present in the application, in particular legacy features, to
                  determine if they are relevant and required, and if not remove them and associated OS permissions.
                  &lt;/div&gt;
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing App Permissions'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05h-Testing-Platform-Interaction.html#testing-app-permissions'/>
                  <reference name='OWASP MASVS - iOS - Testing App Permissions'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06h-Testing-Platform-Interaction.html#testing-app-permissions'/>
              </references>
              <standards>
                  <standard ref='6.1' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='6.1' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='6.1' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='6.1' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>For Android applications:&amp;nbsp;
                      &lt;div&gt;
                      &lt;ol&gt;
                      &lt;li&gt;Install the application and review the permissions the application is asking for.&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Check they are actually needed.&lt;/li&gt;
                      &lt;/ol&gt;For iOS applications:&amp;nbsp;
                      &lt;/div&gt;
                      &lt;div&gt;
                      &lt;ol&gt;
                      &lt;li&gt;Install the application and use its main functionality, iOS will ask for the
                      permission when it is needed.&amp;nbsp;&lt;/li&gt;
                      &lt;li&gt;Verify those permissions requests are in accordance with the minimum set of
                      permissions needed by the application.&lt;/li&gt;
                      &lt;/ol&gt;
                      &lt;/div&gt;
                  </steps>
                  <notes />
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references />
                  <udts />
              </test>
          </control>
        <control ref='MASVS-3.3-KEY-AES' name='Use other block modes rather than ECB mode for AES encryption' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>Advanced Encryption Standard (AES) is the widely accepted standard for symmetric encryption in
                        mobile apps. It's an iterative block cipher that is based on a series of linked mathematical
                        operations. AES performs a variable number of rounds on the input, each of which involve
                        substitution and permutation of the bytes in the input block. Each round uses a 128-bit round
                        key which is derived from the original AES key. As of this writing, no efficient cryptanalytic
                        attacks against AES have been discovered. However, implementation details and configurable
                        parameters such as the block cipher mode leave some margin for error.&amp;nbsp;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        You shall configure AES encryption with Cipher Block Chaining (CBC) mode instead of ECB mode.
                        &lt;/div&gt;
                        &lt;div&gt;
                        &lt;br /&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                        In CBC mode, plaintext blocks are XORed with the previous ciphertext block. This ensures each
                        encrypted block is unique and randomized even if blocks contain the same information. When
                        storing encrypted data, we recommend using a block mode that also protects the integrity of the
                        stored data, such as Galois/Counter Mode (GCM). The latter has the additional benefit that the
                        algorithm is mandatory for each TLSv1.2 implementation, and thus is available on all modern
                        platforms.
                        &lt;/div&gt;
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Verifying the Configuration of Cryptographic Standard Algorithms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05e-Testing-Cryptography.html#verifying-the-configuration-of-cryptographic-standard-algorithms' />
            <reference name='OWASP MASVS - iOS - Verifying the Configuration of Cryptographic Standard Algorithms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06e-Testing-Cryptography.html#verifying-the-configuration-of-cryptographic-standard-algorithms' />
          </references>
          <standards>
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>If AES encryption is used, verify it's not configured with ECB mode.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-3.2' name='Use proven implementations of cryptographic primitives' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>It's recommended to use well-known algorithms that are widely regarded as secure. Mobile
                        operating systems offer standard cryptographic APIs that implement those algorithms.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing for Custom Implementations of Cryptography' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05e-Testing-Cryptography.html#testing-for-custom-implementations-of-cryptography' />
            <reference name='OWASP MASVS - iOS - Testing for Custom Implementations of Cryptography' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06e-Testing-Cryptography.html#testing-for-custom-implementations-of-cryptography' />
          </references>
          <standards>
            <standard ref='3.2' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='3.2' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='3.2' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='3.2' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Carefully inspect all the cryptographic methods used within the source code, especially
                            those that are directly applied to sensitive data. All cryptographic operations should use
                            standard cryptographic APIs for Android and iOS.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='MASVS-3.3-RANDOM-KEY' name='Use Random IV with CBC Mode' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>CBC mode requires the first plaintext block to be combined with an initialization vector (IV).
                        The IV doesn't have to be kept secret, but it shouldn't be predictable. Make sure that IVs are
                        generated using a cryptographically-secure random number generator. For more information on IVs,
                        see Crypto Fail's initialization vectors article.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Verifying the Configuration of Cryptographic Standard Algorithms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05e-Testing-Cryptography.html#verifying-the-configuration-of-cryptographic-standard-algorithms' />
            <reference name='OWASP MASVS - iOS - Verifying the Configuration of Cryptographic Standard Algorithms' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06e-Testing-Cryptography.html#verifying-the-configuration-of-cryptographic-standard-algorithms' />
          </references>
          <standards>
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='3.3' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>Check the app is using the Random IV with CBC mode to generate a cryptographically-secure
                            random number.
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='CWE-295-MOBILE' name='Validate that the certificate presented by the server is signed by a trusted Certificate Authority' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
          <desc>The client should verify that the TLS certificate presented by the server has been signed by a
                        recognized certificate authority and that the information in the certificate is valid.
                    </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing Endpoint Identify Verification' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05g-Testing-Network-Communication.html#testing-endpoint-identify-verification' />
            <reference name='OWASP MASVS - iOS - Testing Endpoint Identify Verification' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06g-Testing-Network-Communication.html#app-transport-security' />
          </references>
          <standards>
            <standard ref='5.3' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='5.3' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='5.3' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='5.3' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>For every starting connection the client does to a TLS enabled end-point the certificate
                            must be verified. This verification includes:&amp;nbsp;
                            &lt;div&gt;
                            &lt;ul&gt;
                            &lt;li&gt;in first place to check the certificate is valid, it is neither expired nor
                            revoked, the private key used is of a reasonable length, the signature algorithm is of a
                            reasonable strength and the Distinguished Name matches with the one of the server we are
                            connecting to.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Verification also includes checking the certificate against the certificate chain.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Also verify that the certificate chain is trusted against a local copy of the
                            Certificate Authority certificate, in which we have set up the trust.&amp;nbsp;&lt;/li&gt;
                            &lt;/ul&gt;For Android, we shall review the code and search how it has used the methods of
                            TrustManager and HostnameVerifier.
                            &lt;/div&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
      </controls>
      <usecases>
        <usecase ref='ACCESS SENSITIVE DATA' name='Access sensitive data' desc='' library=''>
          <threats>
            <threat ref='CAPEC-459' name='An attacker exploits a weakness in order to generate a certificate signing request' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker exploits a weakness in the MD5 hash algorithm (weak collision resistance)
                                to generate a certificate signing request (CSR) that contains collision blocks in the
                                &amp;quot;to be signed&amp;quot; part. The attacker specially crafts two different, but
                                valid X.509 certificates that when hashed with the MD5 algorithm would yield the same
                                value. The attacker then sends the CSR for one of the certificates to the Certification
                                Authority which uses the MD5 hashing algorithm. That request is completely valid and the
                                Certificate Authority issues an X.509 certificate to the attacker which is signed with
                                its private key. An attacker then takes that signed blob and inserts it into another
                                X.509 certificate that the attacker generated.&amp;nbsp;
                                &lt;div&gt;
                                &lt;br /&gt;
                                &lt;/div&gt;
                                &lt;div&gt;
                                Due to the MD5 collision, both certificates, though different, hash to the same value
                                and so the signed blob works just as well in the second certificate. The net effect is
                                that the attackers' second X.509 certificate, which the Certification Authority has
                                never seen, is now signed and validated by that Certification Authority. To make the
                                attack more interesting, the second certificate could be not just a regular certificate,
                                but rather itself a signing certificate. Thus the attacker is able to start their own
                                Certification Authority that is anchored in its root of trust in the legitimate
                                Certification Authority that has signed the attackers' first X.509 certificate. If the
                                original Certificate Authority was accepted by default by browsers, so will now the
                                Certificate Authority set up by the attacker and of course any certificates that it
                                signs. So the attacker is now able to generate any SSL certificates to impersonate any
                                web server, and the user's browser will not issue any warning to the victim. This can be
                                used to compromise HTTPS communications and other types of systems where PKI and X.509
                                certificates may be used (e.g., VPN, IPSec) -
                                &lt;/div&gt;
                            </desc>
              <riskRating confidentiality='100' integrity='100' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-295'>
                  <controls>
                    <control ref='MASVS-5.4' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-5.4' mitigation='100' />
              </controls>
            </threat>
            <threat ref='CAPEC-158-SESSION' name='User data or credentials are compromised through network sniffing or man-in-the-middle attacks' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker with access to the network path between the victim and the server could
                                employ a sniffer to observe clear text traffic on the network. If the session ID is
                                transmitted in clear text, then the attacker could compromise it and thereby gain access
                                to the user's session.
                            </desc>
              <riskRating confidentiality='50' integrity='50' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-319'>
                  <controls>
                    <control ref='MASVS-5.5' mitigation='100' />
                  </controls>
                </weakness>
                <weakness ref='CWE-308'>
                  <controls>
                    <control ref='MASVS-5.5' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-5.5' mitigation='100' />
              </controls>
            </threat>
          </threats>
        </usecase>
        <usecase ref='AUTHENTICATION' name='Authentication' desc='' library=''>
          <threats>
            <threat ref='CAPEC-474' name='An attacker obtains an authoritative or reputable signer&apos;s private signature key by theft ' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker obtains an authoritative or reputable signer's private signature key by
                                theft and then uses this key to forge signatures from the original signer to mislead a
                                victim into performing actions that benefit the attacker.
                            </desc>
              <riskRating confidentiality='75' integrity='75' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-255'>
                  <controls>
                    <control ref='MASVS-1.11' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-1.11' mitigation='100' />
              </controls>
            </threat>
            <threat ref='CAPEC-21' name='Attackers bypass authentication implemented on the client side' state='Expose' source='MANUAL' owner='' library=''>
              <desc>If a predictable token is used to authorize requests to read or post data, or if the
                                token can easily be compromised, then an attacker could use this token to impersonate
                                the user.

                                In mobile applications, using seemingly unique values such as the IMEI or UDID numbers
                                to authorize users can be abused since any application on the device can read these
                                values.
                            </desc>
              <riskRating confidentiality='75' integrity='75' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-287'>
                  <controls>
                    <control ref='MASVS-4.6' mitigation='50' />
                    <control ref='MASVS-4.9' mitigation='50' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-4.6' mitigation='50' />
                <control ref='MASVS-4.9' mitigation='50' />
              </controls>
            </threat>
            <threat ref='CSD-SESSION-ID' name='Attackers gain access to critical functions by compromising the session ID' state='Expose' source='MANUAL' owner='' library=''>
              <desc>If a session ID is leaked through a flaw in the application, then attackers could
                                perform sensitive operations or hijack the session of the affected user. This type of
                                attack does not usually result in mass-compromise of ID's.
                            </desc>
              <riskRating confidentiality='100' integrity='100' availability='25' easeOfExploitation='75' />
              <references />
              <weaknesses>
                <weakness ref='CWE-613'>
                  <controls>
                    <control ref='MASVS-4.7' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-4.7' mitigation='100' />
              </controls>
            </threat>
          </threats>
        </usecase>
        <usecase ref='GENERAL' name='General' desc='' library=''>
          <threats>
            <threat ref='CAPEC-117' name='An attacker monitors data streams to or from a target in order to gather information' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker monitors data streams to or from a target in order to gather information.
                                This attack may be undertaken in order to gather information to support a later attack,
                                or the data collected may be the end goal of the attack. This attack usually involves
                                sniffing network traffic, but may include observing other types of data streams, such as
                                radio. In most varieties of this attack, the attacker is passive and simply observes
                                regular communication, however in some variants the attacker may attempt to initiate the
                                establishment of a data stream or influence the nature of the data transmitted. However,
                                in all variants of this attack, and distinguishing this attack from other data
                                collection methods, the attacker is not the intended recipient of the data stream.
                                Unlike some other data leakage attacks, the attacker is observing explicit data channels
                                (e.g. network traffic) and reading the content. This differs from attacks that collect
                                more qualitative information, such as communication volume, or other information not
                                explicitly communicated via a data stream.
                            </desc>
              <riskRating confidentiality='50' integrity='50' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-200'>
                  <controls>
                    <control ref='MASVS-2.12' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-2.12' mitigation='100' />
              </controls>
            </threat>
            <threat ref='CAPEC-122-MOBILE' name='Users lose trust in the application because it requests unnecessary privileges' state='Expose' source='MANUAL' owner='' library=''>
              <desc>If the mobile application requests permissions or access to components that are not
                                strictly needed by the application, then users can lose trust in the security of the
                                application with an associated impact on the trust placed in the application provider.
                            </desc>
              <riskRating confidentiality='50' integrity='50' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-250'>
                  <controls>
                      <control ref='CWE-250-MOBILE' mitigation='25'/>
                      <control ref='MASVS-2.11' mitigation='25'/>
                      <control ref='MASVS-6.10' mitigation='25'/>
                      <control ref='MASVS-8.1' mitigation='25'/>
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                  <control ref='CWE-250-MOBILE' mitigation='25'/>
                  <control ref='MASVS-2.11' mitigation='25'/>
                  <control ref='MASVS-6.10' mitigation='25'/>
                  <control ref='MASVS-8.1' mitigation='25'/>
              </controls>
            </threat>
          </threats>
        </usecase>
        <usecase ref='READ SENSITIVE DATA' name='Read sensitive data' desc='' library=''>
          <threats>
            <threat ref='CWE-937' name='Attackers gain unauthorised access to data or services by exploiting known weaknesses in components, libraries, modules, frameworks, platform and operating systems' state='Expose' source='MANUAL' owner='' library=''>
              <desc>Application components, libraries, modules, frameworks, platform, and operating
                                systems could suffer from known vulnerabilities. There is a high risk that an attacker
                                could easily gain access to the underlying systems or data by exploiting these
                                vulnerabilities.

                                In some cases, public exploits exist, making the exploitation process even easier.
                            </desc>
              <riskRating confidentiality='75' integrity='75' availability='50' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-937'>
                  <controls>
                    <control ref='MASVS-2.3' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-2.3' mitigation='100' />
              </controls>
            </threat>
          </threats>
        </usecase>
        <usecase ref='SENSITIVE READ OR POST DATA' name='Sensitive Read or Post data' desc='' library=''>
          <threats>
            <threat ref='CAPEC-167' name='An attacker discovers the structure, function, and composition of a type of computer software through white box analysis techniques' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker discovers the structure, function, and composition of a type of computer
                                software through white box analysis techniques. White box techniques involve methods
                                which can be applied to a piece of software when an executable or some other compiled
                                object can be directly subjected to analysis, revealing at least a portion of its
                                machine instructions that can be observed upon execution.
                            </desc>
              <riskRating confidentiality='75' integrity='75' availability='50' easeOfExploitation='25' />
              <references />
              <weaknesses>
                <weakness ref='CWE-530'>
                  <controls>
                    <control ref='MASVS-2.8' mitigation='33' />
                  </controls>
                </weakness>
                <weakness ref='CWE-323'>
                  <controls>
                    <control ref='MASVS-3.5' mitigation='33' />
                  </controls>
                </weakness>
                <weakness ref='CWE-321'>
                  <controls>
                    <control ref='MASVS-3.1' mitigation='34' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-2.8' mitigation='33' />
                <control ref='MASVS-3.1' mitigation='34' />
                <control ref='MASVS-3.5' mitigation='33' />
              </controls>
            </threat>
              <threat ref='CAPEC-204'
                      name='An attacker examines a target application&apos;s cache for sensitive information'
                      state='Expose' source='MANUAL' owner='' library=''>
                  <desc>An attacker examines a target application's cache for sensitive information. Many
                      applications that communicate with remote entities or which perform intensive
                      calculations utilize caches to improve efficiency. However, if the application computes
                      or receives sensitive information and the cache is not appropriately protected, an
                      attacker can browse the cache and retrieve this information. This can result in the
                      disclosure of sensitive information.
                  </desc>
                  <riskRating confidentiality='50' integrity='50' availability='100' easeOfExploitation='100'/>
                  <references/>
                  <weaknesses>
                      <weakness ref='CWE-524'>
                          <controls>
                              <control ref='MASVS-2.7' mitigation='50'/>
                          </controls>
                      </weakness>
                      <weakness ref='MOB-INFO-LEAK'>
                          <controls>
                              <control ref='MASVS-2.5' mitigation='50'/>
                          </controls>
                      </weakness>
                  </weaknesses>
                  <controls>
                      <control ref='MASVS-2.5' mitigation='50'/>
                      <control ref='MASVS-2.7' mitigation='50'/>
                  </controls>
              </threat>
            <threat ref='CAPEC-97' name='An attacker leverages Cryptanalysis to gain access to sensitive data' state='Expose' source='MANUAL' owner='' library=''>
              <desc>Cryptanalysis is the process of finding weaknesses in cryptographic algorithms and
                                using these weaknesses to decipher the ciphertext without knowing the secret key
                                (instance deduction). Sometimes the weakness is not in the cryptographic algorithm
                                itself, but rather in how it is applied that makes cryptanalysis successful. An attacker
                                may have other goals as well, such as:
                                The goal of the attacker performing cryptanalysis will depend on the specific needs of
                                the attacker in a given attack context. In most cases, if cryptanalysis is successful at
                                all, an attacker will not be able to go past being able to deduce some information about
                                the plaintext (goal 3). However, that may be sufficient for an attacker, depending on
                                the context.
                            </desc>
              <riskRating confidentiality='100' integrity='100' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-327'>
                  <controls>
                    <control ref='MASVS-3.2' mitigation='33' />
                    <control ref='MASVS-3.3-KEY-AES' mitigation='34' />
                    <control ref='MASVS-3.4' mitigation='33' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-3.2' mitigation='33' />
                <control ref='MASVS-3.3-KEY-AES' mitigation='34' />
                <control ref='MASVS-3.4' mitigation='33' />
              </controls>
            </threat>
            <threat ref='CAPEC-485' name='An attacker obtains an authoritative signer&apos;s private signature key by exploiting a cryptographic weaknesses' state='Expose' source='MANUAL' owner='' library=''>
              <desc>An attacker obtains an authoritative or reputable signer's private signature key by
                                exploiting a cryptographic weakness in the signature algorithm or pseudorandom number
                                generation and then uses this key to forge signatures from the original signer to
                                mislead a victim into performing actions which benefit the attacker.
                            </desc>
              <riskRating confidentiality='75' integrity='75' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-329'>
                  <controls>
                    <control ref='MASVS-3.3-RANDOM-KEY' mitigation='50' />
                  </controls>
                </weakness>
                <weakness ref='CWE-330'>
                  <controls>
                    <control ref='MASVS-3.6' mitigation='50' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-3.3-RANDOM-KEY' mitigation='50' />
                <control ref='MASVS-3.6' mitigation='50' />
              </controls>
            </threat>
            <threat ref='CAPEC-112' name='An attacker uses Brute Force to gain access to sensitive data' state='Expose' source='MANUAL' owner='' library=''>
              <desc>In this attack, some asset (information, functionality, identity, etc.) is protected
                                by a finite secret value. The attacker attempts to gain access to this asset by using
                                trial-and-error to exhaustively explore all the possible secret values in the hope of
                                finding the secret (or a value that is functionally equivalent) that will unlock the
                                asset. Examples of secrets can include, but are not limited to, passwords, encryption
                                keys, database lookup keys, and initial values to one-way functions.
                                The key factor in this attack is the attackers' ability to explore the possible secret
                                space rapidly. This, in turn, is a function of the size of the secret space and the
                                computational power the attacker is able to bring to bear on the problem. If the
                                attacker has modest resources and the secret space is large, the challenge facing the
                                attacker is intractable. While the defender cannot control the resources available to an
                                attacker, they can control the size of the secret space. Creating a large secret space
                                involves selecting one's secret from as large a field of equally likely alternative
                                secrets as possible and ensuring that an attacker is unable to reduce the size of this
                                field using available clues or cryptanalysis. Doing this is more difficult than it
                                sounds since elimination of patterns (which, in turn, would provide an attacker clues
                                that would help them reduce the space of potential secrets) is difficult to do using
                                deterministic machines, such as computers. Assuming a finite secret space, a brute force
                                attack will eventually succeed. The defender must rely on making sure that the time and
                                resources necessary to do so will exceed the value of the information. For example, a
                                secret space that will likely take hundreds of years to explore is likely safe from
                                raw-brute force attacks.
                            </desc>
              <riskRating confidentiality='75' integrity='75' availability='100' easeOfExploitation='100' />
              <references />
              <weaknesses>
                <weakness ref='CWE-326'>
                  <controls>
                    <control ref='MASVS-3.3-KEY-LENGTH' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='MASVS-3.3-KEY-LENGTH' mitigation='100' />
              </controls>
            </threat>
            <threat ref='NTW-MITM' name='Attackers could gain access to sensitive data through a man-in-the-middle attack' state='Expose' source='MANUAL' owner='' library=''>
              <desc>Sensitive data transmission that it is not properly protected could allow an attacker
                                to eavesdrop on this data.
                            </desc>
              <riskRating confidentiality='100' integrity='100' availability='100' easeOfExploitation='50' />
              <references />
              <weaknesses>
                <weakness ref='CWE-295-AUTH'>
                  <controls>
                    <control ref='CWE-295-MOBILE' mitigation='100' />
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                <control ref='CWE-295-MOBILE' mitigation='100' />
              </controls>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </component>
      <component ref='MOBILE-CLIENT:SENS-DATA-STORAGE' name='Mobile Client: Store Sensitive data'
                 desc='This risk pattern is imported when we have a mobile device, and we don&apos;t know which operating system runs and the mobile app uses sensitive data (all processes with sensitive data, i.e. store). This is a common risk pattern for all types of operating systems.'
                 groupName='' tags='' position='7' library='' diagramPositionX='0' diagramPositionY='0'
                 componentDefinitionRef=''>
      <weaknesses>
        <weakness ref='CWE-312' name='Cleartext Storage of Sensitive Information' state='0' impact='100'>
          <desc>The application stores sensitive information in cleartext within a resource that might be
                        accessible to another control sphere.

                        Because the information is stored in cleartext, attackers could potentially read it. Even if the
                        information is encoded in a way that is not human-readable, certain techniques could determine
                        which encoding is being used, then decode the information.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:03.539'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-312: Cleartext Storage of Sensitive Information' url='https://cwe.mitre.org/data/definitions/312.html' />
            </references>
              <udts/>
          </test>
        </weakness>
          <weakness ref='CWE-530' name='Exposure of Backup File to an Unauthorized Control Sphere' state='0'
                    impact='100'>
              <desc>A backup file is stored in a directory that is accessible to actors outside of the intended
                  control sphere.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2019-04-25T15:57:24.719'>
                      <output/>
                  </source>
                  <references>
                      <reference name='CWE-530: Exposure of Backup File to an Unauthorized Control Sphere'
                                 url='https://cwe.mitre.org/data/definitions/530.html'/>
                  </references>
                  <udts/>
              </test>
          </weakness>
          <weakness ref='CWE-323' name='Reusing a Nonce, Key Pair in Encryption' state='0' impact='100'>
              <desc>Nonces should be used for the present occasion and only once.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2019-04-25T15:57:22.519'>
                      <output/>
                  </source>
                  <references>
                      <reference name='CWE-323: Reusing a Nonce, Key Pair in Encryption'
                                 url='https://cwe.mitre.org/data/definitions/323.html'/>
                  </references>
                  <udts />
              </test>
          </weakness>
        <weakness ref='CWE-921' name='Storage of Sensitive Data in a Mechanism without Access Control' state='0' impact='100'>
          <desc>The software stores sensitive information in a file system or device that does not have
                        built-in access control.

                        While many modern file systems or devices utilize some form of access control in order to
                        restrict access to data, not all storage mechanisms have this capability. For example, memory
                        cards, floppy disks, CDs, and USB devices are typically made accessible to any user within the
                        system. This can become a problem when sensitive data is stored in these mechanisms in a
                        multi-user environment, because anybody on the system can read or write this data. On Android
                        devices, external storage is typically globally readable and writable by other applications on
                        the device. External storage may also be easily accessible through the mobile device's USB
                        connection or physically accessible through the device's memory card port.
                    </desc>
          <test expiryDate='' expiryPeriod='0'>
            <steps />
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2018-05-29T09:16:03.557'>
              <output></output>
            </source>
            <references>
              <reference name='CWE-921: Storage of Sensitive Data in a Mechanism without Access Control' url='https://cwe.mitre.org/data/definitions/921.html' />
            </references>
            <udts />
          </test>
        </weakness>
          <weakness ref='CWE-321' name='Use of Hard-coded Cryptographic Key' state='0' impact='100'>
              <desc>The use of a hard-coded cryptographic key significantly increases the possibility that
                  encrypted data may be recovered.
              </desc>
              <test expiryDate='' expiryPeriod='0'>
                  <steps/>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2019-04-25T15:57:20.233'>
                      <output/>
                  </source>
                  <references>
                      <reference name='CWE-321: Use of Hard-coded Cryptographic Key'
                                 url='https://cwe.mitre.org/data/definitions/321.html'/>
                  </references>
                  <udts/>
              </test>
          </weakness>
      </weaknesses>
      <controls>
        <control ref='CWE-921' name='Avoid storing sensitive data in shared memory such as the SD card' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
            <desc>Applications storing or caching data locally are at risk of attack and compromise of that data. Most
                mobile devices and operating systems offer built in API's to store data in their encrypted stores, such
                as the Keychain on iOS.&amp;nbsp;
                &lt;div&gt;
                &lt;ul&gt;
                &lt;li&gt;Data stored in shared memory, such as a removable SD card, may be accessed by other
                applications on the device, or may be removed and accessed in a third party system.&amp;nbsp;&lt;/li&gt;
                &lt;li&gt;Do not store sensitive or private data on shared or removable storage, such as SD cards. Where
                data is stored on shared but non removable storage, there is still a risk an attacker with physical
                access may be able to access the device storage and therefore the data.&amp;nbsp;&lt;/li&gt;
                &lt;li&gt;Use OS provided secure storage for sensitive or private data.&lt;/li&gt;
                &lt;/ul&gt;
                &lt;/div&gt;
            </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing For Sensitive Data in Local Data Storage' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#testing-for-sensitive-data-in-local-storage' />
            <reference name='OWASP MASVS - iOS - Testing For Sensitive Data in Local Data Storage' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-for-sensitive-data-disclosure-in-local-storage' />
          </references>
          <standards>
            <standard ref='2.1' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='2.1' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='2.1' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.1' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>&lt;ol&gt;
                            &lt;li&gt;Identify in which points the component is processing sensitive data.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Verify that this data is not stored on the SD card. This data should be kept to
                            the minimum possible for the application to run appropriately and should be stored on OS
                            provided secure-means (i.e. iOS keychain).&lt;/li&gt;
                            &lt;/ol&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
          <control ref='MASVS-2.8' name='Disable auto-backup for sensitive data' platform='' cost='1' risk='0'
                   state='Recommended' owner='' library='' source='MANUAL'>
              <desc>The auto backup attribute is enabled by default, this attribute shall be disabled for the following
                  cases: Sensitive information should not be sent in clear text to the cloud. Either, avoid storing the
                  information in the first place, or encrypt the information at rest, before sending it to the cloud.
                  Files can also be excluded from Auto Backup, in case they should not be shared in the Cloud.
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Testing for Sensitive Data in Backups'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#finding-sensitive-information-in-auto-generated-screenshots'/>
                  <reference name='OWASP MASVS - iOS - Testing for Sensitive Data in Backups'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-for-sensitive-information-in-auto-generated-screenshots'/>
              </references>
              <standards>
                  <standard ref='2.8' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='2.8' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check that sensitive data is not saved into a backup by the Auto-Backup functionality.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-3.1' name='Do not hard-code encryption keys when using symmetric encryption' platform=''
                   cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc>The security of symmetric encryption and keyed hashes (MACs) depends on the secrecy of the key. If
                  the key is disclosed, the security gained by encryption is lost. To prevent this, never store secret
                  keys in the same place as the encrypted data they helped create. Developers often make the mistake of
                  encrypting locally stored data with a static, hard-coded encryption key and compiling that key into
                  the app. This makes the key accessible to anyone who can use a disassembler. Ensure that no keys or
                  passwords are stored within the source code.&amp;nbsp;
                  &lt;div&gt;
                  &lt;br /&gt;
                  &lt;/div&gt;
                  &lt;div&gt;
                  Note that hard-coded keys are problematic even if the source code is obfuscated since obfuscation is
                  easily bypassed by dynamic instrumentation. If the app is using two-way SSL (both server and client
                  certificates are validated), make sure that:&amp;nbsp;
                  &lt;/div&gt;
                  &lt;div&gt;
                  &lt;ul&gt;
                  &lt;li&gt;The password to the client certificate isn't stored locally or is locked in the device
                  Keychain.&amp;nbsp;&lt;/li&gt;
                  &lt;li&gt;The client certificate isn't shared among all installations.&amp;nbsp;&lt;/li&gt;
                  &lt;li&gt;If the app relies on additional encrypted containers stored in app data, check how the
                  encryption key is used.&amp;nbsp;&lt;/li&gt;
                  &lt;li&gt;If a key-wrapping scheme is used, ensure that the master secret is initialized for each user
                  or the container is re-encrypted with new key.&amp;nbsp;&lt;/li&gt;
                  &lt;li&gt;If you can use the master secret or previous password to decrypt the container, check how
                  password changes are handled.&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;/div&gt;
              </desc>
              <implementations/>
              <references>
                  <reference name='OWASP MASVS - Android - Verifying Key Management'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05e-Testing-Cryptography.html#testing-key-management'/>
                  <reference name='OWASP MASVS - iOS - Verifying Key Management'
                             url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06e-Testing-Cryptography.html#verifing-key-management'/>
              </references>
              <standards>
                  <standard ref='3.1' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='3.1' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='3.1' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='3.1' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check the symmetric encryption key is not stored locally with a static, hard-coded
                      encryption key and compiling that key into the app.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
          <control ref='MASVS-3.5' name='Do not re-use the same cryptographic key for multiple purposes' platform=''
                   cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
              <desc></desc>
              <implementations/>
              <references/>
              <standards>
                  <standard ref='3.5' supportedStandardRef='OWASP-MASVS-L1'/>
                  <standard ref='3.5' supportedStandardRef='OWASP-MASVS-L1+R'/>
                  <standard ref='3.5' supportedStandardRef='OWASP-MASVS-L2'/>
                  <standard ref='3.5' supportedStandardRef='OWASP-MASVS-L2+R'/>
              </standards>
              <udts/>
              <test expiryDate='' expiryPeriod='0'>
                  <steps>Check that the same cryptographic key is not used for several purposes.
                  </steps>
                  <notes/>
                  <source filename='' args='' type='Manual' result='Not Tested' enabled='true'
                          timestamp='2016-08-02T10:21:32.718'>
                      <output></output>
                  </source>
                  <references/>
                  <udts/>
              </test>
          </control>
        <control ref='CWE-921-LOGS-MOBILE' name='Ensure sensitive data is not written to log files on the mobile device' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
            <desc>Applications are commonly built with detailed logging enabled, in particular debug logs during
                development. These logs are often accessible to processes and users outside of the application's trust
                model, and as such it is important that sensitive data is not included in the logs. Sensitive data
                should not be logged by the application. Where the data is relevant from a support perspective, it
                should be masked or otherwise obfuscated, in accordance with industry or legislative requirements where
                appropriate (e.g. PAN masking dictated by the PCI DSS standards).
            </desc>
          <implementations />
          <references>
            <reference name='OWASP MASVS - Android - Testing For Sensitive Data in Logs' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x05d-Testing-Data-Storage.html#testing-for-sensitive-data-in-logs' />
            <reference name='OWASP MASVS - iOS - Testing For Sensitive Data in Logs' url='https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06d-Testing-Data-Storage.html#testing-for-sensitive-data-in-logs' />
          </references>
          <standards>
            <standard ref='2.2' supportedStandardRef='OWASP-MASVS-L1' />
            <standard ref='2.2' supportedStandardRef='OWASP-MASVS-L1+R' />
            <standard ref='2.2' supportedStandardRef='OWASP-MASVS-L2' />
            <standard ref='2.2' supportedStandardRef='OWASP-MASVS-L2+R' />
          </standards>
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>&lt;ol&gt;
                            &lt;li&gt;Run the application and perform the most common user journeys.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Inspect the logging information on the mobile device and verify there is no
                            sensitive data. This can be achieved using the adb (logcat subcommand) tool on Android or
                            XCode on iOS.&lt;/li&gt;
                            &lt;/ol&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
        <control ref='CWE-312-ENCRYPT' name='Store sensitive data in a cryptographically secure (system provided) store' platform='' cost='1' risk='0' state='Recommended' owner='' library='' source='MANUAL'>
            <desc>Applications storing or caching data locally are at risk of attack and compromise of that data. Most
                mobile devices and operating systems offer built in API's to store data in their encrypted stores, such
                as the Keychain on iOS. These stores are ultimately encrypted using a key derived from the device
                passcode and require the user to set a passcode.&amp;nbsp;
                &lt;div&gt;
                &lt;br /&gt;
                &lt;/div&gt;
                &lt;div&gt;
                However, they do not enforce the quality of the passcode, nor is it possible to determine the quality of
                the passcode (and therefore, ultimately the key) from within the application.&amp;nbsp;
                &lt;/div&gt;
                &lt;div&gt;
                &lt;ul&gt;
                &lt;li&gt;Data should not be stored locally unless there is an explicit requirement to do so. This
                includes restricting thumbnails or screenshots of pages in the application that contain private data.&amp;nbsp;&lt;/li&gt;
                &lt;li&gt;Data that must be stored on the client side must be held in a cryptographically secure store.&amp;nbsp;&lt;/li&gt;
                &lt;li&gt;Use OS provided stores to protect private data on the client side, acknowledging that the
                residual risk from users with weak passwords may affect that data.&amp;nbsp;&lt;/li&gt;
                &lt;li&gt;Do not store highly sensitive/financial data on the client-side without implementing a
                provably strong cryptographic process. For example, it should be encrypted using a key derived from an
                independent password where the strength of this password can be verified.&lt;/li&gt;
                &lt;/ul&gt;
                &lt;/div&gt;
            </desc>
          <implementations />
          <references />
          <standards />
          <udts />
          <test expiryDate='' expiryPeriod='0'>
            <steps>&lt;ol&gt;
                            &lt;li&gt;Identify in which points the component is storing sensitive data.&amp;nbsp;&lt;/li&gt;
                            &lt;li&gt;Check the storage routines and verify they are using OS APIs which are built on
                            top of secure storage components.&lt;/li&gt;
                            &lt;/ol&gt;
                        </steps>
            <notes />
            <source filename='' args='' type='Manual' result='Not Tested' enabled='true' timestamp='2016-08-02T10:21:32.718'>
              <output></output>
            </source>
            <references />
            <udts />
          </test>
        </control>
      </controls>
      <usecases>
        <usecase ref='SENSITIVE READ OR POST DATA' name='Sensitive Read or Post data' desc='' library=''>
          <threats>
              <threat ref='CAPEC-167'
                      name='An attacker discovers the structure, function, and composition of a type of computer software through white box analysis techniques'
                      state='Expose' source='MANUAL' owner='' library=''>
                  <desc>An attacker could retrieve sensitive data stored on a mobile device. This information may be
                      stored in configuration files, embedded within the application itself, or stored in other ways.
                      Sensitive information may include long-term keys, passwords, credit card or financial information,
                      and other private material that the mobile app uses in its interactions with the server. In some
                      cases, it may not even be necessary to gain access to another user's installation - if all
                      instances of the client software are embedded with the same sensitive information (for example,
                      long term keys for communication with the server) then the attacker must simply find a way to gain
                      their own copy of the client software in order to perform this attack.
                  </desc>
              <riskRating confidentiality='75' integrity='75' availability='50' easeOfExploitation='25' />
              <references />
              <weaknesses>
                <weakness ref='CWE-312'>
                  <controls>
                      <control ref='CWE-312-ENCRYPT' mitigation='17'/>
                  </controls>
                </weakness>
                  <weakness ref='CWE-530'>
                      <controls>
                          <control ref='MASVS-2.8' mitigation='17'/>
                      </controls>
                  </weakness>
                  <weakness ref='CWE-323'>
                      <controls>
                          <control ref='MASVS-3.5' mitigation='17'/>
                  </controls>
                </weakness>
                <weakness ref='CWE-921'>
                  <controls>
                      <control ref='CWE-921' mitigation='16'/>
                      <control ref='CWE-921-LOGS-MOBILE' mitigation='16'/>
                  </controls>
                </weakness>
                  <weakness ref='CWE-321'>
                      <controls>
                          <control ref='MASVS-3.1' mitigation='17'/>
                  </controls>
                </weakness>
              </weaknesses>
              <controls>
                  <control ref='CWE-312-ENCRYPT' mitigation='17'/>
                  <control ref='CWE-921' mitigation='16'/>
                  <control ref='CWE-921-LOGS-MOBILE' mitigation='16'/>
                  <control ref='MASVS-2.8' mitigation='17'/>
                  <control ref='MASVS-3.1' mitigation='17'/>
                  <control ref='MASVS-3.5' mitigation='17'/>
              </controls>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </component>
  </components><rules>
  <rule name='Q: Mobile OS - Mobile Device Client' module='component' generatedByGui='true'>
    <condition name='Risk pattern exists' type='drools-without-variable-type' field='id' value='OWASP MASVS v1.0_::_MOBILE-CLIENT'>
      <pattern name='Risk pattern exists' pattern='$riskPattern : ImportWholeRiskPatternAwareDto(libraryRef == "${value-1}",riskPatternRef == "${value-2}");' />
    </condition>
      <action project=''
              value='mobile.os_::_Mobile OS_::_Which mobile operating system will be used?_::_6051_::_true_::_false_::_'
              name='Insert Question Group' type='drools-without-variable-type'>
      <pattern name='Action of insert question group' pattern='QuestionGroup group = new QuestionGroup("${value-1}","${value-2}","${value-3}", ${value-4}, "${value-7}"); group.setFlags(${value-5}, ${value-6}); insertLogical(group);' />
    </action>
    <content />
  </rule>
  <rule name='Q: Mobile OS - Mobile Device Client - *' module='component' generatedByGui='true'>
    <condition name='Question Group exists' type='drools-without-variable-type' field='id' value='mobile.os'>
      <pattern name='Question group exists' pattern='$group : QuestionGroup(id == "${value}") @Watch(!*);' />
    </condition>
    <action project='' value='mobile.android_::_Android_::_' name='Insert Question' type='drools-without-variable-type'>
      <pattern name='Action of insert question' pattern='insertLogical(new Question($group, "${value-1}", "${value-2}", "${value-3}"));' />
    </action>
    <action project='' value='mobile.iOS_::_iOS_::_' name='Insert Question' type='drools-without-variable-type'>
      <pattern name='Action of insert question' pattern='insertLogical(new Question($group, "${value-1}", "${value-2}", "${value-3}"));' />
    </action>
    <action project='' value='mobile.windows_::_Windows Mobile_::_' name='Insert Question' type='drools-without-variable-type'>
      <pattern name='Action of insert question' pattern='insertLogical(new Question($group, "${value-1}", "${value-2}", "${value-3}"));' />
    </action>
    <content />
  </rule>
  <rule name='Risk Pattern: Assets - Mobile Device - Android - Sens Data Processed' module='component' generatedByGui='true'>
    <condition name='Conclusion exists' type='drools-without-variable-type' field='id' value='sensitiveDataProcessed'>
      <pattern name='Conclusion exists' pattern='Conclusion(id == "${value}");' />
    </condition>
    <condition name='Risk pattern exists' type='drools-without-variable-type' field='id' value='OWASP MASVS v1.0_::_ANDROID-CLIENT'>
      <pattern name='Risk pattern exists' pattern='$riskPattern : ImportWholeRiskPatternAwareDto(libraryRef == "${value-1}",riskPatternRef == "${value-2}");' />
    </condition>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_ANDROID-CLIENT: SENS-DATA'
              name='Extend risk pattern' type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
    <content />
  </rule>
  <rule name='Risk Pattern: Assets - Mobile Device - Android - Sens Data Received' module='component' generatedByGui='true'>
    <condition name='Conclusion exists' type='drools-without-variable-type' field='id' value='sensitiveDataReceived'>
      <pattern name='Conclusion exists' pattern='Conclusion(id == "${value}");' />
    </condition>
    <condition name='Risk pattern exists' type='drools-without-variable-type' field='id' value='OWASP MASVS v1.0_::_ANDROID-CLIENT'>
      <pattern name='Risk pattern exists' pattern='$riskPattern : ImportWholeRiskPatternAwareDto(libraryRef == "${value-1}",riskPatternRef == "${value-2}");' />
    </condition>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_ANDROID-CLIENT: SENS-DATA'
              name='Extend risk pattern' type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
    <content />
  </rule>
  <rule name='Risk Pattern: Assets - Mobile Device - Android - Sens Data Sent' module='component' generatedByGui='true'>
    <condition name='Conclusion exists' type='drools-without-variable-type' field='id' value='sensitiveDataTransmitted'>
      <pattern name='Conclusion exists' pattern='Conclusion(id == "${value}");' />
    </condition>
    <condition name='Risk pattern exists' type='drools-without-variable-type' field='id' value='OWASP MASVS v1.0_::_ANDROID-CLIENT'>
      <pattern name='Risk pattern exists' pattern='$riskPattern : ImportWholeRiskPatternAwareDto(libraryRef == "${value-1}",riskPatternRef == "${value-2}");' />
    </condition>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_ANDROID-CLIENT: SENS-DATA'
              name='Extend risk pattern' type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
    <content />
  </rule>
  <rule name='Risk Pattern: Assets - Mobile Device - Android - Sens Data Stored' module='component' generatedByGui='true'>
    <condition name='Conclusion exists' type='drools-without-variable-type' field='id' value='sensitiveDataStorage'>
      <pattern name='Conclusion exists' pattern='Conclusion(id == "${value}");' />
    </condition>
    <condition name='Risk pattern exists' type='drools-without-variable-type' field='id' value='OWASP MASVS v1.0_::_ANDROID-CLIENT'>
      <pattern name='Risk pattern exists' pattern='$riskPattern : ImportWholeRiskPatternAwareDto(libraryRef == "${value-1}",riskPatternRef == "${value-2}");' />
    </condition>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_ANDROID-CLIENT: SENS-DATA'
              name='Extend risk pattern' type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
    <content />
  </rule>
  <rule name='Risk Pattern: Assets - Mobile Device - Sens Data Processed' module='component' generatedByGui='true'>
    <condition name='Conclusion exists' type='drools-without-variable-type' field='id' value='sensitiveDataProcessed'>
      <pattern name='Conclusion exists' pattern='Conclusion(id == "${value}");' />
    </condition>
    <condition name='Risk pattern exists' type='drools-without-variable-type' field='id' value='OWASP MASVS v1.0_::_MOBILE-CLIENT'>
      <pattern name='Risk pattern exists' pattern='$riskPattern : ImportWholeRiskPatternAwareDto(libraryRef == "${value-1}",riskPatternRef == "${value-2}");' />
    </condition>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_MOBILE-CLIENT:SENS-DATA' name='Extend risk pattern'
              type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_MOBILE-CLIENT:SENS-DATA-RECEIVED'
              name='Extend risk pattern' type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_MOBILE-CLIENT:SENS-DATA-STORAGE'
              name='Extend risk pattern' type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_MOBILE-CLIENT:SENS-DATA-TRANSMIT'
              name='Extend risk pattern' type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
    <content />
  </rule>
  <rule name='Risk Pattern: Assets - Mobile Device - Sens Data Received' module='component' generatedByGui='true'>
    <condition name='Conclusion exists' type='drools-without-variable-type' field='id' value='sensitiveDataReceived'>
      <pattern name='Conclusion exists' pattern='Conclusion(id == "${value}");' />
    </condition>
    <condition name='Risk pattern exists' type='drools-without-variable-type' field='id' value='OWASP MASVS v1.0_::_MOBILE-CLIENT'>
      <pattern name='Risk pattern exists' pattern='$riskPattern : ImportWholeRiskPatternAwareDto(libraryRef == "${value-1}",riskPatternRef == "${value-2}");' />
    </condition>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_MOBILE-CLIENT:SENS-DATA' name='Extend risk pattern'
              type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_MOBILE-CLIENT:SENS-DATA-RECEIVED'
              name='Extend risk pattern' type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
    <content />
  </rule>
  <rule name='Risk Pattern: Assets - Mobile Device - Sens Data Sent' module='component' generatedByGui='true'>
    <condition name='Conclusion exists' type='drools-without-variable-type' field='id' value='sensitiveDataTransmitted'>
      <pattern name='Conclusion exists' pattern='Conclusion(id == "${value}");' />
    </condition>
    <condition name='Risk pattern exists' type='drools-without-variable-type' field='id' value='OWASP MASVS v1.0_::_MOBILE-CLIENT'>
      <pattern name='Risk pattern exists' pattern='$riskPattern : ImportWholeRiskPatternAwareDto(libraryRef == "${value-1}",riskPatternRef == "${value-2}");' />
    </condition>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_MOBILE-CLIENT:SENS-DATA' name='Extend risk pattern'
              type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_MOBILE-CLIENT:SENS-DATA-TRANSMIT'
              name='Extend risk pattern' type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
    <content />
  </rule>
  <rule name='Risk Pattern: Assets - Mobile Device - Sens Data Stored' module='component' generatedByGui='true'>
    <condition name='Conclusion exists' type='drools-without-variable-type' field='id' value='sensitiveDataStorage'>
      <pattern name='Conclusion exists' pattern='Conclusion(id == "${value}");' />
    </condition>
    <condition name='Risk pattern exists' type='drools-without-variable-type' field='id' value='OWASP MASVS v1.0_::_MOBILE-CLIENT'>
      <pattern name='Risk pattern exists' pattern='$riskPattern : ImportWholeRiskPatternAwareDto(libraryRef == "${value-1}",riskPatternRef == "${value-2}");' />
    </condition>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_MOBILE-CLIENT:SENS-DATA' name='Extend risk pattern'
              type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_MOBILE-CLIENT:SENS-DATA-STORAGE'
              name='Extend risk pattern' type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
    <content />
  </rule>
  <rule name='Risk Pattern: Mobile OS - Mobile Device Client - Android' module='component' generatedByGui='true'>
    <condition name='Question is answered' type='Question' field='id' value='mobile.android'>
      <pattern name='Condition with answer' pattern='${type}(${field} == "${value}", answer == true);' />
    </condition>
      <condition name='Risk pattern exists' type='drools-without-variable-type' field='id'
                 value='OWASP MASVS v1.0_::_MOBILE-CLIENT'>
          <pattern name='Risk pattern exists'
                   pattern='$riskPattern : ImportWholeRiskPatternAwareDto(libraryRef == "${value-1}",riskPatternRef == "${value-2}");'/>
      </condition>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_ANDROID-CLIENT' name='Extend risk pattern'
              type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
    <content />
  </rule>
  <rule name='Risk Pattern: Mobile OS - Mobile Device Client - iOS' module='component' generatedByGui='true'>
    <condition name='Question is answered' type='Question' field='id' value='mobile.iOS'>
      <pattern name='Condition with answer' pattern='${type}(${field} == "${value}", answer == true);' />
    </condition>
      <condition name='Risk pattern exists' type='drools-without-variable-type' field='id'
                 value='OWASP MASVS v1.0_::_MOBILE-CLIENT'>
          <pattern name='Risk pattern exists'
                   pattern='$riskPattern : ImportWholeRiskPatternAwareDto(libraryRef == "${value-1}",riskPatternRef == "${value-2}");'/>
      </condition>
      <action project='OWASP MASVS v1.0' value='OWASP MASVS v1.0_::_IOS-CLIENT' name='Extend risk pattern'
              type='drools-without-variable-type'>
          <pattern name='Action of extend risk pattern'
                   pattern='insertLogical($riskPattern.extendRiskPattern("${value-1}","${value-2}"));'/>
    </action>
    <content />
  </rule>
</rules>
</project>