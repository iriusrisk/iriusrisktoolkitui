<?xml version="1.0" encoding="UTF-8"?>
<!--Copyright (c) 2012-2019 Continuum Security.  All rights reserved.The content of this library is the property of Continuum Security SL and may only be used in whole or in part with a valid license for IriusRisk.-->
<project ref="aws-lambda" name="AWS Lambda" revision="7" type="LIBRARY" status="OPEN" enabled="true" priority="0" tags="">
    <desc>This library provides us a set of risk patterns (threats, use-cases, weaknesses,...) for AWS Lambda.</desc>
    <categoryComponents>
        <categoryComponent ref="amazon-web-services" name="Amazon Web Services"/>
    </categoryComponents>
    <componentDefinitions>
        <componentDefinition ref="aws-lambda-function" name="Lambda Function" desc="Only select this if the security of the AWS Lambda Function will be managed in this product." categoryRef="amazon-web-services">
            <riskPatterns>
                <riskPattern ref="aws-lambda-monitoring-and-logging"/>
                <riskPattern ref="aws-lambda-authoritation"/>
                <riskPattern ref="aws-lambda-access-sensitive-data"/>
                <riskPattern ref="aws-lambda-tampering"/>
                <riskPattern ref="aws-lambda-flow-management"/>
                <riskPattern ref="aws-lambda-authentication"/>
                <riskPattern ref="aws-lambda-denial-of-service"/>
                <riskPattern ref="aws-lambda-patching"/>
            </riskPatterns>
        </componentDefinition>
    </componentDefinitions>
    <udts/>
    <supportedStandards>
        <supportedStandard ref="cis-amazon-web-services-three-tier-web-architecture-benchmark" name="CIS Amazon Web Services Three-tier Web Architecture Benchmark"/>
        <supportedStandard ref="CIS AWS Standard" name="CIS Amazon Web Services Foundations Benchmark"/>
        <supportedStandard ref="ISO/IEC 27002:2013" name="ISO/IEC 27002:2013"/>
        <supportedStandard ref="OWASP-ASVS-Level-1" name="OWASP-ASVS-Level-1"/>
        <supportedStandard ref="OWASP-ASVS-Level-2" name="OWASP-ASVS-Level-2"/>
        <supportedStandard ref="OWASP-ASVS-Level-3" name="OWASP-ASVS-Level-3"/>
        <supportedStandard ref="NIST 800-53" name="NIST 800-53"/>
        <supportedStandard ref="owasp-top-10-2017" name="OWASP Top 10 2017"/>
    </supportedStandards>
    <components>
<component ref="aws-lambda-access-sensitive-data" name="AWS Lambda: Access sensitive data" desc="" tags="" position="1" groupName="" library="" diagramPositionX="0" diagramPositionY="0" componentDefinitionRef="">
            <weaknesses>
<weakness ref="AWS-LAMBDA-W2" name="The Data Store is directly exposed to the internet" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Data Stores are accessible by the public internet with no - or weak - authentication.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W21" name="Verbose error messages are left in the code and are not removed before moving to production" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Error messages or debugging information must be removed before moving to the production/release branch. This type of information gives an attacker additional insight on the internal working of the application/functions and on the technology used.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W22" name="Messages exposed to end users reveal information about serverless functions and the logic used" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Messages to end users must only contain general information and not leak data relating to software implementation or the underlying technology.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W1" name="Sensitive stored information was not encrypted at rest" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Because sensitive information is stored in cleartext, attackers could potentially read it. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is used and decode the information.</desc>
                </weakness>
</weaknesses>
<controls>
<control ref="AWS-LAMBDA-C29" name="Ensure that sensitive data is not saved into logs files." platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>	&lt;p&gt;Review periodically all logs to ensure that sensitive data is not presented in the logs files.&lt;/p&gt;

	&lt;p&gt;AWS introduces a new security service Macie recognizing sensitive data such as personally identifiable information (PII) or intellectual property, and provides you with dashboards and alerts that give visibility into how this data is being accessed or moved.&lt;/p&gt;

	&lt;p&gt;You can also use the Amazon Macie service to classify all data and find if there is sensitive data in the logs files.&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS CloudWatch user guide" url="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html"/>
                        <reference name="AWS Macie" url="https://aws.amazon.com/macie/"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>	&lt;p&gt;Verify if the log files don&amp;#8217;t contain sensitive data.&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C2" name="Not expose your data stores directly to internet" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;When using S3 buckets ensure you disable public read access, unless you are using the bucket for storing images or a static website. Ensure data stores are properly protected with firewall settings and gateways. Create specific internal users to access the data store and ensure that only those users can access the data store.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;/b&gt;&lt;br /&gt; To set ACL access permissions for an S3 bucket: &lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Sign in to the AWS Management Console and open the Amazon S3 console at https://console.aws.amazon.com/s3/.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;In the Bucket name list, choose the name of the bucket that you want to set permissions for.&lt;/li&gt; 
 &lt;li&gt;Choose Permissions .&lt;/li&gt; 
 &lt;li&gt;You can manage bucket access permissions for the following: Owner access, Access for other AWS accounts, Public access or S3 log delivery group.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="How Do I Set ACL Bucket Permissions?" url="https://docs.aws.amazon.com/AmazonS3/latest/user-guide/set-bucket-permissions.html"/>
                        <reference name="Identifying Public Buckets Using Bucket Permissions Check" url="https://docs.aws.amazon.com/AmazonS3/latest/user-guide/bucket-permissions-check.html"/>
                        <reference name="S3 Access Control List (ACL) Overview" url="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Check the access permissions for an S3 bucket: &lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Sign in to the AWS Management Console and open the Amazon S3 console at https://console.aws.amazon.com/s3/.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;In the Bucket name list, choose the name of the bucket that you want to set permissions for.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Choose Permissions.&lt;/li&gt; 
 &lt;li&gt;Check that the permissions are defined well.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="Hydras-AWS-S3-7.4" name="Encrypt sensitive data at rest with KMS" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Amazon Simple Storage Service is storage for the Internet. It is designed to make web-scale computing easier for developers. &lt;/p&gt; 
&lt;p&gt;Amazon S3 has a simple web services interface that you can use to store and retrieve any amount of data, at any time, from anywhere on the web. It gives any developer access to the same highly scalable, reliable, fast, inexpensive data storage infrastructure that Amazon uses to run its own global network of web sites. &lt;/p&gt; 
&lt;p&gt;To ensure that sensitive data is encrypted at rest you can use AWS KMS–managed keys (SSE-KMS). This provides several advantages: &lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;You can create and manage the CMK encryption keys yourself.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;You can use a single CMK to encrypt and decrypt log files for multiple accounts across all regions.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;You have control over who can use your key for encrypting and decrypting CloudTrail log files. You can assign permissions for the key to the users in your organization according to your requirements.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;You have enhanced security. With this feature, in order to read log files, you now need to meet two conditions: 1) you must have S3 read permission on the bucket, and 2) you must be granted decrypt permission by the CMK policy.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;It is recommended to encrypt all sensitive data with SSE-KMS to avoid undue disclosure of information and provide an extra layer of security.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation: &lt;/b&gt;&lt;br /&gt; The following example shows how to upload data using AWS KMS Encryption: &lt;br /&gt; aws s3api put-object --bucket --server-side-encryption aws:kms --ssekms-key-id --key &lt;/p&gt; 
&lt;p&gt;Content provided by Hydras IT LTD&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Secrets Manager" url="https://aws.amazon.com/secrets-manager/"/>
                        <reference name="Protecting data using Encryption" url="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingEncryption.html"/>
                        <reference name="Storing and Retrieving a Secret (AWS Tutorial)" url="https://docs.aws.amazon.com/secretsmanager/latest/userguide/tutorials_basic.html"/>
                        <reference name="Storing Lambda function encrypted secrets using environment variables and KMS" url="https://docs.aws.amazon.com/lambda/latest/dg/tutorial-env_console.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;blockquote&gt; 
 &lt;p&gt;aws s3api head-object --bucket --key &lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt; Look for the line “ServerSideEncryption” and verify that it is set to “aws:kms” which indicates KMS Encryption.&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control>
</controls>
<usecases>
<usecase ref="SENSITIVE INFORMATION IN DATA STORES" name="Sensitive information in data stores" desc="" library="">
                    <threats>
<threat ref="AWS-LAMBDA-T1" name="Sensitive information is leaked from data stores" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;Sensitive information is exfiltrated from a data store because there is no encryption applied or the server was misconfigured&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C2" mitigation="50"/>
                                <control ref="Hydras-AWS-S3-7.4" mitigation="50"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W1">
                                    <controls>
                                        <control ref="Hydras-AWS-S3-7.4" mitigation="50"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W2">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C2" mitigation="50"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat>
</threats>
</usecase>
<usecase ref="SENSITIVE INFORMATION IN LOGS" name="Sensitive information in logs" desc="" library="">
                    <threats>
<threat ref="AWS-LAMBDA-T14" name="Sensitive data is leaked through non-sanitized debugging/logging statements" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;Whilst logging all information may be helpful during development stages, it is important that logging levels be set appropriately before a product ships, ensuring sensitive user data and system information are not exposed to potential attackers.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C29" mitigation="100"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W22">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C29" mitigation="100"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W21">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C29" mitigation="100"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat>
</threats>
</usecase>
</usecases>
</component>
<component ref="aws-lambda-monitoring-and-logging" name="AWS Lambda: Monitoring and Logging" desc="" tags="" position="6" groupName="" library="" diagramPositionX="0" diagramPositionY="0" componentDefinitionRef="">
            <weaknesses>
<weakness ref="CWE-284" name="Improper Access Control" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>The software does not restrict or incorrectly restricts access to a resource from an unauthorized actor.</desc>
                </weakness>
</weaknesses>
<controls>
<control ref="AWS-LOGS-INTEGRITY" name="Ensure the integrity of the logging system" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Enable AWS Log integrity for the application generated logs, such as storing logs on write-once media, forwarding a copy of the logs to a centralized SIEM or generating message digests for each log file.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;/b&gt;&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;AWS Management Console:&lt;/li&gt; 
 &lt;ul&gt; 
  &lt;li&gt;To enable log file integrity validation with the CloudTrail console, choose Yes for the Enable log file validation option when you create or update a trail. By default, this feature is enabled for new trails.&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;AWS CLI:&lt;/li&gt; 
 &lt;ul&gt; 
  &lt;li&gt;To enable log file integrity validation with the AWS CLI, use the --enable-log-file-validation option with the create-trail or update-trail commands.&amp;nbsp;&lt;/li&gt; 
  &lt;li&gt;To disable log file integrity validation, use the --no-enable-log-file-validation option.&lt;/li&gt; 
  &lt;li&gt;For example:&amp;nbsp;&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;aws cloudtrail update-trail --name your-trail-name --enable-log-file-validation&lt;/p&gt; 
  &lt;/blockquote&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;CloudTrail API:&lt;/li&gt; 
 &lt;ul&gt; 
  &lt;li&gt;To enable log file integrity validation with the CloudTrail API, set the EnableLogFileValidation request parameter to true when calling CreateTrail or UpdateTrail.&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS CLI describe trails" url="https://docs.aws.amazon.com/cli/latest/reference/cloudtrail/describe-trails.html"/>
                        <reference name="Enabling Log File Integrity Validation for CloudTrail" url="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-log-file-validation-enabling.html"/>
                    </references>
                    <standards>
                        <standard ref="12.1.2" supportedStandardRef="ISO/IEC 27002:2013"/>
                        <standard ref="12.4.2" supportedStandardRef="ISO/IEC 27002:2013"/>
                        <standard ref="AC-24" supportedStandardRef="NIST 800-53"/>
                        <standard ref="AC-3" supportedStandardRef="NIST 800-53"/>
                        <standard ref="AU-4" supportedStandardRef="NIST 800-53"/>
                        <standard ref="AU-9" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SA-18" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SC-28" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-4" supportedStandardRef="NIST 800-53"/>
                        <standard ref="8.6" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="8.11" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="8.6" supportedStandardRef="OWASP-ASVS-Level-3"/>
                    </standards>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Check the AWS Logs Integrity is enabled if the output of the following command in the AWS CLI has got the variable “LogFileValidationEnabled” set to true.&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws cloudtrail describe-trails&lt;/p&gt; 
&lt;/blockquote&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-LOG-SPECIFICS" name="Increase log reports with serverless-specific information" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Organizations adopting serverless architectures, are encouraged to augment log reports with serverless-specific information such as:&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Logging of API access keys related to successful/failed logins (authentication)&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Attempts to invoke serverless functions with inadequate permissions (authorizations)&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Successful/failed deployment of new serverless functions or configurations (change)&lt;/li&gt; 
 &lt;li&gt;Changes to function permissions or execution roles (change)&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Changes to files or access permissions on relevant cloud storage services (change)&lt;/li&gt; 
 &lt;li&gt;Changes in function trigger definitions (change)&lt;/li&gt; 
 &lt;li&gt;Anomalous interaction or irregular flow between serverless functions (change)&lt;/li&gt; 
 &lt;li&gt;Changes to 3rd party dependencies (modules, libraries or APIs)&lt;/li&gt; 
 &lt;li&gt;Outbound connections initiated by serverless functions (network)&lt;/li&gt; 
 &lt;li&gt;Execution of serverless functions or access to data from an external 3rd party account not related to the main account to which the serverless application belongs (resource access)&lt;/li&gt; 
 &lt;li&gt;Serverless function execution timeouts (failure reports)&lt;/li&gt; 
 &lt;li&gt;Concurrent serverless function execution limits reached (failure reports)&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;Organizations are also encouraged to adopt serverless application logic/code runtime tracing and debugging facilities in order to gain better understanding of the overall system and data flow. For example: AWS X-Ray&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;/b&gt;&lt;br /&gt; To log more actions with the CloudTrail, we only have to create a trail as following:&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Create a trail. By default, when you create a trail in a region in the CloudTrail console, the trail applies to all regions.&lt;/li&gt; 
 &lt;li&gt;Create an Amazon S3 bucket or specify an existing bucket where you want the log files delivered. By default, log files from all regions in your account are delivered to the bucket that you specify.&lt;/li&gt; 
 &lt;li&gt;Configure your trail to log read-only, write-only, or all management events, and all or a subset of data events. By default, trails log all management events and no data events.&lt;/li&gt; 
 &lt;li&gt;Create an Amazon SNS topic to receive notifications when log files are delivered. Delivery notifications from all regions are sent to the topic that you specify.&lt;/li&gt; 
 &lt;li&gt;Configure CloudWatch Logs to receive your logs from CloudTrail so that you can monitor for specific log events.&lt;/li&gt; 
 &lt;li&gt;Change the encryption method for your log files from server-side encryption with Amazon S3-managed encryption keys (SSE-S3) to server-side encryption with AWS KMS–managed keys (SSE-KMS).&lt;/li&gt; 
 &lt;li&gt;Turn on integrity validation for log files. This enables the delivery of digest files that you can use to validate the integrity of log files after CloudTrail has delivered them.&lt;/li&gt; 
 &lt;li&gt;Add tags (custom key-value pairs) to your trail.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS CLI describe-trails" url="https://docs.aws.amazon.com/cli/latest/reference/cloudtrail/describe-trails.html"/>
                        <reference name="AWS Lambda Metrics and Dimensions – CloudWatch" url="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/aws-services-cloudwatch-metrics.html"/>
                        <reference name="AWS-X-Ray" url="https://aws.amazon.com/xray/"/>
                        <reference name="Creating a Trail For Your AWS Account" url="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-create-and-update-a-trail.html"/>
                        <reference name="Logging AWS Lambda API Calls by Using AWS CloudTrail" url="https://docs.aws.amazon.com/lambda/latest/dg/logging-using-cloudtrail.html"/>
                        <reference name="Logging AWS Serverless Application Repository API Calls with AWS CloudTrail" url="https://docs.aws.amazon.com/serverlessrepo/latest/devguide/logging-using-cloudtrail.html"/>
                        <reference name="Troubleshooting &amp; Monitoring Lambda-based Apps with CloudWatch" url="https://docs.aws.amazon.com/lambda/latest/dg/monitoring-functions.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Check that the new logs are included in CloudTrail, we can get all trails with the following command: &lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws cloudtrail describe-trails&lt;/p&gt; 
&lt;/blockquote&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-RESTRICT-NUMBER-ACCOUNT-TO-LOGS" name="Limit the number of accounts with privileges allowing modification and/or deletion of audit logs files" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Limit the number of accounts with privileges to modify and/or delete audit logs files.&lt;/p&gt; 
&lt;p&gt;The following AWS managed policies, which you can attach to users in your account, are specific to CloudWatch Logs:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;CloudWatchLogsFullAccess – Grants full access to CloudWatch Logs.&lt;/li&gt; 
 &lt;li&gt;CloudWatchLogsReadOnlyAccess – Grants read-only access to CloudWatch Logs.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;By default, all user shall only have got the managed policy “CloudWatchLogsReadOnlyAccess”, and only few users shall have got the managed policy “CloudWatchLogsFullAccess”.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;/b&gt;&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Go to the AWS CLI.&lt;/li&gt; 
 &lt;li&gt;List all users, with the following command:&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt;aws iam list-users&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Run the following command per user to ensure that only the desired users have got the managed policy “CloudWatchLogsFullAccess” and the other users the managed policy “CloudWatchLogsReadOnlyAccess”, to do it run the following command per username:&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt;aws iam list-attached-user-policies --user-name [userName]&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;If there is at least user with the managed policy “CloudWatchLogsFullAccess” and it shall not be allowed, we have to change the managed policy for these users.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Run the following command per each user to remove the managed policy:&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt;aws iam delete-user-policy --user-name [userName] --policy-name CloudWatchLogsFullAccess&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt; 
 &lt;li&gt;Run the following command per each user to add a new managed policy:&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt;aws iam attach-user-policy --policy-arn arn:aws:iam::aws:policy/CloudWatchLogsReadOnlyAccess --user-name [userName]&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS CLI assign policy to user" url="https://docs.aws.amazon.com/cli/latest/reference/iam/attach-user-policy.html"/>
                        <reference name="AWS CLI list policies per user" url="https://docs.aws.amazon.com/cli/latest/reference/iam/list-attached-user-policies.html"/>
                        <reference name="AWS CLI list users" url="https://docs.aws.amazon.com/cli/latest/reference/iam/list-users.html"/>
                        <reference name="AWS CLI remove policy per user" url="https://docs.aws.amazon.com/cli/latest/reference/iam/delete-user-policy.html"/>
                        <reference name="AWS Managed (Predefined) Policies for CloudWatch Logs" url="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-identity-based-access-control-cwl.html#managed-policies-cwl"/>
                        <reference name="Berkeley security: audit logs" url="https://security.berkeley.edu/security-audit-logging-guideline"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Go to the AWS CLI.&lt;/li&gt; 
 &lt;li&gt;List all users, with the following command: aws iam list-users&lt;/li&gt; 
 &lt;li&gt;Run the following command per user and check that only the desired users have got the managed policy “CloudWatchLogsFullAccess” and the other users the managed policy “CloudWatchLogsReadOnlyAccess”, to do it run the following command per username: aws iam list-attached-user-policies --user-name [userName]&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control>
</controls>
<usecases>
<usecase ref="MONITORING AND LOGGING" name="Monitoring and Logging" desc="" library="">
                    <threats>
<threat ref="CAPEC-93" name="An attacker injects, manipulates or forges malicious log entries in the log file, allowing her to mislead a log audit, cover traces of attack, or perform other malicious actions" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;This attack targets the log files of the target host. The attacker injects, manipulates or forges malicious log entries in the log file, allowing him to mislead a log audit, cover traces of attack, or perform other malicious actions. The target host is not properly controlling log access. As a result tainted data is resulting in the log files leading to a failure in accountability, non-repudiation and incident forensics capability.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-LOG-SPECIFICS" mitigation="33"/>
                                <control ref="AWS-LOGS-INTEGRITY" mitigation="34"/>
                                <control ref="AWS-RESTRICT-NUMBER-ACCOUNT-TO-LOGS" mitigation="33"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="CWE-284">
                                    <controls>
                                        <control ref="AWS-LAMBDA-LOG-SPECIFICS" mitigation="33"/>
                                        <control ref="AWS-LOGS-INTEGRITY" mitigation="34"/>
                                        <control ref="AWS-RESTRICT-NUMBER-ACCOUNT-TO-LOGS" mitigation="33"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat>
</threats>
</usecase>
</usecases>
</component>
<component ref="aws-lambda-flow-management" name="AWS Lambda: Flow management" desc="" tags="" position="5" groupName="" library="" diagramPositionX="0" diagramPositionY="0" componentDefinitionRef="">
            <weaknesses>
<weakness ref="CWE-841" name="Improper Enforcement of Behavioral Workflow" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>The software supports a session in which more than one behavior must be performed by an actor, but it does not properly ensure that the actor performs the behaviors in the required sequence.</desc>
                </weakness>
</weaknesses>
<controls>
<control ref="OTG-BUSLOGIC" name="Detect and notify the usage of automated tools or unusual behavior" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>	&lt;p&gt;Don&amp;#8217;t allow users to manipulate a system or guess its behavior based on input or output timing and detect the usage of automated tools or unusual behavior, such as actions not performed in reasonable &amp;quot;human time&amp;quot; or other abnormal time patterns. &lt;/p&gt;

 When the usage of automated tools is detected, the application shall respond with denying the access and notifying the security group.</desc>
                    <implementations/>
                    <references>
                        <reference name="OWASP testing business logic" url="https://www.owasp.org/index.php/Testing_for_business_logic"/>
                    </references>
                    <standards>
                        <standard ref="SI-13" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-17" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-5" supportedStandardRef="NIST 800-53"/>
                        <standard ref="15.2" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="15.2" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="9.8" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="A10:2017-Insufficient Logging&amp;Monitoring" supportedStandardRef="owasp-top-10-2017"/>
                        <standard ref="A5:2017-Broken Access Control" supportedStandardRef="owasp-top-10-2017"/>
                    </standards>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Use several automated tools to perform normal user actions.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Check that the applications detects these actions, denies the users access and notifies the security group.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="OTG-BUSLOGIC-006" name="Restrict actions of users that follow unusual patterns." platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>	&lt;p&gt;Restrict actions that users can do outside of the approved/required business process flow. &lt;/p&gt;

 This is important because without this safeguard in place attackers may be able to bypass or circumvent workflows and checks allowing them to prematurely enter or skip required sections of the application potentially allowing action/transaction to be completed without successfully completing the entire business process, leaving the system with incomplete backend tracking information.</desc>
                    <implementations/>
                    <references>
                        <reference name="OWASP testing business logic" url="https://www.owasp.org/index.php/Testing_for_business_logic"/>
                        <reference name="OWASP testing for the circumvention of work flows" url="https://www.owasp.org/index.php/Testing_for_the_Circumvention_of_Work_Flows_(OTG-BUSLOGIC-006)"/>
                    </references>
                    <standards>
                        <standard ref="SI-17" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-2" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-6" supportedStandardRef="NIST 800-53"/>
                        <standard ref="15.1" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="15.1" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="A10:2017-Insufficient Logging&amp;Monitoring" supportedStandardRef="owasp-top-10-2017"/>
                        <standard ref="A5:2017-Broken Access Control" supportedStandardRef="owasp-top-10-2017"/>
                    </standards>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>	&lt;p&gt;Check that the application will only process business logic flows in sequential step order and in realistic human time.&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control>
</controls>
<usecases>
<usecase ref="GENERAL" name="General" desc="" library="">
                    <threats>
<threat ref="CAPEC-172" name="Attackers subvert the intended workflow of the application in order to perform unauthorised operations" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;If an application enforces an order in workflows, then attackers could attempt to bypass this order so that they can perform operations for which they are not authorized. The technique can also be used to gain access to unauthorised data.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="OTG-BUSLOGIC" mitigation="50"/>
                                <control ref="OTG-BUSLOGIC-006" mitigation="50"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="CWE-841">
                                    <controls>
                                        <control ref="OTG-BUSLOGIC" mitigation="50"/>
                                        <control ref="OTG-BUSLOGIC-006" mitigation="50"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat>
</threats>
</usecase>
</usecases>
</component>
<component ref="aws-lambda-authentication" name="AWS Lambda: Authentication" desc="" tags="" position="2" groupName="" library="" diagramPositionX="0" diagramPositionY="0" componentDefinitionRef="">
            <weaknesses>
<weakness ref="AWS-LAMBDA-W8" name="Environment variables are not stored securely" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Environment variables were stored in plain text configuration files and stored in the code repository</desc>
                </weakness><weakness ref="CWE-592" name="Authentication Bypass Issues" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>The software does not properly perform authentication, allowing 					it to be bypassed through various methods.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W20" name="DynamoDB APIs are vulnerable to XSS" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>DynamoDB is a NoSQL database and as such is schemaless. NoSQL databases provide looser consistency restrictions than traditional SQL databases. By requiring fewer relational constraints and consistency checks, NoSQL databases often offer performance and scaling benefits. Yet these databases are still potentially vulnerable to injection attacks, even if they aren't using the traditional SQL syntax.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W7" name="Your AWS credentials were stored in a code repositories such as GitHub" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Monitoring is needed to understand the relationships between all of the objects across a virtual environment’s topology and recognize the difference between inconsequential anomalies and actual performance problems. 
 This will identify root causes and recommended actions for remediation. This way, you can understand what needs your attention, and how to narrow down a problem to the relevant components.</desc>
                </weakness>
</weaknesses>
<controls>
<control ref="ACCESS-CONTROL-CENTRALIZED-AWS-LAMBDA" name="Ensure that the access control through API is centralized" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;The access control, authentication and authorization procedures through API shall be centralized. To implement it into Lambda functions, we have got the two options:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Lambda authorizers are Lambda functions that control access to REST API methods using bearer token authentication as well as information described by headers, paths, query strings, stage variables, or context variables request parameters.&amp;nbsp;&lt;/li&gt; 
 &lt;ul&gt; 
  &lt;li&gt;TOKEN type Lambda authorizers grant a caller permissions to invoke a given request using an authorization token passed in a header. The token could be, for example, an OAuth token.&amp;nbsp;&lt;/li&gt; 
  &lt;li&gt;REQUEST type Lambda authorizers grant a caller permissions to invoke a given request using request parameters, including headers, query strings, stage variables, or context parameters.&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;li&gt;Amazon Cognito user pools let you create customizable authentication and authorization solutions for your REST APIs.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;/b&gt;&lt;br /&gt; Create an API Gateway Lambda Authorizer Lambda Function:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Before creating an API Gateway Lambda authorizer, you must first create the AWS Lambda function that implements the logic to authorize and, if necessary, to authenticate the caller. You can do so in the Lambda console, using the code template available from the API Gateway Lambda Authorizer blueprint.&lt;/li&gt; 
 &lt;li&gt;To grant IAM principals in the account that owns the API permission to call authorizer:create or create-authorizer to control the Lambda function used in your Lambda authorizer, you can create the following IAM policy.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;blockquote&gt;
    { 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;, 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;quot;Statement&amp;quot;: [ 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; { 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;, 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;Action&amp;quot;: [ 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;apigateway:POST&amp;quot; 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ], 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;Resource&amp;quot;: [ 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;arn:aws:apigateway:region::/restapis/restapi_id/authorizers&amp;quot; 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ], 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //Create Authorizer operation is allowed only with the following Lambda function 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;Condition&amp;quot;: { 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;StringEquals&amp;quot;: { 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;apigateway:AuthorizerUri&amp;quot;: &amp;quot;arn:aws:lambda:region:account-id:function:lambda-function-name&amp;quot; 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; } 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; } 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; } 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    &amp;nbsp; &amp;nbsp; ] 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt;
    } 
  &lt;/blockquote&gt; 
 &lt;/blockquote&gt; 
 &lt;blockquote&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;div&gt; 
 &lt;p&gt;&lt;/p&gt; 
 &lt;p&gt;Create a Lambda Function for a Lambda Authorizer of the TOKEN type&lt;br /&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;In the code editor of the Lambda console, enter the following Node.js code as an example of the API Gateway Lambda authorizer of the TOKEN type.&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;div&gt; 
   &lt;p&gt;// A simple TOKEN authorizer example to demonstrate how to use an authorization token&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;// to allow or deny a request. In this example, the caller named 'user' is allowed to invoke&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;// a request if the client-supplied token value is 'allow'. The caller is not allowed to invoke&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;// the request if the token value is 'deny'. If the token value is 'Unauthorized', the function&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;// returns the 'Unauthorized' error with an HTTP status code of 401. For any other token value,&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;// the authorizer returns an 'Invalid token' error.&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&lt;br /&gt;&lt;/p&gt; 
   &lt;p&gt;exports.handler =&amp;nbsp; function(event, context, callback) {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var token = event.authorizationToken;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; switch (token.toLowerCase()) {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case 'allow':&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; callback(null, generatePolicy('user', 'Allow', event.methodArn));&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; break;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case 'deny':&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; callback(null, generatePolicy('user', 'Deny', event.methodArn));&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; break;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case 'unauthorized':&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; callback(&amp;quot;Unauthorized&amp;quot;);&amp;nbsp; &amp;nbsp;// Return a 401 Unauthorized response&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; break;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; default:&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; callback(&amp;quot;Error: Invalid token&amp;quot;);&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt; 
   &lt;p&gt;};&lt;/p&gt; 
   &lt;p&gt;&lt;br /&gt;&lt;/p&gt; 
   &lt;p&gt;// Help function to generate an IAM policy&lt;/p&gt; 
   &lt;p&gt;var generatePolicy = function(principalId, effect, resource) {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var authResponse = {};&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; authResponse.principalId = principalId;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; if (effect &amp;amp;&amp;amp; resource) {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var policyDocument = {};&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; policyDocument.Version = '2012-10-17';&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; policyDocument.Statement = [];&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var statementOne = {};&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; statementOne.Action = 'execute-api:Invoke';&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; statementOne.Effect = effect;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; statementOne.Resource = resource;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; policyDocument.Statement[0] = statementOne;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; authResponse.policyDocument = policyDocument;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // Optional output with custom properties of the String, Number or Boolean type.&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; authResponse.context = {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;stringKey&amp;quot;: &amp;quot;stringval&amp;quot;,&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;numberKey&amp;quot;: 123,&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;booleanKey&amp;quot;: true&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; };&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; return authResponse;&lt;/p&gt; 
   &lt;p&gt;}&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;div&gt; 
 &lt;p&gt;Create a Lambda Function of a Lambda Authorizer of the REQUEST type&lt;br /&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;In the code editor of the Lambda console, enter the following Node.js code for a simplified Lambda function as an example of the API Gateway Lambda authorizers of the REQUEST type.&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;div&gt; 
   &lt;p&gt;exports.handler = function(event, context, callback) {&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; console.log('Received event:', JSON.stringify(event, null, 2));&lt;/p&gt; 
   &lt;p&gt;&lt;br /&gt;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // A simple REQUEST authorizer example to demonstrate how to use request&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // parameters to allow or deny a request. In this example, a request is&amp;nbsp;&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // authorized if the client-supplied HeaderAuth1 header, QueryString1 query parameter,&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // stage variable of StageVar1 and the accountId in the request context all match&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // specified values of 'headerValue1', 'queryValue1', 'stageValue1', and&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // '123456789012', respectively.&lt;/p&gt; 
   &lt;p&gt;&lt;br /&gt;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // Retrieve request parameters from the Lambda function input:&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var headers = event.headers;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var queryStringParameters = event.queryStringParameters;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var pathParameters = event.pathParameters;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var stageVariables = event.stageVariables;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var requestContext = event.requestContext;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // Parse the input for the parameter values&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var tmp = event.methodArn.split(':');&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var apiGatewayArnTmp = tmp[5].split('/');&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var awsAccountId = tmp[4];&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var region = tmp[3];&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var restApiId = apiGatewayArnTmp[0];&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var stage = apiGatewayArnTmp[1];&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var method = apiGatewayArnTmp[2];&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var resource = '/'; // root resource&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; if (apiGatewayArnTmp[3]) {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; resource += apiGatewayArnTmp[3];&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // Perform authorization to return the Allow policy for correct parameters and&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // the 'Unauthorized' error, otherwise.&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var authResponse = {};&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var condition = {};&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; condition.IpAddress = {};&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; if (headers.HeaderAuth1 === &amp;quot;headerValue1&amp;quot;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;amp;&amp;amp; queryStringParameters.QueryString1 === &amp;quot;queryValue1&amp;quot;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;amp;&amp;amp; stageVariables.StageVar1 === &amp;quot;stageValue1&amp;quot;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;amp;&amp;amp; requestContext.accountId === &amp;quot;123456789012&amp;quot;) {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; callback(null, generateAllow('me', event.methodArn));&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; }&amp;nbsp; else {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; callback(&amp;quot;Unauthorized&amp;quot;);&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt; 
   &lt;p&gt;}&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;// Help function to generate an IAM policy&lt;/p&gt; 
   &lt;p&gt;var generatePolicy = function(principalId, effect, resource) {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // Required output:&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; var authResponse = {};&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; authResponse.principalId = principalId;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; if (effect &amp;amp;&amp;amp; resource) {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var policyDocument = {};&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; policyDocument.Version = '2012-10-17'; // default version&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; policyDocument.Statement = [];&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var statementOne = {};&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; statementOne.Action = 'execute-api:Invoke'; // default action&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; statementOne.Effect = effect;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; statementOne.Resource = resource;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; policyDocument.Statement[0] = statementOne;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; authResponse.policyDocument = policyDocument;&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; // Optional output with custom properties of the String, Number or Boolean type.&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; authResponse.context = {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;stringKey&amp;quot;: &amp;quot;stringval&amp;quot;,&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;numberKey&amp;quot;: 123,&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;quot;booleanKey&amp;quot;: true&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; };&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; return authResponse;&lt;/p&gt; 
   &lt;p&gt;}&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;var generateAllow = function(principalId, resource) {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; return generatePolicy(principalId, 'Allow', resource);&lt;/p&gt; 
   &lt;p&gt;}&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;var generateDeny = function(principalId, resource) {&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp; &amp;nbsp; return generatePolicy(principalId, 'Deny', resource);&lt;/p&gt; 
   &lt;p&gt;}&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;div&gt; 
 &lt;blockquote&gt; 
  &lt;blockquote&gt; 
   &lt;div&gt; 
   &lt;/div&gt; 
  &lt;/blockquote&gt; 
 &lt;/blockquote&gt; 
 &lt;div&gt; 
  &lt;p&gt;Amazon Cognito&lt;/p&gt; 
  &lt;p&gt;&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;To create and configure an Amazon Cognito user pool for your API, you perform the following tasks:&lt;/li&gt; 
   &lt;ol&gt; 
    &lt;li&gt;Use the Amazon Cognito console, CLI/SDK, or API to create a user pool—or use one that’s owned by another AWS account.&lt;/li&gt; 
    &lt;li&gt;Use the API Gateway console, CLI/SDK, or API to create an API Gateway authorizer with the chosen user pool.&lt;/li&gt; 
    &lt;li&gt;Use the API Gateway console, CLI/SDK, or API to enable the authorizer on selected API methods.&lt;/li&gt; 
   &lt;/ol&gt; 
   &lt;li&gt;To call any API methods with a user pool enabled, your API clients perform the following tasks:&lt;/li&gt; 
   &lt;ol&gt; 
    &lt;li&gt;Use the Amazon Cognito CLI/SDK or API to sign a user in to the chosen user pool, and obtain an identity token or access token.&lt;/li&gt; 
    &lt;li&gt;Use a client-specific framework to call the deployed API Gateway API and supply the appropriate token in the Authorization header.&lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/ul&gt; 
  &lt;p&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS API Gateway authorization facilities" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-control-access-to-api.html"/>
                        <reference name="AWS Use API Gateway Lambda Authorizers" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html"/>
                        <reference name="Control Access to a REST API Using Amazon Cognito User Pools as Authorizer" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>	&lt;p&gt;Check that access control mechanisms for the API are centralized.&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C8" name="Ensure that sensitive data is not commited to the repository" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>	&lt;p&gt;Create the mechanisms to ensure that sensitive data, such personal data or credentials is not uploaded to a repository. There are different ways to implement it. One of them is with the git pre-commit hooks, this way is described in the references.&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="Preventing AWS credential leaks in Git with pre-commit" url="https://www.unixdaemon.net/cloud/preventing-aws-creds-in-git-with-pre-commit/"/>
                        <reference name="Prevents you from committing secrets and credentials into git repositories" url="https://github.com/awslabs/git-secrets"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>	&lt;p&gt;Check that there is not any sensitive data in the code from a repository.&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="DATA-VAL-GENERIC" name="Validate all data received" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;All data received shall be considered tainted and a potential risk, regardless of the source or transport method. For example, while hidden form fields, cookies, or other headers may be obfuscated from a user, along with parameters passed in ViewStates or other encapsulated forms, these can be modified by the user on the client-side in memory, or in transit on the network. Similarly, data passed from binary or compiled components can be modified in situ or in transit. &lt;/p&gt; 
&lt;p&gt;Furthermore, encryption only secures the data in transit between the two ends of the encrypted tunnel (one end of which is typically controlled by the client); data passing through the link may still be malicious.&lt;/p&gt; 
&lt;p&gt;As such, all data received must be subjected to strict validation, sanitization, and encoding against expected syntactic and semantic criteria.&lt;/p&gt; 
&lt;p&gt; Define a specification of the data that is expected at each input; both the syntax (e.g. alphanumeric only) and semantics (e.g. a word of between 1 and 25 characters, or a specific list). As an example of business rule logic, “boat” may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as “red” or “blue.”&lt;br /&gt; Implement a ‘known good’ or white-list approach, where only inputs that meet the strict criteria for each input are accepted, and reject, transform, or encapsulate any non-compliant data.&lt;/p&gt; 
&lt;p&gt; While useful for identifying malicious content, do not rely on looking for specific malformed or attack payloads (blacklists). It is almost impossible to maintain a comprehensive and accurate blacklist due to the complexity and evolving nature of attacks, opportunities to obfuscate payloads, and changes to the code’s execution environment. As noted, blacklists can be useful for detecting and logging potential attacks, or determining which inputs are so malformed that they should be rejected outright.&lt;/p&gt; 
&lt;p&gt; Validate all data received from the client, including values such as HTTP headers and cookie values if these are used as input on the server side, X- headers, and other platform specific data objects passed between the client and server.&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="Enable Request Validation in API Gateway" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html"/>
                        <reference name="OWASP Input Validation Cheat Sheet" url="https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet"/>
                        <reference name="OWASP Testing for Input Validation" url="https://www.owasp.org/index.php/Testing_for_Input_Validation"/>
                    </references>
                    <standards>
                        <standard ref="12.2.1" supportedStandardRef="ISO/IEC 27002:2013"/>
                        <standard ref="12.6.1" supportedStandardRef="ISO/IEC 27002:2013"/>
                        <standard ref="CA-8" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SC-13" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-1" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-10" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-11" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-15" supportedStandardRef="NIST 800-53"/>
                        <standard ref="5.14" supportedStandardRef="OWASP-ASVS-Level-1"/>
                        <standard ref="7.2" supportedStandardRef="OWASP-ASVS-Level-1"/>
                        <standard ref="5.14" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="5.19" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="5.20" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="5.21" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="7.2" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="5.14" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="5.19" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="5.20" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="5.21" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="5.6" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="7.2" supportedStandardRef="OWASP-ASVS-Level-3"/>
                    </standards>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Identify all data input points for the application, for example:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Forms with user input (including hidden fields)&lt;/li&gt; 
 &lt;li&gt;API calls&lt;/li&gt; 
 &lt;li&gt;HTTP Headers&lt;/li&gt; 
 &lt;li&gt;Application states such as ASP Viewstates&lt;/li&gt; 
 &lt;li&gt;Serialized Java objects&lt;/li&gt; 
 &lt;li&gt;Any data structure received&lt;/li&gt; 
 &lt;li&gt;For every input, define accepted input (both syntactic and semantic criteria)&lt;/li&gt; 
 &lt;li&gt;Where possible, define a white-list of accepted input or characters&lt;/li&gt; 
 &lt;li&gt;For each of the inputs, ensure that the data is validated against the whitelists (for example with a regular expression) before being processed.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;To test data validation:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Review the acceptable input criteria, and build test cases that deviate from it (invalid characters, lengths, ranges etc.)&lt;/li&gt; 
 &lt;li&gt;Pass invalid input to the application and review error trapping and handling.&lt;/li&gt; 
 &lt;li&gt;Where unexpected exceptions occur, the application may be vulnerable to attack.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;A number of tools can be used to aid in testing: &lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Directly with your browser and with the Developer Tools&lt;/li&gt; 
 &lt;li&gt;Use a browser extension which allows you to modify the request and responses on the fly (i.e. Tamper Data)&lt;/li&gt; 
 &lt;li&gt;Use a proxy which allows you to modify the request and response on the fly (i.e. OWASP ZAP, Burp, Fiddler, etc.)&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C9" name="Store your environment variables in a secure place." platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Plain text environment variables should not be pushed to code repositories. You can use KMS to encrypt environment variables.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; Step 1: Create the Lambda Function (If you've already created the Lambda function, skip this step)&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Sign in to the AWS Management Console and open the AWS Lambda console at https://console.aws.amazon.com/lambda/.&lt;/li&gt; 
 &lt;li&gt;Choose Create a Lambda function.&lt;/li&gt; 
 &lt;li&gt;In Select blueprint, choose the Author from scratch button.&lt;/li&gt; 
 &lt;li&gt;In Basic information, do the following:&lt;/li&gt; 
 &lt;ul&gt; 
  &lt;li&gt;In Name, specify your Lambda function name.&lt;/li&gt; 
  &lt;li&gt;In Role, choose Choose an existing role.&lt;/li&gt; 
  &lt;li&gt;In Existing role, choose lambda_basic_execution.&lt;/li&gt; 
  &lt;li&gt;Note: If the policy of the execution role does not have the decrypt permission, you will need add it.&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;li&gt;Choose Create function.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;Step 2: Configure the Lambda Function&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Under Configuration, specify the Runtime of your choice.&lt;/li&gt; 
 &lt;li&gt;Under the Lambda function code section you can take advantage of the Edit code inline option to replace the Lambda function handler code with your custom code.&lt;/li&gt; 
 &lt;li&gt;Note the Triggers tab. Under the Triggers page, you can optionally choose a service that automatically triggers your Lambda function by choosing the Add trigger button and then choosing the gray box with ellipses (…) to display a list of available services. For this example, do not configure a trigger and choose Configuration.&lt;/li&gt; 
 &lt;li&gt;Note the Monitoring tab. This page will provide immediate CloudWatch metrics for your Lambda function invocations, as well as links to other helpful guides, including Using AWS X-Ray.&lt;/li&gt; 
 &lt;li&gt;Expand the Environment variables section.&lt;/li&gt; 
 &lt;li&gt;Enter your key-value pair. Expand the Encryption configuration section. Note that Lambda provides a default service key under KMS key to encrypt at rest which encrypts your information after it has been uploaded. If the information you provided is sensitive, you can additionally check the Enable helpers for encryption in transit checkbox and supply a custom key. This masks the value you entered and results in a call to AWS KMS to encrypt the value and return it as Ciphertext. If you haven’t created a KMS key for your account, you will be provided a link to the AWS IAM console to create one. The account must have have encrypt and decrypt permissions for that key. Note that the Encrypt button toggles to Decrypt after you choose it. This affords you the option to update the information. Once you have done that, choose the Encrypt button.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda Environment Variables" url="https://docs.aws.amazon.com/lambda/latest/dg/env_variables.html#env_encrypt"/>
                        <reference name="Using Environment Variables in Lambda functions" url="https://docs.aws.amazon.com/lambda/latest/dg/tutorial-env_console.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>	&lt;p&gt;1. Under Configuration, specify the Runtime of your choice.&lt;br /&gt;
2. Expand the Environment variables section.&lt;br /&gt;
3. Check that the Environment variables are configured well in this section.&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control>
</controls>
<usecases>
<usecase ref="AUTHENTICATION" name="Authentication" desc="" library="">
                    <threats>
<threat ref="CAPEC-115" name="Authentication Bypass" state="Expose" source="MANUAL" owner="" library="">
                            <desc>&lt;p&gt;An attacker gains access to the application, service, or device with the privileges of an authorized or privileged user by evading - or circumventing - an authentication mechanism. The attacker is therefore able to access protected data without authentication ever having taken place. This refers to an attacker gaining access equivalent to an authenticated user without ever going through an authentication procedure. &lt;/p&gt; This is usually the result of the attacker using an unexpected access procedure that does not go through the proper checkpoints where authentication should occur. For example, a web site might assume that all users will click through a given link in order to access secure material and simply authenticate everyone that clicks the link. However, an attacker might be able to reach secured web content by explicitly entering the path to the content rather than clicking through the authentication link, thereby avoiding the check entirely. This attack pattern differs from other authentication attacks in that attacks of this pattern avoid authentication entirely, rather than faking authentication by exploiting flaws or by stealing credentials from legitimate users.</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="ACCESS-CONTROL-CENTRALIZED-AWS-LAMBDA" mitigation="100"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="CWE-592">
                                    <controls>
                                        <control ref="ACCESS-CONTROL-CENTRALIZED-AWS-LAMBDA" mitigation="100"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat><threat ref="AWS-LAMBDA-T4" name="Attackers gain access to the AWS account through leaked credentials" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;By storing your account information or environment variables in a “public” resource or storing them as plain text, attackers can find that information. Attackers will scan GitHub repositories or scrape/crawl files on your resources to find this kind of information.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C8" mitigation="50"/>
                                <control ref="AWS-LAMBDA-C9" mitigation="50"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W8">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C9" mitigation="50"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W7">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C8" mitigation="50"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat><threat ref="AWS-LAMBDA-T13" name="Attackers gain access to a Lambda function through a Cross-site scripting attack on the DynamoDB API" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;Through a Cross-site scripting attack an attacker retrieves credentials. The parameters weren’t validated, resulting in an injection of code to retrieve sensitive data such as as credentials.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="DATA-VAL-GENERIC" mitigation="100"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W20">
                                    <controls>
                                        <control ref="DATA-VAL-GENERIC" mitigation="100"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat>
</threats>
</usecase>
</usecases>
</component>
<component ref="aws-lambda-authoritation" name="AWS Lambda: Authorization" desc="" tags="" position="3" groupName="" library="" diagramPositionX="0" diagramPositionY="0" componentDefinitionRef="">
            <weaknesses>
<weakness ref="AWS-LAMBDA-W10" name="All Lambda functions have the same permissions" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Setting of permissions is done at the function level. Because there could be many functions, the job of configuring permissions on each one is all too often ignored or forgotten, leading to security weak spots.</desc>
                </weakness>
</weaknesses>
<controls>
<control ref="AWS-LAMBDA-C12" name="Configure IAM Role statements on a per-function basis." platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;You should spend time crafting suitable, minimal roles for each of your functions. This leverages the principle of least privilege. If you are using the API Gateway, you can also set Lambda authorizers. A Lambda function should do one specific task, so ensure the following model is followed: One function, one use case, one permission.&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;b&gt; Remediation: &lt;br /&gt;&lt;/b&gt; UsingAWSConsole: &lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Login to theAWSManagement Console.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Navigate to the Lambda dashboard at https://console.aws.amazon.com/lambda/.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;In the navigation panel, underAWSLambda section, choose Functions.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Choose the Lambda function that you want to examine then click on the function name to access its configuration page.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Select the Configuration tab then click the Execution role to expand the panel with theIAMrole that defines the permissions for the selected function.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Copy the name of theIAMexecution role currently available in the Existing role drop-down list.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Now navigate to theIAMdashboard at https://console.aws.amazon.com/iam/.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;In the left navigation panel, choose Roles.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Paste the name of the execution role copied at step no. 6 in the Search box and press Enter.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Click on the AmazonIAMexecution role returned as the result.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;On theIAMrole configuration page, select the Permissions tab from the bottom panel.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Click on the attachedIAMpolicy name available within Policy name column to access the policy document (JSONformat).&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Include inside the {}JSONpanel, the policy document defined for the selectedIAMexecution role.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Add the Action and Resource elements&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;and their current values, if the element values are set to “*”&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;and the Effect is set to “Allow”,the selected Amazon Lambda function has admin privileges (we have to restrict the admin privileges in the Amazon Lambda function)&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Repeat step no. 12 and 13 to add otherIAMpolicies attached to the selected execution role.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Repeat steps no. 4 – 16 to add theIAMexecution role permissions for other Amazon Lambda functions created within the current region.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Change theAWSregion from the navigation bar and repeat the process for the other regions.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda Permissions Model" url="https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html"/>
                        <reference name="Configure Lambda Authorizer Using the API Gateway Console" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/configure-api-gateway-lambda-authorization-with-console.html"/>
                        <reference name="Use API Gateway Lambda Authorizers" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html"/>
                        <reference name="Using Identity-Based Policies (IAM Policies) for AWS Lambda" url="https://docs.aws.amazon.com/lambda/latest/dg/access-control-identity-based.html"/>
                        <reference name="Using Resource-Based Policies for AWS Lambda (Lambda Function Policies)" url="https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;UsingAWSConsole:&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Login to theAWSManagement Console.&lt;/li&gt; 
 &lt;li&gt;Navigate to the Lambda dashboard at https://console.aws.amazon.com/lambda/.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;In the navigation panel, underAWSLambda section, choose Functions.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Choose the Lambda function that you want to examine then click on the function name to access its configuration page.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Select the Configuration tab then click the Execution role to expand the panel with theIAMrole that defines the permissions for the selected function.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Copy the name of theIAMexecution role currently available in the Existing role drop-down list.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Now navigate to theIAMdashboard at https://console.aws.amazon.com/iam/.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;In the left navigation panel, choose Roles.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Paste the name of the execution role copied at step no. 6 in the Search box and press Enter.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Click on the AmazonIAMexecution role returned as the result.&lt;/li&gt; 
 &lt;li&gt;On theIAMrole configuration page, select the Permissions tab from the bottom panel.&lt;/li&gt; 
 &lt;li&gt;Click on the attachedIAMpolicy name available within Policy name column to access the policy document (JSONformat).&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Inside the {}JSONpanel, verify the policy document defined for the selectedIAMexecution role. Identify Action and Resource elements and their current values. If the element values are set to “*” and the Effect is set to “Allow”,the selected Amazon Lambda function has admin privileges&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;&amp;nbsp;Repeat step no. 12 and 13 to verify otherIAMpolicies attached to the selected execution role.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Repeat steps no. 4 - 15 to verify theIAMexecution role permissions for other Amazon Lambda functions created within the current region.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Change theAWSregion from the navigation bar and repeat the process for the other regions.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="Hydras-AWS-IAM-2.8" name="Apply RBAC with pre-defined policies added into groups or roles" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Instead of defining permissions for individual IAM users, it’s usually more convenient to create groups that relate to job functions (administrators, developers, accounting, etc.), define the relevant permissions for each group, and then assign IAM users to those groups. All the users in an IAM group inherit the permissions assigned to the group. That way, you can make changes for everyone in a group in just one place. As people move around in your company, you can simply change what IAM group their IAM user belongs to. This method is know as Role Based Access Control (RBAC).&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; Remove privilege granted directly to a user: &lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Sign in to the AWS Management Console (with IAM update privileges).&lt;/li&gt; 
 &lt;li&gt;Go to IAM Service on the AWS Console.&lt;/li&gt; 
 &lt;li&gt;Click on Users.&lt;/li&gt; 
 &lt;li&gt;For each user complete the following:&lt;/li&gt; 
 &lt;ol&gt; 
  &lt;li&gt;Select the user.&lt;/li&gt; 
  &lt;li&gt;Click on the Permissions tab.&lt;/li&gt; 
  &lt;li&gt;Expand “Managed Policies”.&lt;/li&gt; 
  &lt;li&gt;Click “Detach Policy”.&lt;/li&gt; 
  &lt;li&gt;Expand “Inline Policies”.&lt;/li&gt; 
  &lt;li&gt;Click “Remove Policy”.&lt;/li&gt; 
 &lt;/ol&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;Create a Group and add a user: &lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Sign in to the AWS Management Console (with IAM update privileges).&lt;/li&gt; 
 &lt;li&gt;Go to IAM Service on the AWS Console.&lt;/li&gt; 
 &lt;li&gt;Select Groups and click Create New Group.&lt;/li&gt; 
 &lt;li&gt;In the Group Name box, type the name of the group and click Next Step.&lt;/li&gt; 
 &lt;li&gt;In the list of policies, select the check box for each policy that you want to apply to all members of the group. Click Next Step.&lt;/li&gt; 
 &lt;li&gt;Click Create Group.&lt;/li&gt; 
 &lt;li&gt;Click the new Group and select the “Users” tab.&lt;/li&gt; 
 &lt;li&gt;Click “Add Users to Group”.&lt;/li&gt; 
 &lt;li&gt;Select the users and click “Add Users”.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;Content provided by Hydras IT LTD&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda Permissions Model" url="https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html"/>
                        <reference name="Configure Lambda Authorizer Using the API Gateway Console" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/configure-api-gateway-lambda-authorization-with-console.html"/>
                        <reference name="Use API Gateway Lambda Authorizers" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html"/>
                        <reference name="Using Identity-Based Policies (IAM Policies) for AWS Lambda" url="https://docs.aws.amazon.com/lambda/latest/dg/access-control-identity-based.html"/>
                        <reference name="Using Resource-Based Policies for AWS Lambda (Lambda Function Policies)" url="https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html"/>
                    </references>
                    <standards>
                        <standard ref="1.16" supportedStandardRef="CIS AWS Standard"/>
                        <standard ref="1.22" supportedStandardRef="CIS AWS Standard"/>
                    </standards>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Obtain a list of IAM users by: aws iam list-users --query 'Users[*].UserName' --output text&lt;/li&gt; 
 &lt;li&gt;Run the following to determine if they have policies directly attached:&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt; aws iam list-attached-user-policies --user-name user&lt;/p&gt; 
 &lt;/blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt; aws iam list-user-policies --user-name user&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="Hydras-AWS-IAM-2.7" name="Enforce Least Privilege" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Granting least privilege ensures that users only have the permissions required to complete their jobs rather than additional privileges that are not required. Following this model ensures that, should an account be compromised, the blast radius of damage is limited. &lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;/b&gt;&lt;br /&gt; Allocate privileges via groups or roles via the recommendation in “Use RBAC with pre-defined policies added into groups or roles”.&lt;/p&gt; 
&lt;p&gt;Content provided by Hydras IT LTD&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda Permissions Model" url="https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html"/>
                        <reference name="Configure Lambda Authorizer Using the API Gateway Console" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/configure-api-gateway-lambda-authorization-with-console.html"/>
                        <reference name="Use API Gateway Lambda Authorizers" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html"/>
                        <reference name="Using Identity-Based Policies (IAM Policies) for AWS Lambda" url="https://docs.aws.amazon.com/lambda/latest/dg/access-control-identity-based.html"/>
                        <reference name="Using Resource-Based Policies for AWS Lambda (Lambda Function Policies)" url="https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html"/>
                    </references>
                    <standards>
                        <standard ref="1.22" supportedStandardRef="CIS AWS Standard"/>
                    </standards>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Follow the audit check in “Use RBAC with pre-defined policies added into groups or roles”.&lt;/li&gt; 
 &lt;li&gt;Ensure the privileges granted to these groups or roles only give the user the ability to perform their and no more.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C16" name="Ensure it only exists one user to access to the API gateway" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;The API gateway sits between the Lambda functions and the user. You must create an API gateway user that only has the ability to communicate with Lambda functions. It can only communicate between your internal perimeter. If the user is manipulated to send from a source other than theAPIgateway, access should be denied. You can also set Lambda authorizers in the API Gateway. &lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation: &lt;/b&gt;&lt;br /&gt; Configure the Lambda authorizers on API methods: &lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Sign in to the API Gateway console.&lt;/li&gt; 
 &lt;li&gt;Create an API method and choose Authorizers under that API.&lt;/li&gt; 
 &lt;li&gt;Give the permissions to access to the Lambda Functions only to one user.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="Configure Lambda Authorizer Using the API Gateway Console" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/configure-api-gateway-lambda-authorization-with-console.html"/>
                        <reference name="Set Up an IAM to Invoke Lambda Functions" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/integrating-api-with-aws-services-lambda.html#api-as-lambda-proxy-setup-iam-role-policies"/>
                        <reference name="Use API Gateway Lambda Authorizers" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Verify that Lambda authorizers are configured on API methods:&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Sign in to the API Gateway console.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Select each existing API and choose Authorizers under that API.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Check that it exist only one API gateway user with the permissions to access to the Lambda Functions.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C14" name="Ensure that there is no user in production with the permission to delete permission on any service" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Ensure that there is no user in production that can delete services, functions and perhaps even data. This will ensure that nobody deletes items by accident. If delete actions are required in production, ensure that you have proper guidelines in place to prevent accidental deletion.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; To view a function’s resource-based policy, use the get-policy command.&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda get-policy --function-name my-function --output text&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;For versions and aliases, append the version number or alias to the function name.&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda get-policy --function-name my-function:PROD&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;To remove permissions from your function, use remove-permission.&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda remove-permission --function-name example --statement-id sns&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Use the get-layer-version-policy command to view the permissions on a layer, and remove-layer-version-permission to remove statements from the policy.&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda get-layer-version-policy --layer-name my-layer --version-number 3 --output text&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;aws lambda remove-layer-version-permission --layer-name my-layer --version-number 3 --statement-id engineering-org&lt;/p&gt; 
&lt;/blockquote&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda Permissions Model" url="https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html"/>
                        <reference name="Configure Lambda Authorizer Using the API Gateway Console" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/configure-api-gateway-lambda-authorization-with-console.html"/>
                        <reference name="Use API Gateway Lambda Authorizers" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html"/>
                        <reference name="Using Identity-Based Policies (IAM Policies) for AWS Lambda" url="https://docs.aws.amazon.com/lambda/latest/dg/access-control-identity-based.html"/>
                        <reference name="Using Resource-Based Policies for AWS Lambda (Lambda Function Policies)" url="https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Use the following command to view the remove permission over a certain function:&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda get-layer-version-policy --layer-name my-layer --version-number 3 --output text&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Verify that the command above doesn’t show the permissions defined with “Action”: [“lambda:DeleteFunction”]&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control>
</controls>
<usecases>
<usecase ref="AUTHORIZATION" name="Authorization" desc="" library="">
                    <threats>
<threat ref="CAPEC-122" name="Privilege Abuse" state="Expose" source="MANUAL" owner="" library="">
                            <desc>&lt;p&gt;An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts.&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems – all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C12" mitigation="25"/>
                                <control ref="AWS-LAMBDA-C16" mitigation="25"/>
                                <control ref="Hydras-AWS-IAM-2.7" mitigation="25"/>
                                <control ref="Hydras-AWS-IAM-2.8" mitigation="25"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W10">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C12" mitigation="25"/>
                                        <control ref="AWS-LAMBDA-C16" mitigation="25"/>
                                        <control ref="Hydras-AWS-IAM-2.7" mitigation="25"/>
                                        <control ref="Hydras-AWS-IAM-2.8" mitigation="25"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat><threat ref="CAPEC-233" name="Privilege Escalation" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;An adversary exploits a weakness enabling them to elevate their privilege and perform an action that they are not supposed to be authorized to perform.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C12" mitigation="33"/>
                                <control ref="AWS-LAMBDA-C14" mitigation="33"/>
                                <control ref="Hydras-AWS-IAM-2.7" mitigation="34"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W10">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C12" mitigation="33"/>
                                        <control ref="AWS-LAMBDA-C14" mitigation="33"/>
                                        <control ref="Hydras-AWS-IAM-2.7" mitigation="34"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat>
</threats>
</usecase>
</usecases>
</component>
<component ref="aws-lambda-denial-of-service" name="AWS Lambda: Denial-of-Service / Wallet" desc="" tags="" position="4" groupName="" library="" diagramPositionX="0" diagramPositionY="0" componentDefinitionRef="">
            <weaknesses>
<weakness ref="AWS-LAMBDA-W15" name="Functions consume too much memory" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Default limits and poor configuration can lead to successful DDoS attacks.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W18" name="The retry mechanism of asynchronous sources are not configured correctly" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Asynchronous events (e.g. S3, SNS, SES, CloudWatch Events, etc.) uses queues before invoking, so retry behavior must be taken in account.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W17" name="Functions take too long to execute" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>The function is taken too long to execute. This could be because the function is doing too much or recursive patterns are used.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W19" name="No validation for asynchronous events" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Lambda can handle several different event types that can trigger a serverless function. These event types don't necessarily need to be HTTP requests (e.g. S3, SNS, SES, CloudWatch Events, etc.). This increases the potential attack surface and introduces complexities to secure the serverless functions.</desc>
                </weakness><weakness ref="AWS-VPC-IP-ADDRESS-DEPLETION-WEAKNESS" name="AWS VPC IP address depletion" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Organizations that deploy AWS Lambda functions in VPC (Virtual Private Cloud) environments should also pay attention to the potential exhaustion of IP addresses in the VPC subnet.  
 An attacker might cause a denial of service scenario by forcing more and more function instances to execute, and deplete the VPC subnet from available IP addresses.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W14" name="Functions have poor concurrency limits" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>If your concurrency limits are too small, scaling will not be as flexible as you would like. If your concurrency limits are too high, DoS could be a problem.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W16" name="Functions don’t have a rate limit or aren’t throttled" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>An attacker can try to freeze the system with huge amounts of requests. 
 If your concurrency limits are set and high, an attacker can still execute a lot of requests and it will cost you a lot of money. It's important to set some limits on services or functions.</desc>
                </weakness>
</weaknesses>
<controls>
<control ref="AWS-LAMBDA-C24" name="Use the API gateway Plans to throttle incoming API calls or rate limit the requests" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Throttling or rate limiting will limit the rate of transactions passing through the API Gateway. When limits are exceeded the API gateway will respond with a HTTP response error code. There are several possibilities to set throttling but the use of an API key and usage plan is a best practice.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;/b&gt;&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;In the Amazon API Gateway main navigation pane, choose Usage Plans, and then choose Create.&lt;/li&gt; 
 &lt;li&gt;Under Create Usage Plan, do the following:&lt;/li&gt; 
 &lt;ol&gt; 
  &lt;li&gt;For Name, type a name for your plan (for example, Plan_A).&lt;/li&gt; 
  &lt;li&gt;For Description, type a description for your plan.&amp;nbsp;&lt;/li&gt; 
  &lt;li&gt;Select Enable throttling, and set Rate (for example, 100) and Burst (for example, 200).&lt;/li&gt; 
  &lt;li&gt;Choose Enable quota, and set its limit (for example, 5000) for a selected time interval (for example, Month).&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;li&gt;To add a stage to the plan, do the following in the Associated API Stages pane:&lt;/li&gt; 
 &lt;ol&gt; 
  &lt;li&gt;Choose Add API Stage.&lt;/li&gt; 
  &lt;li&gt;Choose an API (for example, PetStore) from the API drop-down list.&lt;/li&gt; 
  &lt;li&gt;Choose a stage (for example, Stage_1) from the Stage drop-down list.&lt;/li&gt; 
  &lt;li&gt;Choose the checkmark icon to save.&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;li&gt;To configure method throttling, do the following:&lt;/li&gt; 
 &lt;ol&gt; 
  &lt;li&gt;Choose Configure Method Throttling.&lt;/li&gt; 
  &lt;li&gt;Choose Add Resource/Method.&lt;/li&gt; 
  &lt;li&gt;Choose the resource from the Resource drop-down menu.&lt;/li&gt; 
  &lt;li&gt;Choose the method from the Method drop-down menu.&lt;/li&gt; 
  &lt;li&gt;Set Rate (requests per second) (for example, 100) and Burst (for example, 200).&lt;/li&gt; 
  &lt;li&gt;Choose the checkmark icon to save.&lt;/li&gt; 
  &lt;li&gt;Choose Close.&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;li&gt;To add a key to the plan, do the following in the API Keys tab:&lt;/li&gt; 
 &lt;ol&gt; 
  &lt;li&gt;To use an existing key, choose Add API Key to Usage Plan.&lt;/li&gt; 
  &lt;li&gt;For Name, type a name for the key you want to add (for example, MyFirstKey).&lt;/li&gt; 
  &lt;li&gt;Choose the checkmark icon to save.&lt;/li&gt; 
 &lt;/ol&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;As needed, repeat the preceding steps to add other existing API keys to this usage plan.&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS API gateway Limits" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/limits.html"/>
                        <reference name="Create and Use Usage Plans with API Keys" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html"/>
                        <reference name="Create, Configure, and Test Usage Plans Using the API Gateway CLI and REST API" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-usage-plans-with-rest-api.html"/>
                        <reference name="Create, Configure, and Test Usage Plans with the API Gateway Console" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-usage-plans-with-console.html"/>
                        <reference name="Throttle API Requests for Better Throughput" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Check that all API Gateway Plans are configured well.&lt;/li&gt; 
 &lt;li&gt;Go to the API Gateway main navigation pane, choose Usage Plans.&lt;/li&gt; 
 &lt;li&gt;Choose a usage plan from the list of usage plans.&lt;/li&gt; 
 &lt;li&gt;From within the specified plan, choose API Keys.&lt;/li&gt; 
 &lt;li&gt;Choose an API key, and then choose Usage to view Subscriber’s Traffic from the plan you’re monitoring, and verify that all works well&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C20" name="Change the default memory usage to the amount of memory the function really needs" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Specify the amount of memory you want to allocate for your Lambda function. CloudWatch logs can contain memory usage on each function execution. Set the default memory usage to the amount of memory that the function really needs. By default, it set to of 1024 MB.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; Update the memory size of your functions using the following AWS CLI command:&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda update-function-configuration --function-name myfunction --memory-size 256&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;In the example, we change the amount memory for the function to 256 MB.&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda Limits" url="https://docs.aws.amazon.com/lambda/latest/dg/limits.html"/>
                        <reference name="Best practices for AWS Lambda timeouts" url="http://blog.epsagon.com/best-practices-for-aws-lambda-timeouts"/>
                        <reference name="Function configuration" url="https://docs.aws.amazon.com/lambda/latest/dg/resource-model.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Open the AWS Lambda console at https://console.aws.amazon.com/lambda/.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Choose a function.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Settings are on the first page shown.&lt;/li&gt; 
 &lt;li&gt;Check that each function has got the really necessary amount of memory.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C22" name="Set a concurrency limits for your functions" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Lambda provides a concurrent execution limit control at both the account level and the function level. By default, AWS Lambda limits the total concurrent executions across all functions within a given region to 1000. The function level concurrent execution limit is by default enforced against the sum of the concurrent executions of all functions.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; To set a concurrency limit for your Lambda function using the AWS CLI, do the following:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Use the PutFunctionConcurrency operation and pass in the function name and concurrency limit you want allocated to this function:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt; aws lambda put-function-concurrency --function-name function-name --reserved-concurrent-executions limit value&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="Managing Concurrency" url="https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html"/>
                        <reference name="Set Concurrency Limits on Individual AWS Lambda Functions" url="https://aws.amazon.com/about-aws/whats-new/2017/11/set-concurrency-limits-on-individual-aws-lambda-functions/"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Use AWS CLI and use the following command to view the concurrency limit per function:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt;aws lambda get-function --function-name function-name&amp;nbsp;&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Check all function and verify that they have got set a well the concurrency limit.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C25" name="Set time-outs on invocations of functions" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;To prevent your Lambda function from running indefinitely, you specify a timeout. You shall set this value based on your expected execution time. The default for functions created in the console is 3 seconds. To ensure that you write clean code also verify that the termination criteria are met every time to prevent endless or long invocations.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Update the timeout of your functions using the following AWS CLI command:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt;aws lambda update-function-configuration --function-name myfunction --timeout 3&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;In the example, we change the timeout limit to 3 seconds&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda Limits" url="https://docs.aws.amazon.com/lambda/latest/dg/limits.html"/>
                        <reference name="Best practices for AWS Lambda timeouts" url="http://blog.epsagon.com/best-practices-for-aws-lambda-timeouts"/>
                        <reference name="Function configuration" url="https://docs.aws.amazon.com/lambda/latest/dg/resource-model.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Use AWS CLI and use the following command to view the timeout limit per function:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt;aws lambda get-function --function-name function-name&amp;nbsp;&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Check all function and verify that they have got set a well the timeout limit.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-IP-ADDRESSES-VPC" name="Ensure that your VPC Lambda subnet has enough IP addresses to scale" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;The subnets you specify should have sufficient available IP addresses to match the number of ENIs. If your VPC does not have sufficient ENIs or subnet IPs, your Lambda function will not scale as requests increase, and you will see an increase in invocation errors with EC2 error types like EC2ThrottledException. For asynchronous invocation, if you see an increase in errors without corresponding CloudWatch Logs, invoke the Lambda function synchronously in the console to get the error responses. &lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; Review each function and verify that each function has got at least one associated subnet Id with the following command:&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda get-function --function-name &lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;If there is any function without associated Subnet Id, we can update the function and assign a subnet with the following command:&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda update-function-configuration --function-name --vpc-config &lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see VPC Settings .&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; Shorthand Syntax:&lt;/p&gt; 
 &lt;p&gt;SubnetIds=string,string,SecurityGroupIds=string,string&lt;/p&gt; 
 &lt;p&gt; JSON Syntax:&lt;/p&gt; 
 &lt;p&gt;{ “SubnetIds”: [“string”, …], “SecurityGroupIds”: [“string”, …]&lt;/p&gt; 
 &lt;p&gt; }&lt;/p&gt; 
&lt;/blockquote&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda get function" url="https://docs.aws.amazon.com/cli/latest/reference/lambda/get-function.html#output"/>
                        <reference name="AWS Lambda update function configuration" url="https://docs.aws.amazon.com/cli/latest/reference/lambda/update-function-configuration.html"/>
                        <reference name="Configuring a Lambda Function to Access Resources in an Amazon VPC" url="https://docs.aws.amazon.com/lambda/latest/dg/vpc.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Check that all functions have got at least one associate VPN subnet with the following command:&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda get-function --function-name &lt;/p&gt; 
&lt;/blockquote&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-SUBNET-AVAILABILITY-ZONE" name="Ensure that each Lambda Function has got at least one VPC subnet in each Availability Zone" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;By specifying subnets in each of the Availability Zones, your Lambda function can run in another Availability Zone if one goes down or runs out of IP addresses.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; Review each function and verify that each function has got at least one associated subnet Id in different Availability Zone with the following command:&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;aws lambda get-function --function-name&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;If there is any function without associated Subnet Id per Availability Zone, we can update the Lambda function and assign a subnet from a specific Availability Zone with the following command:&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda update-function-configuration --function-name --vpc-config &lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see VPC Settings .&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; Shorthand Syntax:&lt;/p&gt; 
 &lt;p&gt;SubnetIds=string,string,SecurityGroupIds=string,string&lt;/p&gt; 
 &lt;p&gt; JSON Syntax:&lt;/p&gt; 
 &lt;p&gt;{ “SubnetIds”: [“string”, …], “SecurityGroupIds”: [“string”, …]&lt;/p&gt; 
 &lt;p&gt; }&lt;/p&gt; 
&lt;/blockquote&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda get function" url="https://docs.aws.amazon.com/cli/latest/reference/lambda/get-function.html#output"/>
                        <reference name="AWS Lambda update function configuration" url="https://docs.aws.amazon.com/cli/latest/reference/lambda/update-function-configuration.html"/>
                        <reference name="Configuring a Lambda Function to Access Resources in an Amazon VPC" url="https://docs.aws.amazon.com/lambda/latest/dg/vpc.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Check that all Lambda functions have got at least one associate VPN subnet per Availability Zone with the following command:&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda get-function --function-name &lt;/p&gt; 
&lt;/blockquote&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C23" name="Use a profiler tool to improve the application" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>	&lt;p&gt;When using a profiler tool, the execution of your functions are monitored. It will reveal which functions are called, number of invocations, execution times, memory usage and CPU use.&lt;/p&gt;

	&lt;p&gt;You can use it to find and identify bottlenecks and address them. Therefore, you shall use a profiler tool to improve the time of use, memory usage and CPU usage of the function.&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda Limits" url="https://docs.aws.amazon.com/lambda/latest/dg/limits.html"/>
                        <reference name="Best practices for AWS Lambda timeouts" url="http://blog.epsagon.com/best-practices-for-aws-lambda-timeouts"/>
                        <reference name="Function configuration" url="https://docs.aws.amazon.com/lambda/latest/dg/resource-model.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>	&lt;p&gt;Check that a profiler tool is used to improve the Lambda function.&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C26" name="Configurate the retry settings of asynchronous sources" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Any Lambda function invoked asynchronously is retried twice before the event is discarded. If the retries fail and you’re unsure why, use Dead Letter Queues (DLQ) to direct unprocessed events to an Amazon SQS queue or an Amazon SNS topic to analyze the failure.&lt;/p&gt; 
&lt;p&gt;AWS Lambda directs events that cannot be processed to the specified Amazon SNS topic or Amazon SQS queue. Functions that don’t specify a DLQ will discard events after they have exhausted their retries. For more information about retry policies, see AWS Lambda Retry Behavior.&lt;/p&gt; 
&lt;p&gt;You configure a DLQ by specifying the Amazon Resource Name TargetArn value on the Lambda function’s DeadLetterConfig parameter.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; Update the timeout of your functions using the following AWS CLI command:&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda update-function-configuration --function-name myfunction --dead-letter-config (structure)&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead Letter Queues in the references.&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; Shorthand Syntax:&lt;/p&gt; 
 &lt;p&gt; TargetArn=string&lt;/p&gt; 
 &lt;p&gt; JSON Syntax:&lt;/p&gt; 
 &lt;p&gt;{ “TargetArn”: “string”&lt;/p&gt; 
 &lt;p&gt; }&lt;/p&gt; 
&lt;/blockquote&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS CLI update-function-configuration" url="https://docs.aws.amazon.com/cli/latest/reference/lambda/update-function-configuration.html"/>
                        <reference name="AWS Lambda Retry Behavior" url="https://docs.aws.amazon.com/lambda/latest/dg/retries-on-errors.html"/>
                        <reference name="Dead Letter Queue" url="https://docs.aws.amazon.com/lambda/latest/dg/dlq.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Use AWS CLI and use the following command to view the timeout limit per function:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt;aws lambda get-function --function-name function-name&amp;nbsp;&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Check all function and verify that they have got set a well the timeout limit.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C11" name="Enable and set up Request Validation in API Gateway" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;To perform the API Gateway basic validation, we have to enable and set up the Request Validation in the API Gateway.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; To enable basic validation, you specify validation rules in a request validator, add the validator to the API’s map of request validators, and assign the validator to individual API methods.&lt;/p&gt; 
&lt;p&gt;To set up a basic validation, we have some possibilities to configure it:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;by Importing OpenAPI Definition&lt;/li&gt; 
 &lt;li&gt;using the API Gateway REST API&lt;/li&gt; 
 &lt;li&gt;using the API Gateway Console&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;Using the API Gateway Console:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;The API Gateway console lets you set up the basic request validation on a method using one of the three validators:&lt;/li&gt; 
 &lt;ul&gt; 
  &lt;li&gt;Validate body: This is the body-only validator.&lt;/li&gt; 
  &lt;li&gt;Validate query string parameters and headers: This is the parameters-only validator.&lt;/li&gt; 
  &lt;li&gt;Validate body, query string parameters, and headers: This validator is for both body and parameters validation.&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;li&gt;When you choose one of the above validators to enable it on an API method, the API Gateway console will add the validator to the API’s RequestValidators map, if the validator has not already been added to the validators map of the API. To enable a request validator on a method:&lt;/li&gt; 
 &lt;ol&gt; 
  &lt;li&gt;Sign in to the API Gateway console, if not already logged in.&lt;/li&gt; 
  &lt;li&gt;Create a new or choose an existing API.&lt;/li&gt; 
  &lt;li&gt;Create a new or choose an existing resource of the API.&lt;/li&gt; 
  &lt;li&gt;Create a new or choose an existing method the resource.&lt;/li&gt; 
  &lt;li&gt;Choose Method Request.&lt;/li&gt; 
  &lt;li&gt;Choose the pencil icon of Request Validator under Settings.&lt;/li&gt; 
  &lt;li&gt;Choose Validate body, Validate query string parameters and headers or Validate body, query string parameters, and headers from the Request Validator drop-down list and then choose the check mark icon to save your choice.&lt;/li&gt; 
 &lt;/ol&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;For more information see the references.&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="Enable Request Validation in API Gateway" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html"/>
                        <reference name="Set up Basic Request Validation in API Gateway" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-validation-set-up.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>	&lt;p&gt;Verify in the code if input parameters for functions are validated&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control>
</controls>
<usecases>
<usecase ref="GENERAL" name="General" desc="" library="">
                    <threats>
<threat ref="AWS-LAMBDA-T12" name="Attackers force to increase the Amazon billing through overloading the resources" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;One of the principles of Lambda functions is that you pay for the amount of time your code is running. This pushes the developer to write efficient code. Efficient code should also be limited in execution time. An attacker could try to force services to overload resources and push the boundaries.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C11" mitigation="20"/>
                                <control ref="AWS-LAMBDA-C22" mitigation="20"/>
                                <control ref="AWS-LAMBDA-C24" mitigation="20"/>
                                <control ref="AWS-LAMBDA-C25" mitigation="20"/>
                                <control ref="AWS-LAMBDA-C26" mitigation="20"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W16">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C22" mitigation="20"/>
                                        <control ref="AWS-LAMBDA-C24" mitigation="20"/>
                                        <control ref="AWS-LAMBDA-C25" mitigation="20"/>
                                        <control ref="AWS-LAMBDA-C26" mitigation="20"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W19">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C11" mitigation="20"/>
                                        <control ref="AWS-LAMBDA-C26" mitigation="20"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat><threat ref="CAPEC-130" name="Excessive Allocation" state="Expose" source="MANUAL" owner="" library="">
                            <desc>&lt;p&gt;An adversary causes the target to allocate excessive resources to servicing the attackers’ request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources.&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C20" mitigation="13"/>
                                <control ref="AWS-LAMBDA-C22" mitigation="13"/>
                                <control ref="AWS-LAMBDA-C23" mitigation="13"/>
                                <control ref="AWS-LAMBDA-C24" mitigation="13"/>
                                <control ref="AWS-LAMBDA-C25" mitigation="12"/>
                                <control ref="AWS-LAMBDA-C26" mitigation="12"/>
                                <control ref="AWS-LAMBDA-IP-ADDRESSES-VPC" mitigation="12"/>
                                <control ref="AWS-LAMBDA-SUBNET-AVAILABILITY-ZONE" mitigation="12"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-VPC-IP-ADDRESS-DEPLETION-WEAKNESS">
                                    <controls>
                                        <control ref="AWS-LAMBDA-IP-ADDRESSES-VPC" mitigation="12"/>
                                        <control ref="AWS-LAMBDA-SUBNET-AVAILABILITY-ZONE" mitigation="12"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W15">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C20" mitigation="13"/>
                                        <control ref="AWS-LAMBDA-C23" mitigation="13"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W16">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C22" mitigation="13"/>
                                        <control ref="AWS-LAMBDA-C24" mitigation="13"/>
                                        <control ref="AWS-LAMBDA-C25" mitigation="12"/>
                                        <control ref="AWS-LAMBDA-C26" mitigation="12"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W14">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C22" mitigation="13"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W17">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C25" mitigation="12"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W18">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C26" mitigation="12"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat>
</threats>
</usecase>
</usecases>
</component>
<component ref="aws-lambda-tampering" name="AWS Lambda: Tampering" desc="" tags="" position="8" groupName="" library="" diagramPositionX="0" diagramPositionY="0" componentDefinitionRef="">
            <weaknesses>
<weakness ref="AWS-LAMBDA-W9" name="The function takes untrusted input" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Developers should avoid writing code that passes user-controlled input to dangerous functions. This is one of the basics of secure programming. Whenever a function has the capability to execute a dangerous action, it should either not receive user input, or the user-controlled data should be sanitized in order to prevent a malicious user from breaking the intended functionality.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W11" name="The container has processes, pieces of code or temporary files lingering around." state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Container lifetime is important, but also the correct execution and cleanup of your functions. If the container has lingering temporary files or - for example - static data in memory, an attacker could steal this information and leverage it for building a more destructive attack.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W4" name="Data in transit is sent using a weak encryption algorithm" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>When the SSL/TLS service is present this is good but does introduce complexities that must be overcome:&amp;nbsp; 
&lt;div&gt; 
 &lt;ol&gt; 
  &lt;li&gt;SSL/TLS protocols, ciphers, keys and renegotiation must be properly configured.&amp;nbsp;&lt;/li&gt; 
  &lt;li&gt;Certificate validity must be ensured.&lt;/li&gt; 
 &lt;/ol&gt; 
&lt;/div&gt;</desc>
                </weakness><weakness ref="AWS-LAMBDA-W3" name="Data in transit was sent via an unencrypted protocol" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Sensitive data must be protected when it is transmitted through the network. Currently the security best practice is to send any data over an encrypted channel. As a rule of thumb if data must be protected when it is stored, this data must also be protected during transmission.&amp;nbsp; 
&lt;div&gt; 
 &lt;br /&gt; 
&lt;/div&gt; 
&lt;div&gt;
  Some examples of sensitive data include:&amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;ol&gt; 
  &lt;li&gt;Information used in authentication (e.g. Credentials, PINs, Session identifiers, Tokens, Cookies…)&amp;nbsp;&lt;/li&gt; 
  &lt;li&gt;Information protected by laws, regulations or specific organizational policy (e.g. Credit Cards, Customers data)&lt;/li&gt; 
 &lt;/ol&gt; 
&lt;/div&gt;</desc>
                </weakness><weakness ref="AWS-LAMBDA-W12" name="Containers aren’t monitored" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Monitoring is needed to understand the relationships between all of the objects across a virtual environment’s topology, recognize the difference between inconsequential anomalies and actual performance problems. This will show you the root cause and recommended actions for remediation. This way, you can understand what needs your attention, and how to narrow a problem to the relevant components.</desc>
                </weakness>
</weaknesses>
<controls>
<control ref="Hydras-AWS-S3-7.3" name="Enforce HTTPS for sensitive information" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>	&lt;p&gt;Amazon Simple Storage Service is storage for the Internet. It is designed to make web-scale computing easier for developers. &lt;/p&gt;

	&lt;p&gt;Amazon S3 has a simple web services interface that you can use to store and retrieve any amount of data, at any time, from anywhere on the web. It gives any developer access to the same highly scalable, reliable, fast, inexpensive data storage infrastructure that Amazon uses to run its own global network of web sites. &lt;/p&gt;

	&lt;p&gt;To ensure that data is only accessible via HTTPS (as opposed to both HTTP and HTTPS) it is possible to add a condition to the S3 bucket policy. It is recommended to enable this for any bucket containing sensitive data to ensure that data is encrypted in transit.&lt;/p&gt;

	&lt;p&gt;Remediation:&lt;br /&gt;
The following is an example of how to create an S3 bucket policy that enforces HTTPS/SSL only:&lt;br /&gt;
1. Sign in to the AWS Management Console (with S3 update privileges) &lt;br /&gt;
2. Go to the S3 Service on the AWS Console &lt;br /&gt;
3. Select a bucket under &amp;#8220;All buckets&amp;#8221; &lt;br /&gt;
4. Click the properties tab &lt;br /&gt;
5. Under the permissions select &amp;#8220;Add a bucket policy&amp;#8221; &lt;br /&gt;
6. Add the following policy to ensure all objects are accessed via https only &lt;br /&gt;
{&lt;br /&gt;
&lt;a href="%5B"&gt;Statement&lt;/a&gt; {&lt;br /&gt;
&amp;#8220;Action&amp;#8221;: &amp;#8220;s3:*&amp;#8221;,&lt;br /&gt;
&lt;a href=""&gt;Effect&lt;/a&gt;&amp;#8220;Allow&amp;#8221;,&lt;br /&gt;
&amp;#8220;Principal&amp;#8221;: &amp;#8220;*&amp;#8221;,&lt;br /&gt;
&lt;a href=""&gt;Resource&lt;/a&gt;&amp;#8220;arn:aws:s3:::bucketname/*&amp;#8221;,&lt;br /&gt;
&lt;a href="%7B"&gt;Condition&lt;/a&gt;&lt;br /&gt;
&amp;#8220;Bool&amp;#8221;:&lt;br /&gt;
{ &lt;br /&gt;
&amp;#8220;aws:SecureTransport&amp;#8221;: true &lt;br /&gt;
}&lt;br /&gt;
}&lt;br /&gt;
} ]&lt;br /&gt;
}&lt;br /&gt;
7. Click &amp;#8220;&amp;#8220;Save&amp;#8221; &lt;/p&gt;

	&lt;p&gt;Content provided by Hydras IT LTD&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="Configure an API to Use SSL Certificates" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html#configure-api"/>
                        <reference name="Use Client-Side SSL Certificates for Authentication by the Backend" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;The following verifies that HTTPS is forced on a bucket policy: &lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Sign in to the AWS Management Console (with S3 update privileges).&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Go to the S3 Service on the AWS Console.&lt;/li&gt; 
 &lt;li&gt;Select the S3 bucket under “All buckets”.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Click the “properties” tab.&lt;/li&gt; 
 &lt;li&gt;Click “edit bucket policy”.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;In the policy document check for the presence of the line “Condition”: {“Bool”: {“aws:SecureTransport”: “true”}}&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;In the same statement as &lt;a&gt;Effect&lt;/a&gt;“Allow”,&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="aws-tier-1.17" name="Ensure CloudFront to Origin connection is configured using TLS1.1+ as the SSL\TLS protocol" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;CloudFront can connect to your origin using only HTTP, only HTTPS, or to connect by matching the protocol used by the viewer. Our recommendation is to use HTTPS only. In this case you can choose which SSL\TLS protocols CloudFront is allowed to use when establishing an HTTPS connection to your origin. Ensure that you are using only TLS1.1+ as the SSL\TLS protocol.&lt;/p&gt; 
&lt;p&gt;It used to be believed that TLS v1 was marginally more secure than SSL v3.0, its predecessor. However, developments, such as the POODLE vulnerability have shown that SSL v3.0 is now insecure.&lt;/p&gt; 
&lt;p&gt;Subsequent versions of TLS v1.1 and v1.2 are significantly more secure and fix many vulnerabilities present in SSL v3.0 and TLS v1. For example, the BEAST attack that can completely break web sites running on older SSL v3.0 and TLS v1 protocols. The newer TLS versions, if properly configured, prevent the BEAST and other attack vectors and provide many stronger ciphers and encryption methods.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; Using the Amazon unified command line interface:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;For configuring Origin SSL protocols first save locally the current distribution config:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt; aws cloudfront get-distribution-config --id --query “DistributionConfig” &amp;gt; /tmp/cf-distribution.json&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Edit and replace “OriginSslProtocols” element in /tmp/cf-distribution.json with the below section:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt; “OriginSslProtocols”: { “Items”: [ “TLSv1.1”, “TLSv1.2” ], “Quantity”: 2},&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Retrieve the current ETag of your CloudFront distribution:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt; aws cloudfront get-distribution-config --id --query “ETag”&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Update the CloudFront distribution using the edited config and the above Etag:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt; aws cloudfront update-distribution --id --distribution-config file:///tmp/cf-distribution.json --if-match &lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="Amazon CloudFront Adds New Origin Security Features" url="https://aws.amazon.com/about-aws/whats-new/2016/01/amazon-cloudfront-adds-new-origin-security-features/"/>
                        <reference name="AWS CLI get-distribution" url="http://docs.aws.amazon.com/cli/latest/reference/cloudfront/get-distribution.html"/>
                        <reference name="AWS CLI update-distribution" url="http://docs.aws.amazon.com/cli/latest/reference/cloudfront/update-distribution.html"/>
                    </references>
                    <standards>
                        <standard ref="1.17" supportedStandardRef="cis-amazon-web-services-three-tier-web-architecture-benchmark"/>
                    </standards>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Using the Amazon unified command line interface:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Check the “OriginSslProtocols” used by application Cloudfront distributions (only TLSv1.1 and TLSv1.2 should be present):&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt; aws cloudfront list-distributions --query “DistributionList.Items].{Id:Id, OriginSslProtocols:Origins.Items[.CustomOriginConfig.OriginSslProtocols.Items[*]}” &lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C20" name="Change the default memory usage to the amount of memory the function really needs" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Specify the amount of memory you want to allocate for your Lambda function. CloudWatch logs can contain memory usage on each function execution. Set the default memory usage to the amount of memory that the function really needs. By default, it set to of 1024 MB.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; Update the memory size of your functions using the following AWS CLI command:&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; aws lambda update-function-configuration --function-name myfunction --memory-size 256&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;In the example, we change the amount memory for the function to 256 MB.&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda Limits" url="https://docs.aws.amazon.com/lambda/latest/dg/limits.html"/>
                        <reference name="Best practices for AWS Lambda timeouts" url="http://blog.epsagon.com/best-practices-for-aws-lambda-timeouts"/>
                        <reference name="Function configuration" url="https://docs.aws.amazon.com/lambda/latest/dg/resource-model.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Open the AWS Lambda console at https://console.aws.amazon.com/lambda/.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Choose a function.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Settings are on the first page shown.&lt;/li&gt; 
 &lt;li&gt;Check that each function has got the really necessary amount of memory.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="DATA-VAL-GENERIC" name="Validate all data received" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;All data received shall be considered tainted and a potential risk, regardless of the source or transport method. For example, while hidden form fields, cookies, or other headers may be obfuscated from a user, along with parameters passed in ViewStates or other encapsulated forms, these can be modified by the user on the client-side in memory, or in transit on the network. Similarly, data passed from binary or compiled components can be modified in situ or in transit. &lt;/p&gt; 
&lt;p&gt;Furthermore, encryption only secures the data in transit between the two ends of the encrypted tunnel (one end of which is typically controlled by the client); data passing through the link may still be malicious.&lt;/p&gt; 
&lt;p&gt;As such, all data received must be subjected to strict validation, sanitization, and encoding against expected syntactic and semantic criteria.&lt;/p&gt; 
&lt;p&gt; Define a specification of the data that is expected at each input; both the syntax (e.g. alphanumeric only) and semantics (e.g. a word of between 1 and 25 characters, or a specific list). As an example of business rule logic, “boat” may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as “red” or “blue.”&lt;br /&gt; Implement a ‘known good’ or white-list approach, where only inputs that meet the strict criteria for each input are accepted, and reject, transform, or encapsulate any non-compliant data.&lt;/p&gt; 
&lt;p&gt; While useful for identifying malicious content, do not rely on looking for specific malformed or attack payloads (blacklists). It is almost impossible to maintain a comprehensive and accurate blacklist due to the complexity and evolving nature of attacks, opportunities to obfuscate payloads, and changes to the code’s execution environment. As noted, blacklists can be useful for detecting and logging potential attacks, or determining which inputs are so malformed that they should be rejected outright.&amp;nbsp;&lt;/p&gt; 
&lt;p&gt; Validate all data received from the client, including values such as HTTP headers and cookie values if these are used as input on the server side, X- headers, and other platform specific data objects passed between the client and server.&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="Enable Request Validation in API Gateway" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html"/>
                        <reference name="OWASP Input Validation Cheat Sheet" url="https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet"/>
                        <reference name="OWASP Testing for Input Validation" url="https://www.owasp.org/index.php/Testing_for_Input_Validation"/>
                    </references>
                    <standards>
                        <standard ref="12.2.1" supportedStandardRef="ISO/IEC 27002:2013"/>
                        <standard ref="12.6.1" supportedStandardRef="ISO/IEC 27002:2013"/>
                        <standard ref="CA-8" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SC-13" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-1" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-10" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-11" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SI-15" supportedStandardRef="NIST 800-53"/>
                        <standard ref="5.14" supportedStandardRef="OWASP-ASVS-Level-1"/>
                        <standard ref="7.2" supportedStandardRef="OWASP-ASVS-Level-1"/>
                        <standard ref="5.14" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="5.19" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="5.20" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="5.21" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="7.2" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="5.14" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="5.19" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="5.20" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="5.21" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="5.6" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="7.2" supportedStandardRef="OWASP-ASVS-Level-3"/>
                    </standards>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Identify all data input points for the application, for example:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Forms with user input (including hidden fields)&lt;/li&gt; 
 &lt;li&gt;API calls&lt;/li&gt; 
 &lt;li&gt;HTTP Headers&lt;/li&gt; 
 &lt;li&gt;Application states such as ASP Viewstates&lt;/li&gt; 
 &lt;li&gt;Serialized Java objects&lt;/li&gt; 
 &lt;li&gt;Any data structure received&lt;/li&gt; 
 &lt;li&gt;For every input, define accepted input (both syntactic and semantic criteria)&lt;/li&gt; 
 &lt;li&gt;Where possible, define a white-list of accepted input or characters&lt;/li&gt; 
 &lt;li&gt;For each of the inputs, ensure that the data is validated against the whitelists (for example with a regular expression) before being processed.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;To test data validation:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Review the acceptable input criteria, and build test cases that deviate from it (invalid characters, lengths, ranges etc.)&lt;/li&gt; 
 &lt;li&gt;Pass invalid input to the application and review error trapping and handling.&lt;/li&gt; 
 &lt;li&gt;Where unexpected exceptions occur, the application may be vulnerable to attack.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;A number of tools can be used to aid in testing: &lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Directly with your browser and with the Developer Tools&lt;/li&gt; 
 &lt;li&gt;Use a browser extension which allows you to modify the request and responses on the fly (i.e. Tamper Data)&lt;/li&gt; 
 &lt;li&gt;Use a proxy which allows you to modify the request and response on the fly (i.e. OWASP ZAP, Burp, Fiddler, etc.)&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C17" name="Limit the lifetime of your containers" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Ensure that your containers and functions lifecycles are handled correctly and no lingering processes exist.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; Use CloudWatch metrics to view the number of tasks in your services that are in the RUNNING state and set a CloudWatch alarm for this metric to alert you if the number of running tasks in your service falls below a specified value.&lt;/p&gt; 
&lt;p&gt; To view the number of running tasks in a service&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Open the CloudWatch console at https://console.aws.amazon.com/cloudwatch/.&lt;/li&gt; 
 &lt;li&gt;On the navigation pane, choose Metrics.&lt;/li&gt; 
 &lt;li&gt;On the All metrics tab, choose ECS.&lt;/li&gt; 
 &lt;li&gt;Choose ClusterName, ServiceName and then choose any metric (either CPUUtilization or MemoryUtilization) that corresponds to the service to view running tasks in.&lt;/li&gt; 
 &lt;li&gt;On the Graphed metrics tab, change Period to 1 Minute and Statistic to Sample Count.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;To create a CloudWatch alarm on a metric&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Open the CloudWatch console at https://console.aws.amazon.com/cloudwatch/.&lt;/li&gt; 
 &lt;li&gt;On the left navigation, choose Alarms, Create Alarm.&lt;/li&gt; 
 &lt;li&gt;In the CloudWatch Metrics by Category section, choose ECS Metrics &amp;gt; ClusterName.&lt;/li&gt; 
 &lt;li&gt;On the Modify Alarm page, choose the MemoryReservation metric for the default cluster and choose Next.&lt;/li&gt; 
 &lt;li&gt;In the Alarm Threshold section, enter a name and description for your alarm.&lt;/li&gt; 
 &lt;li&gt;Set the threshold and time period requirement to MemoryReservation greater than 75% for 1 period.&lt;/li&gt; 
 &lt;li&gt;Configure a notification to send when the alarm is triggered. You can also choose to delete the notification if you don’t want to configure one now.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Step 1: Create a CloudWatch Alarm for a Metric" url="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cloudwatch_alarm_autoscaling.html"/>
                        <reference name="CloudWatch metrics" url="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cloudwatch-metrics.html#available_cloudwatch_metrics"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Check CloudWatch data on containers and services that are in the RUNNING state.&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Open the CloudWatch console at https://console.aws.amazon.com/cloudwatch/.&lt;/li&gt; 
 &lt;li&gt;On the navigation pane, choose Metrics.&lt;/li&gt; 
 &lt;li&gt;On the All metrics tab, choose ECS.&lt;/li&gt; 
 &lt;li&gt;Choose ClusterName, ServiceName and then choose any metric (either CPUUtilization or MemoryUtilization) that corresponds to the service to view running tasks in.&lt;/li&gt; 
 &lt;li&gt;On the Graphed metrics tab, change Period to 1 Minute and Statistic to Sample Count.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C18" name="Monitor the containers for processes hanging." platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Use CloudWatch to monitor the containers and the processes&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; Before your container instances can send log data to CloudWatch Logs, you must create an IAM policy to allow your container instances to use the CloudWatch Logs APIs, and then you must attach that policy to ecsInstanceRole.&lt;/p&gt; 
&lt;p&gt;To create the ECS-CloudWatchLogs IAM policy&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Open the IAM console at https://console.aws.amazon.com/iam/.&lt;/li&gt; 
 &lt;li&gt;In the navigation pane, choose Policies.&lt;/li&gt; 
 &lt;li&gt;Choose Create policy, JSON.&lt;/li&gt; 
 &lt;li&gt;Enter the following policy:{ “Version”: “2012-10-17”, “Statement”: [ { “Effect”: “Allow”, “Action”: [ “logs:CreateLogGroup”, “logs:CreateLogStream”, “logs:PutLogEvents”, “logs:DescribeLogStreams” ], “Resource”: [ “arn:aws:logs:&lt;strong&gt;:*:&lt;/strong&gt;” ] } ]}&lt;/li&gt; 
 &lt;li&gt;Choose Review policy.&lt;/li&gt; 
 &lt;li&gt;On the Review policy page, enter ECS-CloudWatchLogs for the Name and choose Create policy.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;To attach the ECS-CloudWatchLogs policy to ecsInstanceRole&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Open the IAM console at https://console.aws.amazon.com/iam/.&lt;/li&gt; 
 &lt;li&gt;In the navigation pane, choose Roles.&lt;/li&gt; 
 &lt;li&gt;Choose ecsInstanceRole. If the role does not exist, follow the procedures in Amazon ECS Container Instance IAM Role to create the role.&lt;/li&gt; 
 &lt;li&gt;Choose Permissions, Attach policy.&lt;/li&gt; 
 &lt;li&gt;To narrow the available policies to attach, for Filter, type ECS-CloudWatchLogs.&lt;/li&gt; 
 &lt;li&gt;Check the box to the left of the ECS-CloudWatchLogs policy and choose Attach policy.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;To install the CloudWatch Logs agent:&lt;br /&gt; Run the following command to install the CloudWatch Logs agent.&lt;br /&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt; sudo yum install -y awslogs&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;To configure the CloudWatch Logs agent:&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Back up the existing CloudWatch Logs agent configuration file: sudo mv /etc/awslogs/awslogs.conf /etc/awslogs/awslogs.conf.bak&lt;/li&gt; 
 &lt;li&gt;Create a blank configuration file: sudo touch /etc/awslogs/awslogs.conf&lt;/li&gt; 
 &lt;li&gt;Open the /etc/awslogs/awslogs.conf file with a text editor, and copy the example file above into it.&lt;/li&gt; 
 &lt;li&gt;Install the jq JSON query utility: sudo yum install -y jq&lt;/li&gt; 
 &lt;li&gt;Query the Amazon ECS introspection API to find the cluster name and set it to an environment variable: cluster=$(curl -s http://localhost:51678/v1/metadata | jq -r ‘. | .Cluster’)&lt;/li&gt; 
 &lt;li&gt;Replace the {cluster} placeholders in the file with the value of the environment variable you set in the previous step: sudo sed -i -e “s/{cluster}/$cluster/g” /etc/awslogs/awslogs.conf&lt;/li&gt; 
 &lt;li&gt;Query the Amazon ECS introspection API operation to find the container instance ID and set it to an environment variable: container_instance_id=$(curl -s http://localhost:51678/v1/metadata | jq -r ‘. | .ContainerInstanceArn’ | awk -F/ ‘{print $2}’ )&lt;/li&gt; 
 &lt;li&gt;Replace the {container_instance_id} placeholders in the file with the value of the environment variable you set in the previous step: sudo sed -i -e “s/{container_instance_id}/$container_instance_id/g” /etc/awslogs/awslogs.conf&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;To configure the CloudWatch Logs agent Region:&lt;br /&gt; By default, the CloudWatch Logs agent sends data to the us-east-1 region. To send your data to a different region, such as the Region in which your cluster is located, you can set the Region in the /etc/awslogs/awscli.conf file.&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Open the /etc/awslogs/awscli.conf file with a text editor.&lt;/li&gt; 
 &lt;li&gt;In the [default] section, replace us-east-1 with the Region from which to view log data.&lt;/li&gt; 
 &lt;li&gt;Save the file and exit your text editor.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;To start the CloudWatch Logs agent&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Start the CloudWatch Logs agent with the following command.&lt;/li&gt; 
 &lt;ul&gt; 
  &lt;li&gt;Amazon Linux: sudo service awslogs start&lt;/li&gt; 
  &lt;li&gt;Amazon Linux 2: sudo systemctl start awslogsd&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;li&gt;Ensure that the CloudWatch Logs agent starts at every system boot with the following command.&lt;/li&gt; 
 &lt;ul&gt; 
  &lt;li&gt;Amazon Linux: sudo chkconfig awslogs on&lt;/li&gt; 
  &lt;li&gt;Amazon Linux 2: sudo systemctl enable awslogsd.service&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="Amazon ECS CloudWatch Metrics" url="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cloudwatch-metrics.html"/>
                        <reference name="Using CloudWatch Logs with Container Instances" url="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_cloudwatch_logs.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Check that each container throws their logs and follow the next steps to do it.&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Open the CloudWatch console at https://console.aws.amazon.com/cloudwatch/.&lt;/li&gt; 
 &lt;li&gt;In the left navigation pane, choose Logs.&lt;/li&gt; 
 &lt;li&gt;You should see the log groups you configured in Configuring and Starting the CloudWatch Logs Agent.&lt;/li&gt; 
 &lt;li&gt;Choose a log group to view.&lt;/li&gt; 
 &lt;li&gt;Choose a log stream to view. The streams are identified by the cluster name and container instance ID that sent the logs.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C5" name="Ensure you store your encryption keys in a Key Management System" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;AWS Key Management Service (KMS) is a managed service that makes it easy for you to create and control the encryption keys used to encrypt your data, and uses FIPS 140-2 validated hardware security modules to protect the security of your keys. AWS Key Management Service is integrated with most other AWS services to help you protect the data you store with these services. AWS Key Management Service is also integrated with AWS CloudTrail to provide you with logs of all key usage to help meet your regulatory and compliance needs.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; Verify that you are using the Key Management Service. You can see a list of your customer managed keys in the AWS Management Console.&lt;br /&gt; To view your CMKs (console): &lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Sign in to the AWS Management Console and open the AWS Identity and Access Management (IAM) console at https://console.aws.amazon.com/iam/.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;In the left navigation pane, choose Encryption keys.&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;For Region, choose the appropriate AWS Region. Do not use the region selector in the navigation bar (top right corner). The console shows all the CMKs in your AWS account in the chosen region, including customer-managed and AWS managed CMKs. The page displays the alias, key ID, status, and creation date for each CMK.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;If you need to create a CMK:&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Sign in to the AWS Management Console and open the AWS Key Management Service (AWS KMS) console at https://console.aws.amazon.com/kms.&lt;/li&gt; 
 &lt;li&gt;To change the AWS Region, use the Region selector in the upper-right corner of the page.&lt;/li&gt; 
 &lt;li&gt;In the navigation pane, choose Customer managed keys.&lt;/li&gt; 
 &lt;li&gt;Choose Create key.&lt;/li&gt; 
 &lt;li&gt;Type an alias for the CMK. The alias name cannot begin with aws/. The aws/ prefix is reserved by Amazon Web Services to represent AWS managed CMKs in your account.&lt;/li&gt; 
 &lt;li&gt;An alias is a display name that you can use to identify the CMK. We recommend that you choose an alias that indicates the type of data you plan to protect or the application you plan to use with the CMK.&lt;/li&gt; 
 &lt;li&gt;Aliases are required when you create a CMK in the AWS Management Console. They are optional when you use the CreateKey operation.&lt;/li&gt; 
 &lt;li&gt;(Optional) Type a description for the CMK.&lt;/li&gt; 
 &lt;li&gt;We recommend that you choose a description that explains the type of data you plan to protect or the application you plan to use with the CMK.&lt;/li&gt; 
 &lt;li&gt;Choose Next.&lt;/li&gt; 
 &lt;li&gt;(Optional) Type a tag key and an optional tag value. To add more than one tag to the CMK, choose Add tag.&lt;/li&gt; 
 &lt;li&gt;When you add tags to your AWS resources, AWS generates a cost allocation report with usage and costs aggregated by tags. For information about tagging CMKs, see Tagging Keys.&lt;/li&gt; 
 &lt;li&gt;Choose Next.&lt;/li&gt; 
 &lt;li&gt;Select the IAM users and roles that can administer the CMK.&lt;/li&gt; 
 &lt;li&gt;(Optional) To prevent the selected IAM users and roles from deleting this CMK, in the Key deletion section at the bottom of the page, clear the Allow key administrators to delete this key check box.&lt;/li&gt; 
 &lt;li&gt;Choose Next.&lt;/li&gt; 
 &lt;li&gt;Select the IAM users and roles that can use the CMK for cryptographic operations.&lt;/li&gt; 
 &lt;li&gt;(Optional) You can allow other AWS accounts to use this CMK for cryptographic operations. To do so, in the Other AWS accounts section at the bottom of the page, choose Add another AWS account and enter the AWS account identification number of an external account. To add multiple external accounts, repeat this step.&lt;/li&gt; 
 &lt;li&gt;Choose Next.&lt;/li&gt; 
 &lt;li&gt;Review the key policy document that was created from your choices. You can edit it, too.&lt;/li&gt; 
 &lt;li&gt;Choose Finish to create the CMK.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Key management service documentation" url="https://docs.aws.amazon.com/kms/latest/developerguide/getting-started.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Check that you are using the Key Management Service. To view a list of your customer managed keys in the AWS Management Console.&lt;/li&gt; 
 &lt;li&gt;To view your CMKs (console):&lt;/li&gt; 
 &lt;ol&gt; 
  &lt;li&gt;Sign in to the AWS Management Console and open the AWS Identity and Access Management (IAM) console at https://console.aws.amazon.com/iam/.&lt;/li&gt; 
  &lt;li&gt;In the left navigation pane, choose Encryption keys.&amp;nbsp;&lt;/li&gt; 
  &lt;li&gt;For Region, choose the appropriate AWS Region. Do not use the region selector in the navigation bar (top right corner). The console shows all the CMKs in your AWS account in the chosen region, including customer-managed and AWS managed CMKs. The page displays the alias, key ID, status, and creation date for each CMK.&lt;/li&gt; 
 &lt;/ol&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C23" name="Use a profiler tool to improve the application" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>	&lt;p&gt;When using a profiler tool, the execution of your functions are monitored. It will reveal which functions are called, number of invocations, execution times, memory usage and CPU use.&lt;/p&gt;

	&lt;p&gt;You can use it to find and identify bottlenecks and address them. Therefore, you shall use a profiler tool to improve the time of use, memory usage and CPU usage of the function.&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="AWS Lambda Limits" url="https://docs.aws.amazon.com/lambda/latest/dg/limits.html"/>
                        <reference name="Best practices for AWS Lambda timeouts" url="http://blog.epsagon.com/best-practices-for-aws-lambda-timeouts"/>
                        <reference name="Function configuration" url="https://docs.aws.amazon.com/lambda/latest/dg/resource-model.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>	&lt;p&gt;Check that a profiler tool is used to improve the Lambda function.&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C11" name="Enable and set up Request Validation in API Gateway" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;To perform the API Gateway basic validation, we have to enable and set up the Request Validation in the API Gateway.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;/b&gt;&lt;br /&gt; To enable basic validation, you specify validation rules in a request validator, add the validator to the API’s map of request validators, and assign the validator to individual API methods.&lt;/p&gt; 
&lt;p&gt;To set up a basic validation, we have some possibilities to configure it:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;by Importing OpenAPI Definition&lt;/li&gt; 
 &lt;li&gt;using the API Gateway REST API&lt;/li&gt; 
 &lt;li&gt;using the API Gateway Console&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;Using the API Gateway Console:&lt;br /&gt; The API Gateway console lets you set up the basic request validation on a method using one of the three validators:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Validate body: This is the body-only validator.&lt;/li&gt; 
 &lt;li&gt;Validate query string parameters and headers: This is the parameters-only validator.&lt;/li&gt; 
 &lt;li&gt;Validate body, query string parameters, and headers: This validator is for both body and parameters validation.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;When you choose one of the above validators to enable it on an API method, the API Gateway console will add the validator to the API’s RequestValidators map, if the validator has not already been added to the validators map of the API.&lt;/p&gt; 
&lt;p&gt;To enable a request validator on a method:&lt;br /&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Sign in to the API Gateway console, if not already logged in.&lt;/li&gt; 
 &lt;li&gt;Create a new or choose an existing API.&lt;/li&gt; 
 &lt;li&gt;Create a new or choose an existing resource of the API.&lt;/li&gt; 
 &lt;li&gt;Create a new or choose an existing method the resource.&lt;/li&gt; 
 &lt;li&gt;Choose Method Request.&lt;/li&gt; 
 &lt;li&gt;Choose the pencil icon of Request Validator under Settings.&lt;/li&gt; 
 &lt;li&gt;Choose Validate body, Validate query string parameters and headers or Validate body, query string parameters, and headers from the Request Validator drop-down list and then choose the check mark icon to save your choice.&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;For more information see the references.&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="Enable Request Validation in API Gateway" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html"/>
                        <reference name="Set up Basic Request Validation in API Gateway" url="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-validation-set-up.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Verify in the code if input parameters for functions are validated.&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control>
</controls>
<usecases>
<usecase ref="GENERAL" name="General" desc="" library="">
                    <threats>
<threat ref="AWS-LAMBDA-T9" name="Lambda functions are accessible through an unclean container" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;Cloud providers run your functions in a container. Because you want your function to execute as fast and efficient as possible, the containers are kept warm. This means that a container will be persistent for a while after a function is executed. This could leave room for a successful attack on the container.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C17" mitigation="25"/>
                                <control ref="AWS-LAMBDA-C18" mitigation="25"/>
                                <control ref="AWS-LAMBDA-C20" mitigation="25"/>
                                <control ref="AWS-LAMBDA-C23" mitigation="25"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W12">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C18" mitigation="25"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W11">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C17" mitigation="25"/>
                                        <control ref="AWS-LAMBDA-C20" mitigation="25"/>
                                        <control ref="AWS-LAMBDA-C23" mitigation="25"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat><threat ref="AWS-LAMBDA-T5" name="Lambda function is exploited by a non-HTTP event through code injection" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;A Lambda function can be triggered by a non-HTTP event (e.g. S3, SNS, SES, CloudWatch Events, etc.). When input validation is non-existing or not strong, malicious code can be injected through the input parameters. This may lead to complete compromise of the application and data stores.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C11" mitigation="50"/>
                                <control ref="DATA-VAL-GENERIC" mitigation="50"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W9">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C11" mitigation="50"/>
                                        <control ref="DATA-VAL-GENERIC" mitigation="50"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat><threat ref="AWS-LAMBDA-T15" name="Lambda function is compromised through a code injection attack" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;When input validation is non-existent or not strong, malicious code can be injected through the input parameters. This may compromise the complete application and data stores.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C11" mitigation="50"/>
                                <control ref="DATA-VAL-GENERIC" mitigation="50"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W9">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C11" mitigation="50"/>
                                        <control ref="DATA-VAL-GENERIC" mitigation="50"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat><threat ref="CAPEC-94" name="Man in the Middle Attack" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;This type of attack targets the communication between two components (typically client and server). The attacker places himself in the communication channel between the two components. Whenever one component attempts to communicate with the other (data flow, authentication challenges, etc.), the data first goes to the attacker, who has the opportunity to observe or alter it, and it is then passed on to the other component as if it was never intercepted. This interposition is transparent leaving the two compromised components unaware of the potential corruption or leakage of their communications. The potential for Man-in-the-Middle attacks yields an implicit lack of trust in communication or identify between two components.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C5" mitigation="33"/>
                                <control ref="Hydras-AWS-S3-7.3" mitigation="34"/>
                                <control ref="aws-tier-1.17" mitigation="33"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W4">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C5" mitigation="33"/>
                                        <control ref="aws-tier-1.17" mitigation="33"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W3">
                                    <controls>
                                        <control ref="Hydras-AWS-S3-7.3" mitigation="34"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat>
</threats>
</usecase>
</usecases>
</component>
<component ref="aws-lambda-patching" name="AWS Lambda: Patching" desc="" tags="" position="7" groupName="" library="" diagramPositionX="0" diagramPositionY="0" componentDefinitionRef="">
            <weaknesses>
<weakness ref="AWS-LAMBDA-W5" name="Unused functions have vulnerable dependencies because they were never updated" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Unused functions remain mostly unpatched. So if dependencies have vulnerabilities, this might not catch your attention and could create a security weak point.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W6" name="Unused functions are more risk from a security standpoint as they are often not maintained" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Unused functions are mostly unmaintained. Therefore code may not be regularly reviewed. And because the code isn't under your attention, this can impose a security risk, especially if the functionality of your application changes over time.</desc>
                </weakness><weakness ref="AWS-LAMBDA-W13" name="Functions use vulnerable dependencies " state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>Dependency management is a widespread problem in development. Developers may be unaware that third-party libraries or frameworks can contain vulnerabilities and those vulnerabilities are being constantly detected.</desc>
                </weakness>
</weaknesses>
<controls>
<control ref="CWE-937" name="Regularly check for known vulnerabilities in the dependencies of your project" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Vulnerabilities in common popular and shared libraries are published and recorded in a number of online databases and services, including the MITRE CVE and CWE databases.&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Perform regular checks for published vulnerabilities in third party components and the IDE.&lt;/li&gt; 
 &lt;li&gt;Test and apply appropriate recommended patches and mitigations.&lt;/li&gt; 
 &lt;li&gt;Use subscription threat intelligence and alerting services to ensure timely notification of possible threats&lt;/li&gt; 
 &lt;li&gt;Use automated vulnerability scanning tools to identify and test for security threats to the project.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="OWAPS Dependency check" url="https://www.owasp.org/index.php/OWASP_Dependency_Check"/>
                    </references>
                    <standards>
                        <standard ref="12.6.1" supportedStandardRef="ISO/IEC 27002:2013"/>
                        <standard ref="SA-15" supportedStandardRef="NIST 800-53"/>
                        <standard ref="SA-8" supportedStandardRef="NIST 800-53"/>
                        <standard ref="1.11" supportedStandardRef="OWASP-ASVS-Level-2"/>
                        <standard ref="1.11" supportedStandardRef="OWASP-ASVS-Level-3"/>
                        <standard ref="A9:2017-Using Components with Known Vulnerabilities" supportedStandardRef="owasp-top-10-2017"/>
                    </standards>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Ensure a process is in place to regularly check for vulnerabilities in software components and libraries. Sources should include:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Vendor notifications&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Threat intelligence feeds&amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;Vulnerability scanning.&lt;/li&gt; 
 &lt;li&gt;Verify that processes exist to respond to vulnerabilities to research, test, and deploy appropriate patches.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;The following tools can help in automating dependencies checks:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;OWASP Dependency Check for Java and .NET.&lt;/li&gt; 
 &lt;li&gt;Retire.js with support to scan several different of the most popular JS libraries andframeworks.&lt;/li&gt; 
 &lt;li&gt;nodesecurity.io which focuses on node packages and libraries’ security.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control><control ref="AWS-LAMBDA-C7" name="Review and remove unused functions" platform="" cost="1" risk="0" state="Recommended" owner="" library="" source="MANUAL">
                    <desc>&lt;p&gt;Review the current Lambda Functions and remove those unused functions from the system.&lt;/p&gt; 
&lt;p&gt;&lt;b&gt;Remediation:&lt;br /&gt;&lt;/b&gt; To list all functions:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Go to the AWS CLI, and write the following command:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt;aws list-functions&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt; 
 &lt;li&gt;Review all functions search those unused functions.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;To remove a certain function:&lt;br /&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Go to the AWS CLI, and write the following command:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt; aws delete-function —function-name &lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/blockquote&gt;</desc>
                    <implementations/>
                    <references>
                        <reference name="Automating the discovery of unused AWS Lambda functions" url="https://aws.amazon.com/blogs/mt/automating-the-discovery-of-unused-aws-lambda-functions/"/>
                        <reference name="AWS CLI Delete function" url="https://docs.aws.amazon.com/cli/latest/reference/lambda/delete-function.html"/>
                        <reference name="AWS CLI List functions" url="https://docs.aws.amazon.com/cli/latest/reference/lambda/list-functions.html"/>
                    </references>
                    <standards/>
                    <udts/>
                    <test expiryDate="" expiryPeriod="0">
                        <steps>&lt;p&gt;Write the following command in the AWS CLI and check that all listed functions are not unused functions:&amp;nbsp;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;aws list-functions&lt;/p&gt; 
&lt;/blockquote&gt;</steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-25T16:40:59">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                </control>
</controls>
<usecases>
<usecase ref="PATCHING" name="Patching" desc="" library="">
                    <threats>
<threat ref="AWS-LAMBDA-T3" name="Attackers exploit an unused function to enter the system" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;A &amp;quot;problem&amp;quot; with serverless architecture is that you don’t pay for functions that aren’t used. This means that your unused functions will not appear on your bill. If the unused functions become forgotten, they can become a threat. Those functions will not be updated or patched.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="AWS-LAMBDA-C7" mitigation="50"/>
                                <control ref="CWE-937" mitigation="50"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W6">
                                    <controls>
                                        <control ref="AWS-LAMBDA-C7" mitigation="50"/>
                                    </controls>
                                </weakness>
                                <weakness ref="AWS-LAMBDA-W5">
                                    <controls>
                                        <control ref="CWE-937" mitigation="50"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat><threat ref="AWS-LAMBDA-T10" name="Lambda functions are compromised through exploiting vulnerable dependencies" state="Expose" source="MANUAL" owner="" library="">
                            <desc>	&lt;p&gt;Functions often use third-party libraries or frameworks. These dependencies can be vulnerable and new vulnerabilities are regularly disclosed. As soon as a vulnerability is registered in the CVE database, attackers will try to exploit the vulnerability within hours using automated exploits.&lt;/p&gt;</desc>
                            <riskRating confidentiality="100" integrity="100" availability="100" easeOfExploitation="25"/>
                            <references/>
                            <controls>
                                <control ref="CWE-937" mitigation="100"/>
                            </controls>
                            <weaknesses>
                                <weakness ref="AWS-LAMBDA-W13">
                                    <controls>
                                        <control ref="CWE-937" mitigation="100"/>
                                    </controls>
                                </weakness>
                            </weaknesses>
                        </threat>
</threats>
</usecase>
</usecases>
</component>
</components>
<rules>
<rule name="Set answer: set trust zone  as Public Cloud if the component definition is AWS Lambda" module="component" generatedByGui="true">
            <condition name="Is specific component definition" type="drools-without-variable-type" field="id" value="aws-lambda-function">
                <pattern name="Is specific component definition" pattern='ComponentDefinitionProperties(ref == "${value}");'/>
            </condition>
            <action project="" value="Public Cloud_::_true_::_true" name="Answer Question" type="drools-without-variable-type">
                <pattern name="Action of answer question" pattern='$questionToAnswer : Question(id == "${value-1}", answer != ${value-2}); eval(!${value-3} || !$questionToAnswer.isManuallyModified());_:::_modify($questionToAnswer) { setAnswer(${value-2}), setCanBeManuallyModified(${value-3}) };'/>
            </action>
            <content></content>
        </rule>

</rules>

</project>