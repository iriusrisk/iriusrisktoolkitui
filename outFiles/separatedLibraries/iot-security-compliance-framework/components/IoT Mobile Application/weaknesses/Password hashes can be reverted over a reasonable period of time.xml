<weakness ref="CWE-916" name="Password hashes can be reverted over a reasonable period of time" state="0" impact="100">
                    <test expiryDate="" expiryPeriod="0">
                        <steps></steps>
                        <notes></notes>
                        <references/>
                        <source filename="" args="" type="Manual" result="Not Tested" enabled="true" timestamp="2019-03-13T16:00:46">
                            <output></output>
                        </source>
                        <udts/>
                    </test>
                    <desc>The software generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive. Many password storage mechanisms compute a hash and store the hash, instead of storing the original password in plaintext. In this design, authentication involves accepting an incoming password, computing its hash, and comparing it to the stored hash.&amp;nbsp; 
&lt;div&gt; 
 &lt;br /&gt; 
&lt;/div&gt; 
&lt;div&gt;
  Many hash algorithms are designed to execute quickly with minimal overhead, even cryptographic hashes. However, this efficiency is a problem for password storage, because it can reduce an attacker's workload for brute-force password cracking. If an attacker can obtain the hashes through some other method (such as SQL injection on a database that stores hashes), then the attacker can store the hashes offline and use various techniques to crack the passwords by computing hashes efficiently. Without a built-in workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massively-parallel computing (such as cloud computing) and GPU, ASIC, or FPGA hardware. In such a scenario, an efficient hash algorithm helps the attacker. There are several properties of a hash scheme that are relevant to its strength against an offline, massively-parallel attack:&amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;ul&gt; 
  &lt;li&gt;The amount of CPU time required to compute the hash (&amp;quot;stretching&amp;quot;)&amp;nbsp;&lt;/li&gt; 
  &lt;li&gt;The amount of memory required to compute the hash (&amp;quot;memory-hard&amp;quot; operations)&amp;nbsp;&lt;/li&gt; 
  &lt;li&gt;Including a random value, along with the password, as input to the hash computation (&amp;quot;salting&amp;quot;)&amp;nbsp;&lt;/li&gt; 
  &lt;li&gt;Given a hash, there is no known way of determining a password that produces this hash value, other than by guessing possible passwords (&amp;quot;one-way&amp;quot; hashing)&amp;nbsp;&lt;/li&gt; 
  &lt;li&gt;Relative to the number of all possible hashes that can be generated by the scheme, there is a low likelihood of producing the same hash for multiple different inputs (&amp;quot;collision resistance&amp;quot;)&amp;nbsp;&lt;/li&gt; 
 &lt;/ul&gt;Note that the security requirements for the software may vary depending on the environment and the value of the passwords. Different schemes might not provide all of these properties, yet may still provide sufficient security for the environment. Conversely, a solution might be very strong in preserving one property, which still being very weak for an attack against another property, or it might not be able to significantly reduce the efficiency of a massively-parallel attack. 
&lt;/div&gt;</desc>
                </weakness>