<!DOCTYPE html><html><head><title>Risk Patterns for Docker-CIS.xml</title><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script><script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script></head><body><center><h2>Risk patterns for Docker-CIS.xml<h2></center><div class="accordion" id="components"><div class="card border-primary"><div class="card-header " id="heading77"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse77" aria-expanded="true" aria-controls="collapse77">Risk pattern: Docker Container Runtime <span>[DOCKER-CONTAINER-RUNTIME]</span></button></h5></div><div id="collapse77" class="collapse" aria-labelledby="heading77" data-parent="#components"><div class="card-body">The ways in which a container is started governs a lot of the security implications. It is possible to provide potentially dangerous runtime parameters that might compromise the host and other containers on the host. Verifying container runtime is thus very important. This Risk Pattern contains various recommendations to assess the container runtime.<div class="accordion" id="usecases"><div class="card border-black"><div class="card-header " id="heading34"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse34" aria-expanded="true" aria-controls="collapse34">Use case: Authentication and Authorization <span>[AUTHENTICATION AND AUTHORIZATION]</span></button></h5></div><div id="collapse34" class="collapse" aria-labelledby="heading34" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading33"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse33" aria-expanded="true" aria-controls="collapse33">Threat: Attakers gain access without the necessary privileged to the docker container runtime <span>[CAPEC-122-DOCKER-CONTAINER-RUNTIME]</span></button></h5></div><div id="collapse33" class="collapse" aria-labelledby="heading33" data-parent="#threats"><div class="card-body">An adversary is able to exploit features of the target that should be reserved for
                                privileged users or administrators but are exposed to use by lower or non-privileged
                                accounts. Access to sensitive information and functionality must be controlled to ensure
                                that only authorized users are able to access these resources. If access control
                                mechanisms are absent or misconfigured, a user may be able to access resources that are
                                intended only for higher level users. An adversary may be able to exploit this to
                                utilize a less trusted account to gain information and perform activities reserved for
                                more trusted accounts. This attack differs from privilege escalation and other privilege
                                stealing attacks in that the adversary never actually escalates their privileges but
                                instead is able to use a lesser degree of privilege to access resources that should be
                                (but are not) reserved for higher privilege accounts. Likewise, the adversary does not
                                exploit trust or subvert systems - all control functionality is working as configured
                                but the configuration does not adequately protect sensitive resources at an appropriate
                                level.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading10"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse10" aria-expanded="true" aria-controls="collapse10">Weakness: Execution with Unnecessary Privileges <span>[CWE-250]</span></button></h5></div><div id="collapse10" class="collapse" aria-labelledby="heading10" data-parent="#weaknesses"><div class="card-body">The software performs an operation at a privilege level that is higher than the minimum level
                        required, which creates new weaknesses or amplifies the consequences of other weaknesses.

                        New weaknesses can be exposed because running with extra privileges, such as root or
                        Administrator, can disable the normal security checks being performed by the operating system or
                        surrounding environment. Other pre-existing weaknesses can turn into security vulnerabilities if
                        they occur while operating at raised privileges. Privilege management functions can behave in
                        some less-than-obvious ways, and they have different quirks on different platforms. These
                        inconsistencies are particularly pronounced if you are transitioning from one non-root user to
                        another. Signal handlers and spawned processes run at the privilege of the owning process, so if
                        a process is running as root when a signal fires or a sub-process is executed, the signal
                        handler or sub-process will operate with root privileges.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading0"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse0" aria-expanded="true" aria-controls="collapse0">Countermeasure: Ensure the container's root filesystem is mounted as read only <span>[D5.12]</span></button></h5></div><div id="collapse0" class="collapse" aria-labelledby="heading0" data-parent="#controls"><div class="card-body">The container's root filesystem should be treated as a 'golden image' by using Docker run's
                        --read-only option. This prevents any writes to the container's root filesystem at container
                        runtime and enforces the principle of immutable infrastructure.&nbsp;
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        Enabling this option forces containers at runtime to explicitly define their data writing
                        strategy to persist or not persist their data. This also reduces security attack vectors since
                        the container instance's filesystem cannot be tampered with or written to unless it has explicit
                        read-write permissions on its filesystem folder and directories.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Add a --read-only flag at a container's runtime to enforce the container's root filesystem to be
                        mounted as read only. docker run --read-only Enabling the --read-only option at a container's
                        runtime should be used by administrators to force a container's executable processes to only
                        write container data to explicit storage locations during the container's runtime.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Examples of explicit storage locations during a container's runtime include, but are not limited
                        to:&nbsp;
                        </div>
                        <div>
                        <ol>
                        <li>Use the --tmpfs option to mount a temporary file system for non-persistent data
                        writes. docker run --interactive --tty --read-only --tmpfs &quot;/run&quot; --tmpfs
                        &quot;/tmp&quot; centos /bin/bash&nbsp;</li>
                        <li>Enabling Docker rw mounts at a container's runtime to persist container data directly
                        on the Docker host filesystem. docker run --interactive --tty --read-only -v
                        /opt/app/data:/run/app/data:rw centos /bin/bash&nbsp;</li>
                        <li>Utilizing Docker shared-storage volume plugins for Docker data volume to persist
                        container data. docker volume create -d convoy --opt o=size=20GB my-named-volume docker run
                        --interactive --tty --read-only -v my-named-volume:/run/app/data centos /bin/bash&nbsp;</li>
                        <li>Transmitting container data outside of the docker during the container's runtime for
                        container data to persist container data. Examples include hosted databases, network file
                        shares, and APIs.&nbsp;</li>
                        </ol>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Enabling --read-only at container runtime may break some container OS packages if a data writing
                        strategy is not defined. Define what the container's data should and should not persist at
                        runtime to determine which recommendation procedure to utilize.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading1"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse1" aria-expanded="true" aria-controls="collapse1">Countermeasure: Ensure the default seccomp profile is not Disabled <span>[D5.21]</span></button></h5></div><div id="collapse1" class="collapse" aria-labelledby="heading1" data-parent="#controls"><div class="card-body">Seccomp filtering provides a means for a process to specify a filter for incoming system
                        calls. The default Docker seccomp profile works on whitelist basis and allows 311 system calls
                        blocking all others. It should not be disabled unless it hinders your container application
                        usage.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A large number of system calls are exposed to every userland process with many of them going
                        unused for the entire lifetime of the process. Most of the applications do not need all the
                        system calls and thus benefit by having a reduced set of available system calls. The reduced set
                        of system calls reduces the total kernel surface exposed to the application and thus improves
                        application security.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        By default, seccomp profiles are enabled. You do not need to do anything unless you want to
                        modify and use the modified seccomp profile.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        With Docker 1.10 and greater, the default seccomp profile blocks syscalls, regardless of
                        --cap-add passed to the container. You should create your own custom seccomp profile in such
                        cases. You may also disable the default seccomp profile by passing
                        --security-opt=seccomp:unconfined on docker run.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading2"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse2" aria-expanded="true" aria-controls="collapse2">Countermeasure: Ensure docker exec commands are not used with privileged option <span>[D5.22]</span></button></h5></div><div id="collapse2" class="collapse" aria-labelledby="heading2" data-parent="#controls"><div class="card-body">Do not use docker exec with --privileged option.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Using --privileged option in docker exec gives extended Linux capabilities to the command. This
                        could be potentially insecure and unsafe to do especially when you are running containers with
                        dropped capabilities or with enhanced restrictions.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not use --privileged option in docker exec command.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None. If you need enhanced capabilities within the container, then run the container with the
                        required capabilities.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading3"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse3" aria-expanded="true" aria-controls="collapse3">Countermeasure: Ensure docker exec commands are not used with user option <span>[D5.23]</span></button></h5></div><div id="collapse3" class="collapse" aria-labelledby="heading3" data-parent="#controls"><div class="card-body">Do not use docker exec with --user option.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        Using --user option in docker exec executes the command within the container as that user. This
                        could be potentially insecure and unsafe to do especially when you are running containers with
                        dropped capabilities or with enhanced restrictions. For example, suppose your container is
                        running as tomcat user (or any other non-root user), it would be possible to run a command
                        through docker exec as root with --user=root option. This could be potentially dangerous.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not use --user option in docker exec command.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading4"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse4" aria-expanded="true" aria-controls="collapse4">Countermeasure: Ensure cgroup usage is confirmed <span>[D5.24]</span></button></h5></div><div id="collapse4" class="collapse" aria-labelledby="heading4" data-parent="#controls"><div class="card-body">It is possible to attach to a particular cgroup on container run. Confirming cgroup usage
                        would ensure that containers are running under defined cgroups.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        System administrators typically define cgroups under which containers are supposed to run. Even
                        if cgroups are not explicitly defined by the system administrators, containers run under docker
                        cgroup by default. At run-time, it is possible to attach to a different cgroup other than the
                        one that was expected to be used. This usage should be monitored and confirmed. By attaching to
                        a different cgroup than the one that is expected, excess permissions and resources might be
                        granted to the container and thus, can prove to be unsafe.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not use --cgroup-parent option in docker run command unless needed.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading5"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse5" aria-expanded="true" aria-controls="collapse5">Countermeasure: Ensure the container is restricted from acquiring additional privileges <span>[D5.25]</span></button></h5></div><div id="collapse5" class="collapse" aria-labelledby="heading5" data-parent="#controls"><div class="card-body">Restrict the container from acquiring additional privileges via suid or sgid bits.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        A process can set the no_new_priv bit in the kernel. It persists across fork, clone and execve.
                        The no_new_priv bit ensures that the process or its children processes do not gain any
                        additional privileges via suid or sgid bits. This way a lot of dangerous operations become a lot
                        less dangerous because there is no possibility of subverting privileged binaries.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        For example, you should start your container as below:&nbsp;
                        </div>
                        </div>
                        <blockquote>
                        <div>
                        <div>
                        docker run --rm -it --security-opt=no-new-privileges ubuntu bash
                        </div>
                        </div>
                        </blockquote>
                        <div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        no_new_priv prevents LSMs like SELinux from transitioning to process labels that have access not
                        allowed to the current process.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading6"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse6" aria-expanded="true" aria-controls="collapse6">Countermeasure: Ensure Linux Kernel Capabilities are restricted within containers <span>[D5.3]</span></button></h5></div><div id="collapse6" class="collapse" aria-labelledby="heading6" data-parent="#controls"><div class="card-body">By default, Docker starts containers with a restricted set of Linux Kernel Capabilities. This
                        means that any process may be granted the required capabilities instead of root access. Using
                        Linux Kernel Capabilities, the processes do not have to run as root for almost all the specific
                        areas where root privileges are usually needed.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker supports the addition and removal of capabilities, allowing the use of a non-default
                        profile. This may make Docker more secure through capability removal, or less secure through the
                        addition of capabilities. It is thus recommended to remove all capabilities except those
                        explicitly required for your container process. For example, capabilities such as below are
                        usually not needed for container process: NET_ADMIN SYS_ADMIN SYS_MODULE&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Execute the below command to add needed capabilities:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        $&gt; docker run --cap-add={&quot;Capability 1&quot;,&quot;Capability 2&quot;}&nbsp;
                        </div>
                        </blockquote>For example,&nbsp;
                        <blockquote>
                        <div>
                        docker run --interactive --tty --cap-add={&quot;NET_ADMIN&quot;,&quot;SYS_ADMIN&quot;}
                        centos:latest /bin/bash&nbsp;
                        </div>
                        </blockquote>Execute the below command to drop unneeded capabilities:&nbsp;
                        <blockquote>
                        <div>
                        $&gt; docker run --cap-drop={&quot;Capability 1&quot;,&quot;Capability 2&quot;}&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --cap-drop={&quot;SETUID&quot;,&quot;SETGID&quot;}
                        centos:latest /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Alternatively, You may choose to drop all capabilities and add only the needed ones:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        $&gt; docker run --cap-drop=all --cap-add={&quot;Capability 1&quot;,&quot;Capability
                        2&quot;}&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --cap-drop=all --cap-add= &quot;NET_ADMIN&quot;,&quot;SYS_ADMIN&quot;}
                        centos:latest /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        Based on what Linux Kernel Capabilities were added or dropped, restrictions within the container
                        would apply.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading7"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse7" aria-expanded="true" aria-controls="collapse7">Countermeasure: Ensure the Docker socket is not mounted inside any containers <span>[D5.31]</span></button></h5></div><div id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#controls"><div class="card-body">The docker socket docker.sock should not be mounted inside a container.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        If the docker socket is mounted inside a container it would allow processes running within the
                        container to execute docker commands which effectively allows for full control of the host.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>
                        </div>
                        <div>
                        <b></b>Ensure that no containers mount docker.sock as a volume.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading8"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse8" aria-expanded="true" aria-controls="collapse8">Countermeasure: Ensure privileged containers are not used <span>[D5.4]</span></button></h5></div><div id="collapse8" class="collapse" aria-labelledby="heading8" data-parent="#controls"><div class="card-body">Using the --privileged flag gives all Linux Kernel Capabilities to the container thus
                        overwriting the --cap-add and --cap-drop flags. Ensure that it is not used.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The --privileged flag gives all capabilities to the container, and it also lifts all the
                        limitations enforced by the device cgroup controller. In other words, the container can then do
                        almost everything the host can do. This flag exists to allow special use-cases, like running
                        Docker within Docker.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not run container with the --privileged flag. For example, do not start a container as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --privileged centos /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Linux Kernel Capabilities other than defaults would not be available for use within container.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading9"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse9" aria-expanded="true" aria-controls="collapse9">Countermeasure: Ensure sensitive host system directories are not mounted on containers <span>[D5.5]</span></button></h5></div><div id="collapse9" class="collapse" aria-labelledby="heading9" data-parent="#controls"><div class="card-body">Sensitive host system directories such as below should not be allowed to be mounted as
                        container volumes especially in read-write mode. / /boot /dev /etc /lib /proc /sys /usr&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        If sensitive directories are mounted in read-write mode, it would be possible to make changes to
                        files within those sensitive directories. The changes might have negative security implications
                        or unwarranted changes that could put the Docker host in compromised state.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not mount host sensitive directories on containers especially in read-write mode.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading19"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse19" aria-expanded="true" aria-controls="collapse19">Weakness: Incorrect Default Permissions <span>[CWE-276]</span></button></h5></div><div id="collapse19" class="collapse" aria-labelledby="heading19" data-parent="#weaknesses"><div class="card-body">The software, upon installation, sets incorrect permissions for an object that exposes it to
                        an unintended actor.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading11"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse11" aria-expanded="true" aria-controls="collapse11">Countermeasure: Ensure the container's root filesystem is mounted as read only <span>[D5.12]</span></button></h5></div><div id="collapse11" class="collapse" aria-labelledby="heading11" data-parent="#controls"><div class="card-body">The container's root filesystem should be treated as a 'golden image' by using Docker run's
                        --read-only option. This prevents any writes to the container's root filesystem at container
                        runtime and enforces the principle of immutable infrastructure.&nbsp;
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        Enabling this option forces containers at runtime to explicitly define their data writing
                        strategy to persist or not persist their data. This also reduces security attack vectors since
                        the container instance's filesystem cannot be tampered with or written to unless it has explicit
                        read-write permissions on its filesystem folder and directories.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Add a --read-only flag at a container's runtime to enforce the container's root filesystem to be
                        mounted as read only. docker run --read-only Enabling the --read-only option at a container's
                        runtime should be used by administrators to force a container's executable processes to only
                        write container data to explicit storage locations during the container's runtime.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Examples of explicit storage locations during a container's runtime include, but are not limited
                        to:&nbsp;
                        </div>
                        <div>
                        <ol>
                        <li>Use the --tmpfs option to mount a temporary file system for non-persistent data
                        writes. docker run --interactive --tty --read-only --tmpfs &quot;/run&quot; --tmpfs
                        &quot;/tmp&quot; centos /bin/bash&nbsp;</li>
                        <li>Enabling Docker rw mounts at a container's runtime to persist container data directly
                        on the Docker host filesystem. docker run --interactive --tty --read-only -v
                        /opt/app/data:/run/app/data:rw centos /bin/bash&nbsp;</li>
                        <li>Utilizing Docker shared-storage volume plugins for Docker data volume to persist
                        container data. docker volume create -d convoy --opt o=size=20GB my-named-volume docker run
                        --interactive --tty --read-only -v my-named-volume:/run/app/data centos /bin/bash&nbsp;</li>
                        <li>Transmitting container data outside of the docker during the container's runtime for
                        container data to persist container data. Examples include hosted databases, network file
                        shares, and APIs.&nbsp;</li>
                        </ol>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Enabling --read-only at container runtime may break some container OS packages if a data writing
                        strategy is not defined. Define what the container's data should and should not persist at
                        runtime to determine which recommendation procedure to utilize.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading12"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse12" aria-expanded="true" aria-controls="collapse12">Countermeasure: Ensure the default seccomp profile is not Disabled <span>[D5.21]</span></button></h5></div><div id="collapse12" class="collapse" aria-labelledby="heading12" data-parent="#controls"><div class="card-body">Seccomp filtering provides a means for a process to specify a filter for incoming system
                        calls. The default Docker seccomp profile works on whitelist basis and allows 311 system calls
                        blocking all others. It should not be disabled unless it hinders your container application
                        usage.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A large number of system calls are exposed to every userland process with many of them going
                        unused for the entire lifetime of the process. Most of the applications do not need all the
                        system calls and thus benefit by having a reduced set of available system calls. The reduced set
                        of system calls reduces the total kernel surface exposed to the application and thus improves
                        application security.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        By default, seccomp profiles are enabled. You do not need to do anything unless you want to
                        modify and use the modified seccomp profile.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        With Docker 1.10 and greater, the default seccomp profile blocks syscalls, regardless of
                        --cap-add passed to the container. You should create your own custom seccomp profile in such
                        cases. You may also disable the default seccomp profile by passing
                        --security-opt=seccomp:unconfined on docker run.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading13"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse13" aria-expanded="true" aria-controls="collapse13">Countermeasure: Ensure docker exec commands are not used with privileged option <span>[D5.22]</span></button></h5></div><div id="collapse13" class="collapse" aria-labelledby="heading13" data-parent="#controls"><div class="card-body">Do not use docker exec with --privileged option.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Using --privileged option in docker exec gives extended Linux capabilities to the command. This
                        could be potentially insecure and unsafe to do especially when you are running containers with
                        dropped capabilities or with enhanced restrictions.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not use --privileged option in docker exec command.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None. If you need enhanced capabilities within the container, then run the container with the
                        required capabilities.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading14"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse14" aria-expanded="true" aria-controls="collapse14">Countermeasure: Ensure docker exec commands are not used with user option <span>[D5.23]</span></button></h5></div><div id="collapse14" class="collapse" aria-labelledby="heading14" data-parent="#controls"><div class="card-body">Do not use docker exec with --user option.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        Using --user option in docker exec executes the command within the container as that user. This
                        could be potentially insecure and unsafe to do especially when you are running containers with
                        dropped capabilities or with enhanced restrictions. For example, suppose your container is
                        running as tomcat user (or any other non-root user), it would be possible to run a command
                        through docker exec as root with --user=root option. This could be potentially dangerous.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not use --user option in docker exec command.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading15"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse15" aria-expanded="true" aria-controls="collapse15">Countermeasure: Ensure cgroup usage is confirmed <span>[D5.24]</span></button></h5></div><div id="collapse15" class="collapse" aria-labelledby="heading15" data-parent="#controls"><div class="card-body">It is possible to attach to a particular cgroup on container run. Confirming cgroup usage
                        would ensure that containers are running under defined cgroups.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        System administrators typically define cgroups under which containers are supposed to run. Even
                        if cgroups are not explicitly defined by the system administrators, containers run under docker
                        cgroup by default. At run-time, it is possible to attach to a different cgroup other than the
                        one that was expected to be used. This usage should be monitored and confirmed. By attaching to
                        a different cgroup than the one that is expected, excess permissions and resources might be
                        granted to the container and thus, can prove to be unsafe.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not use --cgroup-parent option in docker run command unless needed.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading16"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse16" aria-expanded="true" aria-controls="collapse16">Countermeasure: Ensure Linux Kernel Capabilities are restricted within containers <span>[D5.3]</span></button></h5></div><div id="collapse16" class="collapse" aria-labelledby="heading16" data-parent="#controls"><div class="card-body">By default, Docker starts containers with a restricted set of Linux Kernel Capabilities. This
                        means that any process may be granted the required capabilities instead of root access. Using
                        Linux Kernel Capabilities, the processes do not have to run as root for almost all the specific
                        areas where root privileges are usually needed.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker supports the addition and removal of capabilities, allowing the use of a non-default
                        profile. This may make Docker more secure through capability removal, or less secure through the
                        addition of capabilities. It is thus recommended to remove all capabilities except those
                        explicitly required for your container process. For example, capabilities such as below are
                        usually not needed for container process: NET_ADMIN SYS_ADMIN SYS_MODULE&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Execute the below command to add needed capabilities:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        $&gt; docker run --cap-add={&quot;Capability 1&quot;,&quot;Capability 2&quot;}&nbsp;
                        </div>
                        </blockquote>For example,&nbsp;
                        <blockquote>
                        <div>
                        docker run --interactive --tty --cap-add={&quot;NET_ADMIN&quot;,&quot;SYS_ADMIN&quot;}
                        centos:latest /bin/bash&nbsp;
                        </div>
                        </blockquote>Execute the below command to drop unneeded capabilities:&nbsp;
                        <blockquote>
                        <div>
                        $&gt; docker run --cap-drop={&quot;Capability 1&quot;,&quot;Capability 2&quot;}&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --cap-drop={&quot;SETUID&quot;,&quot;SETGID&quot;}
                        centos:latest /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Alternatively, You may choose to drop all capabilities and add only the needed ones:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        $&gt; docker run --cap-drop=all --cap-add={&quot;Capability 1&quot;,&quot;Capability
                        2&quot;}&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --cap-drop=all --cap-add= &quot;NET_ADMIN&quot;,&quot;SYS_ADMIN&quot;}
                        centos:latest /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        Based on what Linux Kernel Capabilities were added or dropped, restrictions within the container
                        would apply.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading17"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse17" aria-expanded="true" aria-controls="collapse17">Countermeasure: Ensure privileged containers are not used <span>[D5.4]</span></button></h5></div><div id="collapse17" class="collapse" aria-labelledby="heading17" data-parent="#controls"><div class="card-body">Using the --privileged flag gives all Linux Kernel Capabilities to the container thus
                        overwriting the --cap-add and --cap-drop flags. Ensure that it is not used.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The --privileged flag gives all capabilities to the container, and it also lifts all the
                        limitations enforced by the device cgroup controller. In other words, the container can then do
                        almost everything the host can do. This flag exists to allow special use-cases, like running
                        Docker within Docker.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not run container with the --privileged flag. For example, do not start a container as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --privileged centos /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Linux Kernel Capabilities other than defaults would not be available for use within container.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading18"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse18" aria-expanded="true" aria-controls="collapse18">Countermeasure: Ensure sensitive host system directories are not mounted on containers <span>[D5.5]</span></button></h5></div><div id="collapse18" class="collapse" aria-labelledby="heading18" data-parent="#controls"><div class="card-body">Sensitive host system directories such as below should not be allowed to be mounted as
                        container volumes especially in read-write mode. / /boot /dev /etc /lib /proc /sys /usr&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        If sensitive directories are mounted in read-write mode, it would be possible to make changes to
                        files within those sensitive directories. The changes might have negative security implications
                        or unwarranted changes that could put the Docker host in compromised state.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not mount host sensitive directories on containers especially in read-write mode.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading32"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse32" aria-expanded="true" aria-controls="collapse32">Weakness: Incorrect Permission Assignment for Critical Resource <span>[CWE-732]</span></button></h5></div><div id="collapse32" class="collapse" aria-labelledby="heading32" data-parent="#weaknesses"><div class="card-body">The software specifies permissions for a security-critical resource in a way that allows that
                        resource to be read or modified by unintended actors.
                        When a resource is given a permissions setting that provides access to a wider range of actors
                        than required, it could lead to the exposure of sensitive information, or the modification of
                        that resource by unintended parties. This is especially dangerous when the resource is related
                        to program configuration, execution or sensitive user data.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading20"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse20" aria-expanded="true" aria-controls="collapse20">Countermeasure: Ensure the container's root filesystem is mounted as read only <span>[D5.12]</span></button></h5></div><div id="collapse20" class="collapse" aria-labelledby="heading20" data-parent="#controls"><div class="card-body">The container's root filesystem should be treated as a 'golden image' by using Docker run's
                        --read-only option. This prevents any writes to the container's root filesystem at container
                        runtime and enforces the principle of immutable infrastructure.&nbsp;
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        Enabling this option forces containers at runtime to explicitly define their data writing
                        strategy to persist or not persist their data. This also reduces security attack vectors since
                        the container instance's filesystem cannot be tampered with or written to unless it has explicit
                        read-write permissions on its filesystem folder and directories.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Add a --read-only flag at a container's runtime to enforce the container's root filesystem to be
                        mounted as read only. docker run --read-only Enabling the --read-only option at a container's
                        runtime should be used by administrators to force a container's executable processes to only
                        write container data to explicit storage locations during the container's runtime.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Examples of explicit storage locations during a container's runtime include, but are not limited
                        to:&nbsp;
                        </div>
                        <div>
                        <ol>
                        <li>Use the --tmpfs option to mount a temporary file system for non-persistent data
                        writes. docker run --interactive --tty --read-only --tmpfs &quot;/run&quot; --tmpfs
                        &quot;/tmp&quot; centos /bin/bash&nbsp;</li>
                        <li>Enabling Docker rw mounts at a container's runtime to persist container data directly
                        on the Docker host filesystem. docker run --interactive --tty --read-only -v
                        /opt/app/data:/run/app/data:rw centos /bin/bash&nbsp;</li>
                        <li>Utilizing Docker shared-storage volume plugins for Docker data volume to persist
                        container data. docker volume create -d convoy --opt o=size=20GB my-named-volume docker run
                        --interactive --tty --read-only -v my-named-volume:/run/app/data centos /bin/bash&nbsp;</li>
                        <li>Transmitting container data outside of the docker during the container's runtime for
                        container data to persist container data. Examples include hosted databases, network file
                        shares, and APIs.&nbsp;</li>
                        </ol>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Enabling --read-only at container runtime may break some container OS packages if a data writing
                        strategy is not defined. Define what the container's data should and should not persist at
                        runtime to determine which recommendation procedure to utilize.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading21"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse21" aria-expanded="true" aria-controls="collapse21">Countermeasure: Ensure host devices are not directly exposed to containers <span>[D5.17]</span></button></h5></div><div id="collapse21" class="collapse" aria-labelledby="heading21" data-parent="#controls"><div class="card-body">Host devices can be directly exposed to containers at runtime. Do not directly expose host
                        devices to containers especially for containers that are not trusted.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The --device option exposes the host devices to the containers and consequently, the containers
                        can directly access such host devices. You would not require the container to run in privileged
                        mode to access and manipulate the host devices. By default, the container will be able to read,
                        write and mknod these devices.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Additionally, it is possible for containers to remove block devices from the host. Hence, do not
                        expose host devices to containers directly. If at all you would want to expose the host device
                        to a container, use the sharing permissions appropriately:&nbsp;
                        </div>
                        <div>
                        <ul>
                        <li>r - read only&nbsp;</li>
                        <li>w - writable&nbsp;</li>
                        <li>m - mknod allowed&nbsp;</li>
                        </ul>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not directly expose the host devices to containers. If at all you need to expose the host
                        devices to containers, use the correct set of permissions: For example, do not start a container
                        as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --device=/dev/tty0:/dev/tty0:rwm
                        --device=/dev/temp_sda:/dev/temp_sda:rwm centos bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        For example, share the host device with correct permissions:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --device=/dev/tty0:/dev/tty0:rw
                        --device=/dev/temp_sda:/dev/temp_sda:r centos bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <b>Impact: </b>You would not be able to use the host devices directly within the
                        containers.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading22"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse22" aria-expanded="true" aria-controls="collapse22">Countermeasure: Ensure mount propagation mode is not set to shared <span>[D5.19]</span></button></h5></div><div id="collapse22" class="collapse" aria-labelledby="heading22" data-parent="#controls"><div class="card-body">Mount propagation mode allows mounting volumes in shared, slave or private mode on a
                        container. Do not use shared mount propagation mode until needed.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A shared mount is replicated at all mounts and the changes made at any mount point are
                        propagated to all mounts. Mounting a volume in shared mode does not restrict any other container
                        to mount and make changes to that volume. This might be catastrophic if the mounted volume is
                        sensitive to changes. Do not set mount propagation mode to shared until needed.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not mount volumes in shared mode propagation. For example, do not start container as below:
                        </div>
                        <blockquote>
                        <div>
                        docker run --volume=/hostPath:/containerPath:shared&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        </blockquote>
                        <b>Impact:</b> None.
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading23"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse23" aria-expanded="true" aria-controls="collapse23">Countermeasure: Ensure the default seccomp profile is not Disabled <span>[D5.21]</span></button></h5></div><div id="collapse23" class="collapse" aria-labelledby="heading23" data-parent="#controls"><div class="card-body">Seccomp filtering provides a means for a process to specify a filter for incoming system
                        calls. The default Docker seccomp profile works on whitelist basis and allows 311 system calls
                        blocking all others. It should not be disabled unless it hinders your container application
                        usage.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A large number of system calls are exposed to every userland process with many of them going
                        unused for the entire lifetime of the process. Most of the applications do not need all the
                        system calls and thus benefit by having a reduced set of available system calls. The reduced set
                        of system calls reduces the total kernel surface exposed to the application and thus improves
                        application security.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        By default, seccomp profiles are enabled. You do not need to do anything unless you want to
                        modify and use the modified seccomp profile.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        With Docker 1.10 and greater, the default seccomp profile blocks syscalls, regardless of
                        --cap-add passed to the container. You should create your own custom seccomp profile in such
                        cases. You may also disable the default seccomp profile by passing
                        --security-opt=seccomp:unconfined on docker run.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading24"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse24" aria-expanded="true" aria-controls="collapse24">Countermeasure: Ensure docker exec commands are not used with privileged option <span>[D5.22]</span></button></h5></div><div id="collapse24" class="collapse" aria-labelledby="heading24" data-parent="#controls"><div class="card-body">Do not use docker exec with --privileged option.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Using --privileged option in docker exec gives extended Linux capabilities to the command. This
                        could be potentially insecure and unsafe to do especially when you are running containers with
                        dropped capabilities or with enhanced restrictions.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not use --privileged option in docker exec command.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None. If you need enhanced capabilities within the container, then run the container with the
                        required capabilities.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading25"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse25" aria-expanded="true" aria-controls="collapse25">Countermeasure: Ensure docker exec commands are not used with user option <span>[D5.23]</span></button></h5></div><div id="collapse25" class="collapse" aria-labelledby="heading25" data-parent="#controls"><div class="card-body">Do not use docker exec with --user option.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        Using --user option in docker exec executes the command within the container as that user. This
                        could be potentially insecure and unsafe to do especially when you are running containers with
                        dropped capabilities or with enhanced restrictions. For example, suppose your container is
                        running as tomcat user (or any other non-root user), it would be possible to run a command
                        through docker exec as root with --user=root option. This could be potentially dangerous.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not use --user option in docker exec command.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading26"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse26" aria-expanded="true" aria-controls="collapse26">Countermeasure: Ensure cgroup usage is confirmed <span>[D5.24]</span></button></h5></div><div id="collapse26" class="collapse" aria-labelledby="heading26" data-parent="#controls"><div class="card-body">It is possible to attach to a particular cgroup on container run. Confirming cgroup usage
                        would ensure that containers are running under defined cgroups.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        System administrators typically define cgroups under which containers are supposed to run. Even
                        if cgroups are not explicitly defined by the system administrators, containers run under docker
                        cgroup by default. At run-time, it is possible to attach to a different cgroup other than the
                        one that was expected to be used. This usage should be monitored and confirmed. By attaching to
                        a different cgroup than the one that is expected, excess permissions and resources might be
                        granted to the container and thus, can prove to be unsafe.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not use --cgroup-parent option in docker run command unless needed.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading27"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse27" aria-expanded="true" aria-controls="collapse27">Countermeasure: Ensure the container is restricted from acquiring additional privileges <span>[D5.25]</span></button></h5></div><div id="collapse27" class="collapse" aria-labelledby="heading27" data-parent="#controls"><div class="card-body">Restrict the container from acquiring additional privileges via suid or sgid bits.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        A process can set the no_new_priv bit in the kernel. It persists across fork, clone and execve.
                        The no_new_priv bit ensures that the process or its children processes do not gain any
                        additional privileges via suid or sgid bits. This way a lot of dangerous operations become a lot
                        less dangerous because there is no possibility of subverting privileged binaries.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        For example, you should start your container as below:&nbsp;
                        </div>
                        </div>
                        <blockquote>
                        <div>
                        <div>
                        docker run --rm -it --security-opt=no-new-privileges ubuntu bash
                        </div>
                        </div>
                        </blockquote>
                        <div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        no_new_priv prevents LSMs like SELinux from transitioning to process labels that have access not
                        allowed to the current process.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading28"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse28" aria-expanded="true" aria-controls="collapse28">Countermeasure: Ensure Linux Kernel Capabilities are restricted within containers <span>[D5.3]</span></button></h5></div><div id="collapse28" class="collapse" aria-labelledby="heading28" data-parent="#controls"><div class="card-body">By default, Docker starts containers with a restricted set of Linux Kernel Capabilities. This
                        means that any process may be granted the required capabilities instead of root access. Using
                        Linux Kernel Capabilities, the processes do not have to run as root for almost all the specific
                        areas where root privileges are usually needed.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker supports the addition and removal of capabilities, allowing the use of a non-default
                        profile. This may make Docker more secure through capability removal, or less secure through the
                        addition of capabilities. It is thus recommended to remove all capabilities except those
                        explicitly required for your container process. For example, capabilities such as below are
                        usually not needed for container process: NET_ADMIN SYS_ADMIN SYS_MODULE&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Execute the below command to add needed capabilities:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        $&gt; docker run --cap-add={&quot;Capability 1&quot;,&quot;Capability 2&quot;}&nbsp;
                        </div>
                        </blockquote>For example,&nbsp;
                        <blockquote>
                        <div>
                        docker run --interactive --tty --cap-add={&quot;NET_ADMIN&quot;,&quot;SYS_ADMIN&quot;}
                        centos:latest /bin/bash&nbsp;
                        </div>
                        </blockquote>Execute the below command to drop unneeded capabilities:&nbsp;
                        <blockquote>
                        <div>
                        $&gt; docker run --cap-drop={&quot;Capability 1&quot;,&quot;Capability 2&quot;}&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --cap-drop={&quot;SETUID&quot;,&quot;SETGID&quot;}
                        centos:latest /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Alternatively, You may choose to drop all capabilities and add only the needed ones:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        $&gt; docker run --cap-drop=all --cap-add={&quot;Capability 1&quot;,&quot;Capability
                        2&quot;}&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --cap-drop=all --cap-add= &quot;NET_ADMIN&quot;,&quot;SYS_ADMIN&quot;}
                        centos:latest /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        Based on what Linux Kernel Capabilities were added or dropped, restrictions within the container
                        would apply.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading29"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse29" aria-expanded="true" aria-controls="collapse29">Countermeasure: Ensure the Docker socket is not mounted inside any containers <span>[D5.31]</span></button></h5></div><div id="collapse29" class="collapse" aria-labelledby="heading29" data-parent="#controls"><div class="card-body">The docker socket docker.sock should not be mounted inside a container.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        If the docker socket is mounted inside a container it would allow processes running within the
                        container to execute docker commands which effectively allows for full control of the host.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>
                        </div>
                        <div>
                        <b></b>Ensure that no containers mount docker.sock as a volume.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading30"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse30" aria-expanded="true" aria-controls="collapse30">Countermeasure: Ensure privileged containers are not used <span>[D5.4]</span></button></h5></div><div id="collapse30" class="collapse" aria-labelledby="heading30" data-parent="#controls"><div class="card-body">Using the --privileged flag gives all Linux Kernel Capabilities to the container thus
                        overwriting the --cap-add and --cap-drop flags. Ensure that it is not used.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The --privileged flag gives all capabilities to the container, and it also lifts all the
                        limitations enforced by the device cgroup controller. In other words, the container can then do
                        almost everything the host can do. This flag exists to allow special use-cases, like running
                        Docker within Docker.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not run container with the --privileged flag. For example, do not start a container as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --privileged centos /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Linux Kernel Capabilities other than defaults would not be available for use within container.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading31"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse31" aria-expanded="true" aria-controls="collapse31">Countermeasure: Ensure sensitive host system directories are not mounted on containers <span>[D5.5]</span></button></h5></div><div id="collapse31" class="collapse" aria-labelledby="heading31" data-parent="#controls"><div class="card-body">Sensitive host system directories such as below should not be allowed to be mounted as
                        container volumes especially in read-write mode. / /boot /dev /etc /lib /proc /sys /usr&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        If sensitive directories are mounted in read-write mode, it would be possible to make changes to
                        files within those sensitive directories. The changes might have negative security implications
                        or unwarranted changes that could put the Docker host in compromised state.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not mount host sensitive directories on containers especially in read-write mode.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading68"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse68" aria-expanded="true" aria-controls="collapse68">Use case: General <span>[GENERAL]</span></button></h5></div><div id="collapse68" class="collapse" aria-labelledby="heading68" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading41"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse41" aria-expanded="true" aria-controls="collapse41">Threat: Attackers consume the resources of the Container Runtime by rapidly engaging to do the target inaccessible or to break the target <span>[CAPEC-125-CONTAINER-RUNTIME]</span></button></h5></div><div id="collapse41" class="collapse" aria-labelledby="heading41" data-parent="#threats"><div class="card-body">An adversary consumes the resources of a target by rapidly engaging in a large number
                                of interactions with the target. This type of attack generally exposes a weakness in
                                rate limiting or flow. When successful this attack prevents legitimate users from
                                accessing the service and can cause the target to crash. This attack differs from
                                resource depletion through leaks or allocations in that the latter attacks do not rely
                                on the volume of requests made to the target but instead focus on manipulation of the
                                target's operations. The key factor in a flooding attack is the number of requests the
                                adversary can make in a given period of time. The greater this number, the more likely
                                an attack is to succeed against a given target.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading40"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse40" aria-expanded="true" aria-controls="collapse40">Weakness: Uncontrolled Resource Consumption ('Resource Exhaustion') <span>[CWE-400]</span></button></h5></div><div id="collapse40" class="collapse" aria-labelledby="heading40" data-parent="#weaknesses"><div class="card-body">The software does not properly restrict the size or amount of resources that are requested or
                        influenced by an actor, which can be used to consume more resources than intended.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading35"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse35" aria-expanded="true" aria-controls="collapse35">Countermeasure: Ensure memory usage for container is limited <span>[D5.10]</span></button></h5></div><div id="collapse35" class="collapse" aria-labelledby="heading35" data-parent="#controls"><div class="card-body">By default, all containers on a Docker host share the resources equally. By using the resource
                        management capabilities of Docker host, such as memory limit, you can control the amount of
                        memory that a container may consume.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        By default, container can use all of the memory on the host. You can use memory limit mechanism
                        to prevent a denial of service arising from one container consuming all of the host's resources
                        such that other containers on the same host cannot perform their intended functions. Having no
                        limit on memory can lead to issues where one container can easily make the whole system unstable
                        and as a result unusable.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the container with only as much memory as required. Always run the container using the
                        --memory argument. For example, you could run a container as below:&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --memory 256m centos /bin/bash&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        </blockquote>In the above example, the container is started with a memory limit of 256 MB.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        Note: Please note that the output of the below command would return values in scientific
                        notation if memory limits are in place.
                        </div>
                        <div>
                        <br />
                        </div>
                        <blockquote>
                        <div>
                        docker inspect --format='{{.Config.Memory}}' 7c5a2d4c7fe0&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        </blockquote>For example, if the memory limit is set to 256 MB for the above container
                        instance, the output of the above command would be 2.68435456e+08 and NOT 256mb. You should
                        convert this value using a scientific calculator or programmatic methods. Impact: If you do not
                        set proper limits, the container process may have to starve.
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading36"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse36" aria-expanded="true" aria-controls="collapse36">Countermeasure: Ensure CPU priority is set appropriately on the container <span>[D5.11]</span></button></h5></div><div id="collapse36" class="collapse" aria-labelledby="heading36" data-parent="#controls"><div class="card-body">By default, all containers on a Docker host share the resources equally. By using the resource
                        management capabilities of Docker host, such as CPU shares, you can control the host CPU
                        resources that a container may consume.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        By default, CPU time is divided between containers equally. If it is desired, to control the CPU
                        time amongst the container instances, you can use the CPU sharing feature. CPU sharing allows
                        prioritization of one container over the other and forbids the lower priority container claiming
                        CPU resources more often. This ensures that the high priority containers are served better.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Manage the CPU shares between your containers. To do so, start the container using the
                        --cpu-shares argument. For example, you could run a container as below:&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        docker run --interactive --tty --cpu-shares 512 centos /bin/bash&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        In the above example, the container is started with CPU shares of 50% of what the other
                        containers use. So, if the other container has CPU shares of 80%, this container will have CPU
                        shares of 40%.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Note: Every new container will have 1024 shares of CPU by default. However, this value is shown
                        as 0 if you run the command mentioned in the audit section. Alternatively,&nbsp;
                        </div>
                        <div>
                        <ol>
                        <li>Navigate to /sys/fs/cgroup/cpu/system.slice/ directory.&nbsp;</li>
                        <li>Check your container instance ID using docker ps.&nbsp;</li>
                        <li>Now, inside the above directory (in step 1), you would have a directory named
                        docker-.scope. For example,
                        docker-4acae729e8659c6be696ee35b2237cc1fe4edd2672e9186434c5116e1a6fbed6.scope. Navigate to this
                        directory.&nbsp;</li>
                        <li>You will find a file named cpu.shares. Execute cat cpu.shares.&nbsp;</li>
                        </ol>This will always give you the CPU share value based on the system. So, even if there
                        is no CPU shares configured using -c or --cpu-shares argument in the docker run command, this
                        file will have a value of 1024. If we set one container's CPU shares to 512
                        it will receive half
                        of the CPU time compared to the other container. So, take 1024 as 100% and then do quick math to
                        derive the number that you should set for respective CPU shares. For example, use 512 if you
                        want to set 50% and 256 if you want to set 25%.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If you do not set proper CPU shares, the container process may have to starve if the resources
                        on the host are not available. If the CPU resources on the host are free, CPU shares do not
                        place any restrictions on the CPU that the container may use.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading37"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse37" aria-expanded="true" aria-controls="collapse37">Countermeasure: Ensure 'on-failure' container restart policy is set to '5' <span>[D5.14]</span></button></h5></div><div id="collapse37" class="collapse" aria-labelledby="heading37" data-parent="#controls"><div class="card-body">Using the --restart flag in docker run command you can specify a restart policy for how a
                        container should or should not be restarted on exit. You should choose the on-failure restart
                        policy and limit the restart attempts to 5.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        If you indefinitely keep trying to start the container, it could possibly lead to a denial of
                        service on the host. It could be an easy way to do a distributed denial of service attack
                        especially if you have many containers on the same host. Additionally, ignoring the exit status
                        of the container and always attempting to restart the container leads to non-investigation of
                        the root cause behind containers getting terminated. If a container gets terminated, you should
                        investigate the reason behind it instead of just attempting to restart it indefinitely. Thus, it
                        is recommended to use on-failure restart policy and limit it to a maximum of 5 restart attempts.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        If a container is desired to be restarted on its own, then, for example, you could start the
                        container as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --detach --restart=on-failure:5 nginx&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        The container would attempt to restart only 5 times.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading38"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse38" aria-expanded="true" aria-controls="collapse38">Countermeasure: Ensure the default ulimit is overwritten at runtime, only if needed <span>[D5.18]</span></button></h5></div><div id="collapse38" class="collapse" aria-labelledby="heading38" data-parent="#controls"><div class="card-body">The default ulimit is set at the Docker daemon level. However, you may override the default
                        ulimit setting, if needed, during container runtime.&nbsp;
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        ulimit provides control over the resources available to the shell and to processes started by
                        it. Setting system resource limits judiciously saves you from many disasters such as a fork
                        bomb. Sometimes, even friendly users and legitimate processes can overuse system resources and
                        in-turn can make the system unusable.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        The default ulimit set at the Docker daemon level should be honored. If the default ulimit
                        settings are not appropriate for a particular container instance, you may override them as an
                        exception. But, do not make this a practice. If most of the container instances are overriding
                        default ulimit settings, consider changing the default ulimit settings to something that is
                        appropriate for your needs.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Only override the default ulimit settings if needed. For example, to override default ulimit
                        settings start a container as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --ulimit nofile=1024:1024 --interactive --tty centos /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If the ulimits are not set properly, the desired resource control might not be achieved and
                        might even make the system unusable.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading39"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse39" aria-expanded="true" aria-controls="collapse39">Countermeasure: Ensure PIDs cgroup limit is used <span>[D5.28]</span></button></h5></div><div id="collapse39" class="collapse" aria-labelledby="heading39" data-parent="#controls"><div class="card-body">Use --pids-limit flag at container runtime.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Attackers could launch a fork bomb with a single command inside the container. This fork bomb
                        can crash the entire system and requires a restart of the host to make the system functional
                        again. PIDs cgroup --pids-limit will prevent this kind of attack by restricting the number of
                        forks that can happen inside a container at a given time.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Use --pids-limit flag while launching the container with an appropriate value. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run -it --pids-limit 100&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        In the above example, the number of processes allowed to run at any given time is set to 100.
                        After a limit of 100 concurrently running processes is reached, docker would restrict any new
                        process creations.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Set the PIDs limit value as appropriate. Incorrect values might render the containers unusable.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div><div class="card border-danger"><div class="card-header " id="heading44"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse44" aria-expanded="true" aria-controls="collapse44">Threat: Attackers gain access to the docker container by using sensitive data which was found embedded within it <span>[CAPEC-37-CONTAINER-RUNTIME]</span></button></h5></div><div id="collapse44" class="collapse" aria-labelledby="heading44" data-parent="#threats"><div class="card-body">An attacker examines a target system to find sensitive data that has been embedded
                                within it. This information can reveal confidential contents, such as account numbers or
                                individual keys/credentials which can be used as an intermediate step in a larger
                                attack.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading43"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse43" aria-expanded="true" aria-controls="collapse43">Weakness: Information Exposure <span>[CWE-200]</span></button></h5></div><div id="collapse43" class="collapse" aria-labelledby="heading43" data-parent="#weaknesses"><div class="card-body">An information exposure is the intentional or unintentional disclosure of information to an
                        actor that is not explicitly authorized to have access to that information.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading42"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse42" aria-expanded="true" aria-controls="collapse42">Countermeasure: Ensure sensitive host system directories are not mounted on containers <span>[D5.5]</span></button></h5></div><div id="collapse42" class="collapse" aria-labelledby="heading42" data-parent="#controls"><div class="card-body">Sensitive host system directories such as below should not be allowed to be mounted as
                        container volumes especially in read-write mode. / /boot /dev /etc /lib /proc /sys /usr&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        If sensitive directories are mounted in read-write mode, it would be possible to make changes to
                        files within those sensitive directories. The changes might have negative security implications
                        or unwarranted changes that could put the Docker host in compromised state.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not mount host sensitive directories on containers especially in read-write mode.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div><div class="card border-danger"><div class="card-header " id="heading67"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse67" aria-expanded="true" aria-controls="collapse67">Threat: Exploitation of Security Misconfiguration of the Docker container runtime <span>[OWASP A6:2017-DOCKER-CONTAINER-RUNTIME]</span></button></h5></div><div id="collapse67" class="collapse" aria-labelledby="heading67" data-parent="#threats"><div class="card-body">Attackers will often attempt to exploit unpatched flaws or access default accounts,
                                unused pages, unprotected files and directories, etc to gain unauthorized access or
                                knowledge of the system.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading46"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse46" aria-expanded="true" aria-controls="collapse46">Weakness: Recommended security patches are not applied <span>[UNPATCHED-SERVER]</span></button></h5></div><div id="collapse46" class="collapse" aria-labelledby="heading46" data-parent="#weaknesses"><div class="card-body">When patches are not applied in a timely manner then the server or system could be vulnerable
                        to known security issues. These issues could be used by an attacker to gain access to the
                        system.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading45"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse45" aria-expanded="true" aria-controls="collapse45">Countermeasure: Ensure docker commands always get the latest version of the image <span>[D5.27]</span></button></h5></div><div id="collapse45" class="collapse" aria-labelledby="heading45" data-parent="#controls"><div class="card-body">Always ensure that you are using the latest version of the image within your repository and
                        not the cached older versions.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Multiple docker commands such as docker pull, docker run, etc. are known to have an issue that
                        by default, they extract the local copy of the image, if present, even though there is an
                        updated version of the image with the &quot;same tag&quot; in the upstream repository.
                        This could lead to using older and vulnerable images.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Use proper version pinning mechanisms (the latest tag which is assigned by default is still
                        vulnerable to caching attacks) to avoid extracting the cached older versions. Version pinning
                        mechanisms should be used for base images, packages, and entire images too. You can customize
                        version pinning rules as per your requirements.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading51"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse51" aria-expanded="true" aria-controls="collapse51">Weakness: The application does not define isolated boundaries (Insufficient Encapsulation) <span>[CWE-485]</span></button></h5></div><div id="collapse51" class="collapse" aria-labelledby="heading51" data-parent="#weaknesses"><div class="card-body"><div>
                        The application does not sufficiently encapsulate critical data or functionality.
                        </div>
                        <p>Encapsulation is about drawing strong boundaries. In a web browser that might mean
                        ensuring that your mobile code cannot be abused by other mobile code. On the server it might
                        mean differentiation between validated data and unvalidated data, between one user's data and
                        another's, or between data users are allowed to see and data that they are not.</p>
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading47"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse47" aria-expanded="true" aria-controls="collapse47">Countermeasure: Ensure the host's process namespace is not shared <span>[D5.15]</span></button></h5></div><div id="collapse47" class="collapse" aria-labelledby="heading47" data-parent="#controls"><div class="card-body">Process ID (PID) namespaces isolate the process ID number space, meaning that processes in
                        different PID namespaces can have the same PID. This is process level isolation between
                        containers and the host.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        PID namespace provides separation of processes. The PID Namespace removes the view of the system
                        processes, and allows process ids to be reused including PID 1. If the host's PID namespace is
                        shared with the container, it would basically allow processes within the container to see all of
                        the processes on the host system. This breaks the benefit of process level isolation between the
                        host and the containers.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Someone having access to the container can eventually know all the processes running on the host
                        system and can even kill the host system processes from within the container. This can be
                        catastrophic. Hence, do not share the host's process namespace with the containers.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not start a container with --pid=host argument. For example, do not start a container as
                        below:
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --pid=host centos /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Container processes cannot see the processes on the host system. In certain cases, you want your
                        container to share the host's process namespace. For example, you could build a container with
                        debugging tools like strace or gdb, but want to use these tools when debugging processes within
                        the container. If this is desired, then share only one (or needed) host process by using the -p
                        switch. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --pid=host rhel7 strace -p 1234
                        </div>
                        </blockquote>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading48"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse48" aria-expanded="true" aria-controls="collapse48">Countermeasure: Ensure the host's IPC namespace is not shared <span>[D5.16]</span></button></h5></div><div id="collapse48" class="collapse" aria-labelledby="heading48" data-parent="#controls"><div class="card-body">IPC (POSIX/SysV IPC) namespace provides separation of named shared memory segments, semaphores
                        and message queues. IPC namespace on the host thus should not be shared with the containers and
                        should remain isolated.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        IPC namespace provides separation of IPC between the host and containers. If the host's IPC
                        namespace is shared with the container, it would basically allow processes within the container
                        to see all of the IPC on the host system. This breaks the benefit of IPC level isolation between
                        the host and the containers.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Someone having access to the container can eventually manipulate the host IPC. This can be
                        catastrophic. Hence, do not share the host's IPC namespace with the containers.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>Do not start a container with --ipc=host argument. For example, do not start a
                        container as below:
                        <div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --ipc=host centos /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <b>Impact:</b> Shared memory segments are used to accelerate inter-process
                        communication. It is commonly used by high-performance applications. If such applications are
                        containerized into multiple containers, you might need to share the IPC namespace of the
                        containers to achieve high performance. In such cases, you should still be sharing container
                        specific IPC namespaces only and not the host IPC namespace. You may share the container's IPC
                        namespace with another container as below: For example,&nbsp;
                        </div>
                        </div>
                        <blockquote>
                        <div>
                        <div>
                        docker run --interactive --tty --ipc=container:e3a7a1a97c58 centos /bin/bash
                        </div>
                        </div>
                        </blockquote>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading49"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse49" aria-expanded="true" aria-controls="collapse49">Countermeasure: Ensure the host's UTS namespace is not shared <span>[D5.20]</span></button></h5></div><div id="collapse49" class="collapse" aria-labelledby="heading49" data-parent="#controls"><div class="card-body">UTS namespaces provide isolation of two system identifiers: the hostname and the NIS domain
                        name. It is used for setting the hostname and the domain that is visible to running processes in
                        that namespace. Processes running within containers do not typically require to know hostname
                        and domain name. Hence, the namespace should not be shared with the host.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Sharing the UTS namespace with the host provides full permission to the container to change the
                        hostname of the host. This is insecure and should not be allowed.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        Do not start a container with --uts=host argument. For example, do not start a container as
                        below: docker run --rm --interactive --tty --uts=host rhel7.2&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b> None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading50"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse50" aria-expanded="true" aria-controls="collapse50">Countermeasure: Ensure the host's user namespaces is not shared <span>[D5.30]</span></button></h5></div><div id="collapse50" class="collapse" aria-labelledby="heading50" data-parent="#controls"><div class="card-body">Do not share the host's user namespaces with the containers.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        User namespaces ensure that a root process inside the container will be mapped to a non-root
                        process outside the container. Sharing the user namespaces of the host with the container thus
                        does not isolate users on the host with users on the containers.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not share user namespaces between host and containers. For example, do not run a container as
                        below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --rm -it --userns=host ubuntu bash&nbsp;
                        </div>
                        </blockquote>
                        <b>Impact:&nbsp;</b>
                        <div>
                        None
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading66"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse66" aria-expanded="true" aria-controls="collapse66">Weakness: Unexpected Environment Condition <span>[CWE-2]</span></button></h5></div><div id="collapse66" class="collapse" aria-labelledby="heading66" data-parent="#weaknesses"><div class="card-body">This is a generic weakness that includes several different situations, they are all related to
                        unexpected environmental conditions and they could be related to:&nbsp;
                        <div>
                        <ul>
                        <li>Misconfiguration.</li>
                        <li>Uncleared buffers, shared memory, files, etc.&nbsp;</li>
                        <li>Problems between the interaction of two different entities that cause unexpected
                        behavior.</li>
                        </ul>
                        </div>
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading52"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse52" aria-expanded="true" aria-controls="collapse52">Countermeasure: Ensure AppArmor Profile is Enabled <span>[D5.1]</span></button></h5></div><div id="collapse52" class="collapse" aria-labelledby="heading52" data-parent="#controls"><div class="card-body">AppArmor is an effective and easy-to-use Linux application security system. It is available on
                        quite a few Linux distributions by default such as Debian and Ubuntu. Rationale: AppArmor
                        protects the Linux OS and applications from various threats by enforcing security policy which
                        is also known as AppArmor profile. You can create your own AppArmor profile for containers or
                        use the Docker's default AppArmor profile. This would enforce security policies on the
                        containers as defined in the profile.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        If AppArmor is applicable for your Linux OS, use it. You may have to follow below set of steps:&nbsp;
                        </div>
                        <div>
                        <ol>
                        <li>Verify if AppArmor is installed. If not, install it.&nbsp;</li>
                        <li>Create or import an AppArmor profile for Docker containers.&nbsp;</li>
                        <li>Put this profile in enforcing mode.&nbsp;</li>
                        <li>Start your Docker container using the customized AppArmor profile. For example,&nbsp;</li>
                        </ol>
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --security-opt=&quot;apparmor:PROFILENAME&quot; centos
                        /bin/bash
                        </div>
                        <div>
                        <br />
                        </div>
                        </blockquote>Alternatively, you can keep the docker's default apparmor profile.
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        The container (process) would have a set of restrictions as defined in the AppArmor profile. If
                        your AppArmor profile is mis-configured, then the container may not entirely work as expected.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading53"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse53" aria-expanded="true" aria-controls="collapse53">Countermeasure: Ensure memory usage for container is limited <span>[D5.10]</span></button></h5></div><div id="collapse53" class="collapse" aria-labelledby="heading53" data-parent="#controls"><div class="card-body">By default, all containers on a Docker host share the resources equally. By using the resource
                        management capabilities of Docker host, such as memory limit, you can control the amount of
                        memory that a container may consume.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        By default, container can use all of the memory on the host. You can use memory limit mechanism
                        to prevent a denial of service arising from one container consuming all of the host's resources
                        such that other containers on the same host cannot perform their intended functions. Having no
                        limit on memory can lead to issues where one container can easily make the whole system unstable
                        and as a result unusable.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the container with only as much memory as required. Always run the container using the
                        --memory argument. For example, you could run a container as below:&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --memory 256m centos /bin/bash&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        </blockquote>In the above example, the container is started with a memory limit of 256 MB.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        Note: Please note that the output of the below command would return values in scientific
                        notation if memory limits are in place.
                        </div>
                        <div>
                        <br />
                        </div>
                        <blockquote>
                        <div>
                        docker inspect --format='{{.Config.Memory}}' 7c5a2d4c7fe0&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        </blockquote>For example, if the memory limit is set to 256 MB for the above container
                        instance, the output of the above command would be 2.68435456e+08 and NOT 256mb. You should
                        convert this value using a scientific calculator or programmatic methods. Impact: If you do not
                        set proper limits, the container process may have to starve.
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading54"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse54" aria-expanded="true" aria-controls="collapse54">Countermeasure: Ensure CPU priority is set appropriately on the container <span>[D5.11]</span></button></h5></div><div id="collapse54" class="collapse" aria-labelledby="heading54" data-parent="#controls"><div class="card-body">By default, all containers on a Docker host share the resources equally. By using the resource
                        management capabilities of Docker host, such as CPU shares, you can control the host CPU
                        resources that a container may consume.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        By default, CPU time is divided between containers equally. If it is desired, to control the CPU
                        time amongst the container instances, you can use the CPU sharing feature. CPU sharing allows
                        prioritization of one container over the other and forbids the lower priority container claiming
                        CPU resources more often. This ensures that the high priority containers are served better.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Manage the CPU shares between your containers. To do so, start the container using the
                        --cpu-shares argument. For example, you could run a container as below:&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        docker run --interactive --tty --cpu-shares 512 centos /bin/bash&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        In the above example, the container is started with CPU shares of 50% of what the other
                        containers use. So, if the other container has CPU shares of 80%, this container will have CPU
                        shares of 40%.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Note: Every new container will have 1024 shares of CPU by default. However, this value is shown
                        as 0 if you run the command mentioned in the audit section. Alternatively,&nbsp;
                        </div>
                        <div>
                        <ol>
                        <li>Navigate to /sys/fs/cgroup/cpu/system.slice/ directory.&nbsp;</li>
                        <li>Check your container instance ID using docker ps.&nbsp;</li>
                        <li>Now, inside the above directory (in step 1), you would have a directory named
                        docker-.scope. For example,
                        docker-4acae729e8659c6be696ee35b2237cc1fe4edd2672e9186434c5116e1a6fbed6.scope. Navigate to this
                        directory.&nbsp;</li>
                        <li>You will find a file named cpu.shares. Execute cat cpu.shares.&nbsp;</li>
                        </ol>This will always give you the CPU share value based on the system. So, even if there
                        is no CPU shares configured using -c or --cpu-shares argument in the docker run command, this
                        file will have a value of 1024. If we set one container's CPU shares to 512
                        it will receive half
                        of the CPU time compared to the other container. So, take 1024 as 100% and then do quick math to
                        derive the number that you should set for respective CPU shares. For example, use 512 if you
                        want to set 50% and 256 if you want to set 25%.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If you do not set proper CPU shares, the container process may have to starve if the resources
                        on the host are not available. If the CPU resources on the host are free, CPU shares do not
                        place any restrictions on the CPU that the container may use.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading55"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse55" aria-expanded="true" aria-controls="collapse55">Countermeasure: Ensure incoming container traffic is binded to a specific host interface <span>[D5.13]</span></button></h5></div><div id="collapse55" class="collapse" aria-labelledby="heading55" data-parent="#controls"><div class="card-body">By default, Docker containers can make connections to the outside world, but the outside world
                        cannot connect to containers. Each outgoing connection will appear to originate from one of the
                        host machine's own IP addresses. Only allow container services to be contacted through a
                        specific external interface on the host machine.&nbsp;
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        If you have multiple network interfaces on your host machine, the container can accept
                        connections on the exposed ports on any network interface. This might not be desired and may not
                        be secured. Many times a particular interface is exposed externally and services such as
                        intrusion detection, intrusion prevention, firewall, load balancing, etc. are run on those
                        interfaces to screen incoming public traffic.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Hence, you should not accept incoming connections on any interface. You should only allow
                        incoming connections from a particular external interface.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Bind the container port to a specific host interface on the desired host port. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --detach --publish 10.2.3.4:49153:80 nginx&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        In the example above, the container port 80 is bound to the host port on 49153 and would accept
                        incoming connection only from 10.2.3.4 external interface. Impact: None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading56"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse56" aria-expanded="true" aria-controls="collapse56">Countermeasure: Ensure 'on-failure' container restart policy is set to '5' <span>[D5.14]</span></button></h5></div><div id="collapse56" class="collapse" aria-labelledby="heading56" data-parent="#controls"><div class="card-body">Using the --restart flag in docker run command you can specify a restart policy for how a
                        container should or should not be restarted on exit. You should choose the on-failure restart
                        policy and limit the restart attempts to 5.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        If you indefinitely keep trying to start the container, it could possibly lead to a denial of
                        service on the host. It could be an easy way to do a distributed denial of service attack
                        especially if you have many containers on the same host. Additionally, ignoring the exit status
                        of the container and always attempting to restart the container leads to non-investigation of
                        the root cause behind containers getting terminated. If a container gets terminated, you should
                        investigate the reason behind it instead of just attempting to restart it indefinitely. Thus, it
                        is recommended to use on-failure restart policy and limit it to a maximum of 5 restart attempts.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        If a container is desired to be restarted on its own, then, for example, you could start the
                        container as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --detach --restart=on-failure:5 nginx&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        The container would attempt to restart only 5 times.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading57"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse57" aria-expanded="true" aria-controls="collapse57">Countermeasure: Ensure the default ulimit is overwritten at runtime, only if needed <span>[D5.18]</span></button></h5></div><div id="collapse57" class="collapse" aria-labelledby="heading57" data-parent="#controls"><div class="card-body">The default ulimit is set at the Docker daemon level. However, you may override the default
                        ulimit setting, if needed, during container runtime.&nbsp;
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        ulimit provides control over the resources available to the shell and to processes started by
                        it. Setting system resource limits judiciously saves you from many disasters such as a fork
                        bomb. Sometimes, even friendly users and legitimate processes can overuse system resources and
                        in-turn can make the system unusable.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        The default ulimit set at the Docker daemon level should be honored. If the default ulimit
                        settings are not appropriate for a particular container instance, you may override them as an
                        exception. But, do not make this a practice. If most of the container instances are overriding
                        default ulimit settings, consider changing the default ulimit settings to something that is
                        appropriate for your needs.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Only override the default ulimit settings if needed. For example, to override default ulimit
                        settings start a container as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --ulimit nofile=1024:1024 --interactive --tty centos /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If the ulimits are not set properly, the desired resource control might not be achieved and
                        might even make the system unusable.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading58"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse58" aria-expanded="true" aria-controls="collapse58">Countermeasure: Ensure SELinux security options are set, if applicable <span>[D5.2]</span></button></h5></div><div id="collapse58" class="collapse" aria-labelledby="heading58" data-parent="#controls"><div class="card-body">SELinux is an effective and easy-to-use Linux application security system. It is available on
                        quite a few Linux distributions by default such as Red Hat and Fedora.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        SELinux provides a Mandatory Access Control (MAC) system that greatly augments the default
                        Discretionary Access Control (DAC) model. You can thus add an extra layer of safety by enabling
                        SELinux on your Linux host, if applicable.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        If SELinux is applicable for your Linux OS, use it. You may have to follow the below set of
                        steps:&nbsp;
                        </div>
                        <div>
                        <ol>
                        <li>Set the SELinux State.&nbsp;</li>
                        <li>Set the SELinux Policy.&nbsp;</li>
                        <li>Create or import a SELinux policy template for Docker containers.&nbsp;</li>
                        <li>Start Docker in daemon mode with SELinux enabled. For example, docker daemon
                        --selinux-enabled&nbsp;</li>
                        <li>Start your Docker container using the security options. For example, docker run
                        --interactive --tty --security-opt label=level:TopSecret centos /bin/bash&nbsp;</li>
                        </ol>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        The container (process) would have a set of restrictions as defined in the SELinux policy. If
                        your SELinux policy is mis-configured, then the container may not entirely work as expected.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading59"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse59" aria-expanded="true" aria-controls="collapse59">Countermeasure: Ensure container health is checked at runtime <span>[D5.26]</span></button></h5></div><div id="collapse59" class="collapse" aria-labelledby="heading59" data-parent="#controls"><div class="card-body">If the container image does not have an HEALTHCHECK instruction defined, use --health-cmd
                        parameter at container runtime for checking container health.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        One of the important security triads is availability. If the container image you are using does
                        not have a predefined HEALTHCHECK instruction, use the --health-cmd parameter to check container
                        health at runtime. Based on the reported health status, you could take necessary actions.
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Run the container using --health-cmd and the other parameters. For example, docker run -d
                        --health-cmd='stat /etc/passwd || exit 1' nginx&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading60"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse60" aria-expanded="true" aria-controls="collapse60">Countermeasure: Ensure PIDs cgroup limit is used <span>[D5.28]</span></button></h5></div><div id="collapse60" class="collapse" aria-labelledby="heading60" data-parent="#controls"><div class="card-body">Use --pids-limit flag at container runtime.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Attackers could launch a fork bomb with a single command inside the container. This fork bomb
                        can crash the entire system and requires a restart of the host to make the system functional
                        again. PIDs cgroup --pids-limit will prevent this kind of attack by restricting the number of
                        forks that can happen inside a container at a given time.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Use --pids-limit flag while launching the container with an appropriate value. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run -it --pids-limit 100&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        In the above example, the number of processes allowed to run at any given time is set to 100.
                        After a limit of 100 concurrently running processes is reached, docker would restrict any new
                        process creations.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Set the PIDs limit value as appropriate. Incorrect values might render the containers unusable.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading61"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse61" aria-expanded="true" aria-controls="collapse61">Countermeasure: Ensure Docker's default bridge docker0 is not used <span>[D5.29]</span></button></h5></div><div id="collapse61" class="collapse" aria-labelledby="heading61" data-parent="#controls"><div class="card-body">Do not use Docker's default bridge docker0. Use docker's user-defined networks for container
                        networking.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        Docker connects virtual interfaces created in the bridge mode to a common bridge called docker0.
                        This default networking model is vulnerable to ARP spoofing and MAC flooding attacks since there
                        is no filtering applied.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Follow Docker documentation and set up a user-defined network. Run all the containers in the
                        defined network.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        You have to manage the user-defined networks.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading62"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse62" aria-expanded="true" aria-controls="collapse62">Countermeasure: Ensure SSH is not run within containers <span>[D5.6]</span></button></h5></div><div id="collapse62" class="collapse" aria-labelledby="heading62" data-parent="#controls"><div class="card-body">SSH server should not be running within the container. You should SSH into the Docker host,
                        and use nsenter tool to enter a container from a remote host.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Running SSH within the container increases the complexity of security management by making it&nbsp;
                        </div>
                        <div>
                        <ul>
                        <li>Difficult to manage access policies and security compliance for SSH server&nbsp;</li>
                        <li>Difficult to manage keys and passwords across various containers&nbsp;</li>
                        <li>Difficult to manage security upgrades for SSH server It is possible to have shell
                        access to a container without using SSH.&nbsp;</li>
                        </ul>Needlessly increasing the complexity of security management should be avoided.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Uninstall SSH server from the container and use nsenteror or any other commands such as docker
                        exec or docker attach to interact with the container instance.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker exec --interactive --tty $INSTANCE_ID sh&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        OR&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker attach $INSTANCE_ID&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading63"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse63" aria-expanded="true" aria-controls="collapse63">Countermeasure: Ensure privileged ports are not mapped within containers <span>[D5.7]</span></button></h5></div><div id="collapse63" class="collapse" aria-labelledby="heading63" data-parent="#controls"><div class="card-body">The TCP/IP port numbers below 1024 are considered privileged ports. Normal users and processes
                        are not allowed to use them for various security reasons. Docker allows a container port to be
                        mapped to a privileged port.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        By default, if the user does not specifically declare the container port to host port mapping,
                        Docker automatically and correctly maps the container port to one available in 49153-65535 block
                        on the host. But, Docker allows a container port to be mapped to a privileged port on the host
                        if the user explicitly declared it. This is so because containers are executed with
                        NET_BIND_SERVICE Linux kernel capability that does not restrict the privileged port mapping. The
                        privileged ports receive and transmit various sensitive and privileged data. Allowing containers
                        to use them can bring about serious implications.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not map the container ports to privileged host ports when starting a container. Also, ensure
                        that there is no such container to host privileged port mapping declarations in the Dockerfile.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading64"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse64" aria-expanded="true" aria-controls="collapse64">Countermeasure: Ensure only needed ports are open on the container <span>[D5.8]</span></button></h5></div><div id="collapse64" class="collapse" aria-labelledby="heading64" data-parent="#controls"><div class="card-body">Dockerfile for a container image defines the ports to be opened by default on a container
                        instance. The list of ports may or may not be relevant to the application you are running within
                        the container.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A container can be run just with the ports defined in the Dockerfile for its image or can be
                        arbitrarily passed run time parameters to open a list of ports. Additionally, over time,
                        Dockerfile may undergo various changes and the list of exposed ports may or may not be relevant
                        to the application you are running within the container. Opening unneeded ports increases the
                        attack surface of the container and the containerized application. As a recommended practice, do
                        not open unneeded ports.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Fix the Dockerfile of the container image to expose only needed ports by your containerized
                        application. You can also completely ignore the list of ports defined in the Dockerfile by NOT
                        using -P (UPPERCASE) or --publish-all flag when starting the container. Use the -p (lowercase)
                        or --publish flag to explicitly define the ports that you need for a particular container
                        instance. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --publish 5000 --publish 5001 --publish 5002 centos /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading65"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse65" aria-expanded="true" aria-controls="collapse65">Countermeasure: Ensure the host's network namespace is not shared <span>[D5.9]</span></button></h5></div><div id="collapse65" class="collapse" aria-labelledby="heading65" data-parent="#controls"><div class="card-body">The networking mode on a container when set to --net=host, skips placing the container inside
                        a separate network stack. In essence, this choice tells Docker to not containerize the
                        container's networking. This would network-wise mean that the container lives &quot;outside&quot;
                        in the main Docker host and has full access to its network interfaces.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        This is potentially dangerous. It allows the container process to open low-numbered ports like
                        any other root process. It also allows the container to access network services like D-bus on
                        the Docker host. Thus, a container process can potentially do unexpected things such as shutting
                        down the Docker host. You should not use this option.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not pass --net=host option when starting the container.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading76"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse76" aria-expanded="true" aria-controls="collapse76">Use case: Networking <span>[NETWORKING]</span></button></h5></div><div id="collapse76" class="collapse" aria-labelledby="heading76" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading75"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse75" aria-expanded="true" aria-controls="collapse75">Threat: Attackers gain access to the Docker container by exploiting the vulnerabilities of the network <span>[DOCKER-WIDE-ATTACK-SURFACE-CONTAINER]</span></button></h5></div><div id="collapse75" class="collapse" aria-labelledby="heading75" data-parent="#threats"><div class="card-body">Every point of network interaction is a potential part of the network attack surface
                                having exploitable vulnerabilities.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading74"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse74" aria-expanded="true" aria-controls="collapse74">Weakness: Service is exposed to a wide attack surface <span>[UNRESTRICTED-NETWORK]</span></button></h5></div><div id="collapse74" class="collapse" aria-labelledby="heading74" data-parent="#weaknesses"><div class="card-body">The product is exposed or reachable to an unnecessarily large group of potential attackers. An
                        over-exposure of a component increases the chance of an attacker gaining access to the system
                        through a vulnerability.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading69"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse69" aria-expanded="true" aria-controls="collapse69">Countermeasure: Ensure incoming container traffic is binded to a specific host interface <span>[D5.13]</span></button></h5></div><div id="collapse69" class="collapse" aria-labelledby="heading69" data-parent="#controls"><div class="card-body">By default, Docker containers can make connections to the outside world, but the outside world
                        cannot connect to containers. Each outgoing connection will appear to originate from one of the
                        host machine's own IP addresses. Only allow container services to be contacted through a
                        specific external interface on the host machine.&nbsp;
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        If you have multiple network interfaces on your host machine, the container can accept
                        connections on the exposed ports on any network interface. This might not be desired and may not
                        be secured. Many times a particular interface is exposed externally and services such as
                        intrusion detection, intrusion prevention, firewall, load balancing, etc. are run on those
                        interfaces to screen incoming public traffic.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Hence, you should not accept incoming connections on any interface. You should only allow
                        incoming connections from a particular external interface.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Bind the container port to a specific host interface on the desired host port. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --detach --publish 10.2.3.4:49153:80 nginx&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        In the example above, the container port 80 is bound to the host port on 49153 and would accept
                        incoming connection only from 10.2.3.4 external interface. Impact: None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading70"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse70" aria-expanded="true" aria-controls="collapse70">Countermeasure: Ensure Docker's default bridge docker0 is not used <span>[D5.29]</span></button></h5></div><div id="collapse70" class="collapse" aria-labelledby="heading70" data-parent="#controls"><div class="card-body">Do not use Docker's default bridge docker0. Use docker's user-defined networks for container
                        networking.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        Docker connects virtual interfaces created in the bridge mode to a common bridge called docker0.
                        This default networking model is vulnerable to ARP spoofing and MAC flooding attacks since there
                        is no filtering applied.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Follow Docker documentation and set up a user-defined network. Run all the containers in the
                        defined network.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        You have to manage the user-defined networks.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading71"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse71" aria-expanded="true" aria-controls="collapse71">Countermeasure: Ensure privileged ports are not mapped within containers <span>[D5.7]</span></button></h5></div><div id="collapse71" class="collapse" aria-labelledby="heading71" data-parent="#controls"><div class="card-body">The TCP/IP port numbers below 1024 are considered privileged ports. Normal users and processes
                        are not allowed to use them for various security reasons. Docker allows a container port to be
                        mapped to a privileged port.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        By default, if the user does not specifically declare the container port to host port mapping,
                        Docker automatically and correctly maps the container port to one available in 49153-65535 block
                        on the host. But, Docker allows a container port to be mapped to a privileged port on the host
                        if the user explicitly declared it. This is so because containers are executed with
                        NET_BIND_SERVICE Linux kernel capability that does not restrict the privileged port mapping. The
                        privileged ports receive and transmit various sensitive and privileged data. Allowing containers
                        to use them can bring about serious implications.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not map the container ports to privileged host ports when starting a container. Also, ensure
                        that there is no such container to host privileged port mapping declarations in the Dockerfile.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading72"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse72" aria-expanded="true" aria-controls="collapse72">Countermeasure: Ensure only needed ports are open on the container <span>[D5.8]</span></button></h5></div><div id="collapse72" class="collapse" aria-labelledby="heading72" data-parent="#controls"><div class="card-body">Dockerfile for a container image defines the ports to be opened by default on a container
                        instance. The list of ports may or may not be relevant to the application you are running within
                        the container.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A container can be run just with the ports defined in the Dockerfile for its image or can be
                        arbitrarily passed run time parameters to open a list of ports. Additionally, over time,
                        Dockerfile may undergo various changes and the list of exposed ports may or may not be relevant
                        to the application you are running within the container. Opening unneeded ports increases the
                        attack surface of the container and the containerized application. As a recommended practice, do
                        not open unneeded ports.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Fix the Dockerfile of the container image to expose only needed ports by your containerized
                        application. You can also completely ignore the list of ports defined in the Dockerfile by NOT
                        using -P (UPPERCASE) or --publish-all flag when starting the container. Use the -p (lowercase)
                        or --publish flag to explicitly define the ports that you need for a particular container
                        instance. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker run --interactive --tty --publish 5000 --publish 5001 --publish 5002 centos /bin/bash&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading73"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse73" aria-expanded="true" aria-controls="collapse73">Countermeasure: Ensure the host's network namespace is not shared <span>[D5.9]</span></button></h5></div><div id="collapse73" class="collapse" aria-labelledby="heading73" data-parent="#controls"><div class="card-body">The networking mode on a container when set to --net=host, skips placing the container inside
                        a separate network stack. In essence, this choice tells Docker to not containerize the
                        container's networking. This would network-wise mean that the container lives &quot;outside&quot;
                        in the main Docker host and has full access to its network interfaces.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        This is potentially dangerous. It allows the container process to open low-numbered ports like
                        any other root process. It also allows the container to access network services like D-bus on
                        the Docker host. Thus, a container process can potentially do unexpected things such as shutting
                        down the Docker host. You should not use this option.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not pass --net=host option when starting the container.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-primary"><div class="card-header " id="heading132"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse132" aria-expanded="true" aria-controls="collapse132">Risk pattern: Docker daemon configuration <span>[DOCKER-DAEMON-CONFIGURATION]</span></button></h5></div><div id="collapse132" class="collapse" aria-labelledby="heading132" data-parent="#components"><div class="card-body">This Risk Pattern lists the recommendations that alter and secure the behavior of the Docker daemon. The settings that are under this section affect ALL container instances.<div class="accordion" id="usecases"><div class="card border-black"><div class="card-header " id="heading94"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse94" aria-expanded="true" aria-controls="collapse94">Use case: Authentication and Authorization <span>[AUTHENTICATION AND AUTHORIZATION]</span></button></h5></div><div id="collapse94" class="collapse" aria-labelledby="heading94" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading93"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse93" aria-expanded="true" aria-controls="collapse93">Threat: Attakers gain access without the necessary privileged to the docker daemon configuration <span>[CAPEC-122-DOCKER-DAEMON-CONFIG]</span></button></h5></div><div id="collapse93" class="collapse" aria-labelledby="heading93" data-parent="#threats"><div class="card-body">An adversary is able to exploit features of the target that should be reserved for
                                privileged users or administrators but are exposed to use by lower or non-privileged
                                accounts. Access to sensitive information and functionality must be controlled to ensure
                                that only authorized users are able to access these resources. If access control
                                mechanisms are absent or misconfigured, a user may be able to access resources that are
                                intended only for higher level users. An adversary may be able to exploit this to
                                utilize a less trusted account to gain information and perform activities reserved for
                                more trusted accounts. This attack differs from privilege escalation and other privilege
                                stealing attacks in that the adversary never actually escalates their privileges but
                                instead is able to use a lesser degree of privilege to access resources that should be
                                (but are not) reserved for higher privilege accounts. Likewise, the adversary does not
                                exploit trust or subvert systems - all control functionality is working as configured
                                but the configuration does not adequately protect sensitive resources at an appropriate
                                level.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading83"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse83" aria-expanded="true" aria-controls="collapse83">Weakness: Execution with Unnecessary Privileges <span>[CWE-250]</span></button></h5></div><div id="collapse83" class="collapse" aria-labelledby="heading83" data-parent="#weaknesses"><div class="card-body">The software performs an operation at a privilege level that is higher than the minimum level
                        required, which creates new weaknesses or amplifies the consequences of other weaknesses.

                        New weaknesses can be exposed because running with extra privileges, such as root or
                        Administrator, can disable the normal security checks being performed by the operating system or
                        surrounding environment. Other pre-existing weaknesses can turn into security vulnerabilities if
                        they occur while operating at raised privileges. Privilege management functions can behave in
                        some less-than-obvious ways, and they have different quirks on different platforms. These
                        inconsistencies are particularly pronounced if you are transitioning from one non-root user to
                        another. Signal handlers and spawned processes run at the privilege of the owning process, so if
                        a process is running as root when a signal fires or a sub-process is executed, the signal
                        handler or sub-process will operate with root privileges.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading78"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse78" aria-expanded="true" aria-controls="collapse78">Countermeasure: Ensure that authorization for Docker client commands are enabled <span>[D2.11]</span></button></h5></div><div id="collapse78" class="collapse" aria-labelledby="heading78" data-parent="#controls"><div class="card-body">Use native Docker authorization plugins or a third party authorization mechanism with Docker
                        daemon to manage access to Docker client commands.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker's out-of-the-box authorization model is all or nothing. Any user with
                        permission to access the Docker daemon can run any Docker client command. The same is true for callers using
                        Docker's remote API to contact the daemon. If you require greater access
                        control, you can create authorization plugins and add them to your Docker daemon configuration. Using an authorization
                        plugin, a Docker administrator can configure granular access policies for managing access to
                        Docker daemon. Third party integrations of Docker may implement their own authorization models
                        to require authorization with the Docker daemon outside of docker's native authorization plugin
                        (i.e. Kubernetes, Cloud Foundry, Openshift).&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Step 1: Install/Create an authorization plugin.&nbsp;
                        </div>
                        <div>
                        Step 2: Configure the authorization policy as desired.
                        </div>
                        <div>
                        Step 3: Start the docker daemon as below: dockerd --authorization-plugin=&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Each docker command specifically passes through an authorization plugin mechanism. This might
                        introduce a slight performance drop. Third party use of alternative container engines that
                        utilize the docker daemon may provide alternative mechanisms to provide this security control.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading79"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse79" aria-expanded="true" aria-controls="collapse79">Countermeasure: Ensure daemon-wide custom seccomp profile is applied, if needed <span>[D2.16]</span></button></h5></div><div id="collapse79" class="collapse" aria-labelledby="heading79" data-parent="#controls"><div class="card-body">You can choose to apply your custom seccomp profile at the daemon-wide level if needed and
                        override Docker's default seccomp profile.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        A large number of system calls are exposed to every userland process with many of them going
                        unused for the entire lifetime of the process. Most of the applications do not need all the
                        system calls and thus benefit by having a reduced set of available system calls. The reduced set
                        of system calls reduces the total kernel surface exposed to the application and thus improves
                        application security. You could apply your own custom seccomp profile instead of Docker's
                        default seccomp profile. Alternatively, if Docker's default profile is good for your
                        environment, you can choose to ignore this recommendation.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        By default, Docker's default seccomp profile is applied. If this is good for your environment,
                        no action is necessary. Alternatively, if you choose to apply your own seccomp profile, use the
                        --seccomp-profile flag at daemon start or put it in the daemon runtime parameters file.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --seccomp-profile&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        A misconfigured seccomp profile could possibly interrupt your container environment.
                        Docker-default blocked calls have been carefully scrutinized. These address some critical
                        vulnerabilities/issues within container environments (for example, kernel key ring calls). So,
                        you should be very careful while overriding the defaults.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading80"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse80" aria-expanded="true" aria-controls="collapse80">Countermeasure: Ensure containers are restricted from acquiring new privileges <span>[D2.18]</span></button></h5></div><div id="collapse80" class="collapse" aria-labelledby="heading80" data-parent="#controls"><div class="card-body">Restrict containers from acquiring additional privileges via suid or sgid bits, by default.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A process can set the no_new_priv bit in the kernel. It persists across fork, clone and execve.
                        The no_new_priv bit ensures that the process or its children processes do not gain any
                        additional privileges via suid or sgid bits. This way a lot of dangerous operations become a lot
                        less dangerous because there is no possibility of subverting privileged binaries. Setting this
                        at the daemon level ensures that by default all new containers are restricted from acquiring new
                        privileges.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --no-new-privileges&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        no_new_priv prevents LSMs like SELinux from transitioning to process labels that have access not
                        allowed to the current process.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading81"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse81" aria-expanded="true" aria-controls="collapse81">Countermeasure: Ensure Docker is allowed to make changes to iptables <span>[D2.3]</span></button></h5></div><div id="collapse81" class="collapse" aria-labelledby="heading81" data-parent="#controls"><div class="card-body">Iptables are used to set up, maintain, and inspect the tables of IP packet filter rules in the
                        Linux kernel. Allow the Docker daemon to make changes to the iptables.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        Docker will never make changes to your system iptables rules if you choose to set it so. Docker
                        server would automatically make the needed changes to iptables based on how you choose your
                        networking options for the containers if it is allowed to do so. It is recommended to let Docker
                        server make changes to iptables automatically to avoid networking misconfiguration that might
                        hamper the communication between containers and to the outside world. Additionally, it would
                        save you the hassle of updating iptables every time you choose to run the containers or modify
                        networking options.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not run the Docker daemon with --iptables=false parameter. For example, do not start the
                        Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --iptables=false&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Docker daemon service start requires iptables rules to be enabled before it starts. Any restarts
                        of iptables during docker daemon operation may result in losing docker-created rules. Adding
                        iptables-persistent to your iptables install can assist with mitigating this impact.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading82"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse82" aria-expanded="true" aria-controls="collapse82">Countermeasure: Enable user namespace support <span>[D2.8]</span></button></h5></div><div id="collapse82" class="collapse" aria-labelledby="heading82" data-parent="#controls"><div class="card-body">Enable user namespace support in Docker daemon to utilize container user to host user
                        re-mapping. This recommendation is beneficial where containers you are using do not have an
                        explicit container user defined in the container image. If container images that you are using
                        have a pre-defined non-root user, this recommendation may be skipped since this feature is still
                        in its infancy and might give you unpredictable issues and complexities.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The Linux kernel user namespace support in Docker daemon provides additional security for the
                        Docker host system. It allows a container to have a unique range of user and group IDs which are
                        outside the traditional user and group range utilized by the host system. For example, the root
                        user will have expected administrative privilege inside the container but can effectively be
                        mapped to an unprivileged UID on the host system.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Please consult Docker documentation for various ways in which this can be configured depending
                        upon your requirements. Your steps might also vary based on platform - For example, on Red Hat,
                        sub-UIDs and sub-GIDs mapping creation does not work automatically. You might have to create
                        your own mapping. However, the high-level steps are as below:&nbsp;
                        </div>
                        <div>
                        Step 1: Ensure that the files /etc/subuid and /etc/subgid exist. touch /etc/subuid /etc/subgid&nbsp;
                        </div>
                        <div>
                        Step 2: Start the docker daemon with --userns-remap flag dockerd --userns-remap=default&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        User namespace remapping makes quite a few Docker features incompatible and also currently
                        breaks a few functionalities. Check out the Docker documentation and referenced links for
                        details.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading88"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse88" aria-expanded="true" aria-controls="collapse88">Weakness: Incorrect Default Permissions <span>[CWE-276]</span></button></h5></div><div id="collapse88" class="collapse" aria-labelledby="heading88" data-parent="#weaknesses"><div class="card-body">The software, upon installation, sets incorrect permissions for an object that exposes it to
                        an unintended actor.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading84"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse84" aria-expanded="true" aria-controls="collapse84">Countermeasure: Ensure that authorization for Docker client commands are enabled <span>[D2.11]</span></button></h5></div><div id="collapse84" class="collapse" aria-labelledby="heading84" data-parent="#controls"><div class="card-body">Use native Docker authorization plugins or a third party authorization mechanism with Docker
                        daemon to manage access to Docker client commands.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker's out-of-the-box authorization model is all or nothing. Any user with
                        permission to access the Docker daemon can run any Docker client command. The same is true for callers using
                        Docker's remote API to contact the daemon. If you require greater access
                        control, you can create authorization plugins and add them to your Docker daemon configuration. Using an authorization
                        plugin, a Docker administrator can configure granular access policies for managing access to
                        Docker daemon. Third party integrations of Docker may implement their own authorization models
                        to require authorization with the Docker daemon outside of docker's native authorization plugin
                        (i.e. Kubernetes, Cloud Foundry, Openshift).&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Step 1: Install/Create an authorization plugin.&nbsp;
                        </div>
                        <div>
                        Step 2: Configure the authorization policy as desired.
                        </div>
                        <div>
                        Step 3: Start the docker daemon as below: dockerd --authorization-plugin=&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Each docker command specifically passes through an authorization plugin mechanism. This might
                        introduce a slight performance drop. Third party use of alternative container engines that
                        utilize the docker daemon may provide alternative mechanisms to provide this security control.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading85"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse85" aria-expanded="true" aria-controls="collapse85">Countermeasure: Ensure containers are restricted from acquiring new privileges <span>[D2.18]</span></button></h5></div><div id="collapse85" class="collapse" aria-labelledby="heading85" data-parent="#controls"><div class="card-body">Restrict containers from acquiring additional privileges via suid or sgid bits, by default.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A process can set the no_new_priv bit in the kernel. It persists across fork, clone and execve.
                        The no_new_priv bit ensures that the process or its children processes do not gain any
                        additional privileges via suid or sgid bits. This way a lot of dangerous operations become a lot
                        less dangerous because there is no possibility of subverting privileged binaries. Setting this
                        at the daemon level ensures that by default all new containers are restricted from acquiring new
                        privileges.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --no-new-privileges&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        no_new_priv prevents LSMs like SELinux from transitioning to process labels that have access not
                        allowed to the current process.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading86"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse86" aria-expanded="true" aria-controls="collapse86">Countermeasure: Ensure Docker is allowed to make changes to iptables <span>[D2.3]</span></button></h5></div><div id="collapse86" class="collapse" aria-labelledby="heading86" data-parent="#controls"><div class="card-body">Iptables are used to set up, maintain, and inspect the tables of IP packet filter rules in the
                        Linux kernel. Allow the Docker daemon to make changes to the iptables.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        Docker will never make changes to your system iptables rules if you choose to set it so. Docker
                        server would automatically make the needed changes to iptables based on how you choose your
                        networking options for the containers if it is allowed to do so. It is recommended to let Docker
                        server make changes to iptables automatically to avoid networking misconfiguration that might
                        hamper the communication between containers and to the outside world. Additionally, it would
                        save you the hassle of updating iptables every time you choose to run the containers or modify
                        networking options.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not run the Docker daemon with --iptables=false parameter. For example, do not start the
                        Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --iptables=false&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Docker daemon service start requires iptables rules to be enabled before it starts. Any restarts
                        of iptables during docker daemon operation may result in losing docker-created rules. Adding
                        iptables-persistent to your iptables install can assist with mitigating this impact.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading87"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse87" aria-expanded="true" aria-controls="collapse87">Countermeasure: Ensure insecure registries are not used <span>[D2.4]</span></button></h5></div><div id="collapse87" class="collapse" aria-labelledby="heading87" data-parent="#controls"><div class="card-body">Docker considers a private registry either secure or insecure. By default, registries are
                        considered secure.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A secure registry uses TLS. A copy of registry's CA certificate is placed on the Docker host at
                        /etc/docker/certs.d// directory. An insecure registry is one not having either valid registry
                        certificate or is not using TLS. You should not be using any insecure registries in the
                        production environment. Insecure registries can be tampered with leading to possible compromise
                        of your production system.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Additionally, If a registry is marked as insecure then docker pull, docker push, and docker
                        search commands will not result in an error message and the user might be indefinitely working
                        with insecure registries without ever being notified of potential danger.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not use any insecure registries. For example, do not start the Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --insecure-registry 10.1.0.0/16&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading92"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse92" aria-expanded="true" aria-controls="collapse92">Weakness: Incorrect Permission Assignment for Critical Resource <span>[CWE-732]</span></button></h5></div><div id="collapse92" class="collapse" aria-labelledby="heading92" data-parent="#weaknesses"><div class="card-body">The software specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.

When a resource is given a permission setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.  <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading89"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse89" aria-expanded="true" aria-controls="collapse89">Countermeasure: Ensure that authorization for Docker client commands are enabled <span>[D2.11]</span></button></h5></div><div id="collapse89" class="collapse" aria-labelledby="heading89" data-parent="#controls"><div class="card-body">Use native Docker authorization plugins or a third party authorization mechanism with Docker
                        daemon to manage access to Docker client commands.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker's out-of-the-box authorization model is all or nothing. Any user with
                        permission to access the Docker daemon can run any Docker client command. The same is true for callers using
                        Docker's remote API to contact the daemon. If you require greater access
                        control, you can create authorization plugins and add them to your Docker daemon configuration. Using an authorization
                        plugin, a Docker administrator can configure granular access policies for managing access to
                        Docker daemon. Third party integrations of Docker may implement their own authorization models
                        to require authorization with the Docker daemon outside of docker's native authorization plugin
                        (i.e. Kubernetes, Cloud Foundry, Openshift).&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Step 1: Install/Create an authorization plugin.&nbsp;
                        </div>
                        <div>
                        Step 2: Configure the authorization policy as desired.
                        </div>
                        <div>
                        Step 3: Start the docker daemon as below: dockerd --authorization-plugin=&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Each docker command specifically passes through an authorization plugin mechanism. This might
                        introduce a slight performance drop. Third party use of alternative container engines that
                        utilize the docker daemon may provide alternative mechanisms to provide this security control.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading90"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse90" aria-expanded="true" aria-controls="collapse90">Countermeasure: Ensure containers are restricted from acquiring new privileges <span>[D2.18]</span></button></h5></div><div id="collapse90" class="collapse" aria-labelledby="heading90" data-parent="#controls"><div class="card-body">Restrict containers from acquiring additional privileges via suid or sgid bits, by default.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A process can set the no_new_priv bit in the kernel. It persists across fork, clone and execve.
                        The no_new_priv bit ensures that the process or its children processes do not gain any
                        additional privileges via suid or sgid bits. This way a lot of dangerous operations become a lot
                        less dangerous because there is no possibility of subverting privileged binaries. Setting this
                        at the daemon level ensures that by default all new containers are restricted from acquiring new
                        privileges.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --no-new-privileges&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        no_new_priv prevents LSMs like SELinux from transitioning to process labels that have access not
                        allowed to the current process.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading91"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse91" aria-expanded="true" aria-controls="collapse91">Countermeasure: Ensure Docker is allowed to make changes to iptables <span>[D2.3]</span></button></h5></div><div id="collapse91" class="collapse" aria-labelledby="heading91" data-parent="#controls"><div class="card-body">Iptables are used to set up, maintain, and inspect the tables of IP packet filter rules in the
                        Linux kernel. Allow the Docker daemon to make changes to the iptables.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        Docker will never make changes to your system iptables rules if you choose to set it so. Docker
                        server would automatically make the needed changes to iptables based on how you choose your
                        networking options for the containers if it is allowed to do so. It is recommended to let Docker
                        server make changes to iptables automatically to avoid networking misconfiguration that might
                        hamper the communication between containers and to the outside world. Additionally, it would
                        save you the hassle of updating iptables every time you choose to run the containers or modify
                        networking options.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not run the Docker daemon with --iptables=false parameter. For example, do not start the
                        Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --iptables=false&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Docker daemon service start requires iptables rules to be enabled before it starts. Any restarts
                        of iptables during docker daemon operation may result in losing docker-created rules. Adding
                        iptables-persistent to your iptables install can assist with mitigating this impact.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading114"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse114" aria-expanded="true" aria-controls="collapse114">Use case: General <span>[GENERAL]</span></button></h5></div><div id="collapse114" class="collapse" aria-labelledby="heading114" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading99"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse99" aria-expanded="true" aria-controls="collapse99">Threat: Attackers consume the resources of the Daemon by rapidly engaging to do the target inaccessible or to break the target <span>[CAPEC-125-DAEMON]</span></button></h5></div><div id="collapse99" class="collapse" aria-labelledby="heading99" data-parent="#threats"><div class="card-body">An adversary consumes the resources of a target by rapidly engaging in a large number
                                of interactions with the target. This type of attack generally exposes a weakness in
                                rate limiting or flow. When successful this attack prevents legitimate users from
                                accessing the service and can cause the target to crash. This attack differs from
                                resource depletion through leaks or allocations in that the latter attacks do not rely
                                on the volume of requests made to the target but instead focus on manipulation of the
                                target's operations. The key factor in a flooding attack is the number of requests the
                                adversary can make in a given period of time. The greater this number, the more likely
                                an attack is to succeed against a given target.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading98"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse98" aria-expanded="true" aria-controls="collapse98">Weakness: Uncontrolled Resource Consumption ('Resource Exhaustion') <span>[CWE-400]</span></button></h5></div><div id="collapse98" class="collapse" aria-labelledby="heading98" data-parent="#weaknesses"><div class="card-body">The software does not properly restrict the size or amount of resources that are requested or
                        influenced by an actor, which can be used to consume more resources than intended.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading95"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse95" aria-expanded="true" aria-controls="collapse95">Countermeasure: Ensure base device size is not changed until needed <span>[D2.10]</span></button></h5></div><div id="collapse95" class="collapse" aria-labelledby="heading95" data-parent="#controls"><div class="card-body">In certain circumstances, you might need containers bigger than 10G in size. In these cases,
                        carefully choose the base device size.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The base device size can be increased at daemon restart. Increasing the base device size allows
                        all future images and containers to be of the new base device size. A user can use this option
                        to expand the base device size however shrinking is not permitted. This value affects the
                        system-wide "base" empty filesystem that may already be initialized and inherited by pulled
                        images. Though the file system does not allot the increased size if it is empty, it will use
                        more space for the empty case depending upon the device size. This may cause a denial of service
                        by ending up in file system being over-allocated or full.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not set --storage-opt dm.basesize until needed.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading96"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse96" aria-expanded="true" aria-controls="collapse96">Countermeasure: Ensure the default ulimit is configured appropriately <span>[D2.7]</span></button></h5></div><div id="collapse96" class="collapse" aria-labelledby="heading96" data-parent="#controls"><div class="card-body">Set the default ulimit options as appropriate in your environment.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        ulimit provides control over the resources available to the shell and to processes started by
                        it. Setting system resource limits judiciously saves you from many disasters such as a fork
                        bomb. Sometimes, even friendly users and legitimate processes can overuse system resources and
                        in-turn can make the system unusable.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Setting default ulimit for the Docker daemon would enforce the ulimit for all container
                        instances. You would not need to set up ulimit for each container instance. However, the default
                        ulimit can be overridden during container runtime, if needed. Hence, to control the system
                        resources, define a default ulimit as needed in your environment.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the docker in daemon mode and pass --default-ulimit as argument with respective ulimits as
                        appropriate in your environment. For Example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --default-ulimit nproc=1024:2048 --default-ulimit nofile=100:200&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If the ulimits are not set properly, the desired resource control might not be achieved and
                        might even make the system unusable.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading97"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse97" aria-expanded="true" aria-controls="collapse97">Countermeasure: Ensure the default cgroup usage has been confirmed <span>[D2.9]</span></button></h5></div><div id="collapse97" class="collapse" aria-labelledby="heading97" data-parent="#controls"><div class="card-body">The --cgroup-parent option allows you to set the default cgroup parent to use for all the
                        containers. If there is no specific use case, this setting should be left at its default.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        System administrators typically define cgroups under which containers are supposed to run. Even
                        if cgroups are not explicitly defined by the system administrators, containers run under docker
                        cgroup by default. It is possible to attach to a different cgroup other than that which is the
                        default. This usage should be monitored and confirmed. By attaching to a different cgroup other
                        than the one that is a default, it is possible to share resources unevenly and thus might starve
                        the host for resources.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>
                        </div>
                        <div>
                        The default setting is good enough and can be left as-is. If you want to specifically set a
                        non-default cgroup, pass --cgroup-parent parameter to the docker daemon when starting it. For
                        Example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --cgroup-parent=/foobar&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div><div class="card border-danger"><div class="card-header " id="heading113"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse113" aria-expanded="true" aria-controls="collapse113">Threat: Exploitation of Security Misconfiguration of the docker daemon

 <span>[OWASP A6:2017-DOCKER-DAEMON-CONFIG]</span></button></h5></div><div id="collapse113" class="collapse" aria-labelledby="heading113" data-parent="#threats"><div class="card-body">Attackers will often attempt to exploit unpatched flaws or access default accounts,
                                unused pages, unprotected files and directories, etc to gain unauthorized access or
                                knowledge of the system.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading112"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse112" aria-expanded="true" aria-controls="collapse112">Weakness: Unexpected Environment Condition <span>[CWE-2]</span></button></h5></div><div id="collapse112" class="collapse" aria-labelledby="heading112" data-parent="#weaknesses"><div class="card-body">This is a generic weakness that includes several different situations, they are all related to
                        unexpected environmental conditions and they could be related to:&nbsp;
                        <div>
                        <ul>
                        <li>Misconfiguration.</li>
                        <li>Uncleared buffers, shared memory, files, etc.&nbsp;</li>
                        <li>Problems between the interaction of two different entities that cause unexpected
                        behavior.</li>
                        </ul>
                        </div>
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading100"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse100" aria-expanded="true" aria-controls="collapse100">Countermeasure: Ensure base device size is not changed until needed <span>[D2.10]</span></button></h5></div><div id="collapse100" class="collapse" aria-labelledby="heading100" data-parent="#controls"><div class="card-body">In certain circumstances, you might need containers bigger than 10G in size. In these cases,
                        carefully choose the base device size.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The base device size can be increased at daemon restart. Increasing the base device size allows
                        all future images and containers to be of the new base device size. A user can use this option
                        to expand the base device size however shrinking is not permitted. This value affects the
                        system-wide "base" empty filesystem that may already be initialized and inherited by pulled
                        images. Though the file system does not allot the increased size if it is empty, it will use
                        more space for the empty case depending upon the device size. This may cause a denial of service
                        by ending up in file system being over-allocated or full.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not set --storage-opt dm.basesize until needed.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading101"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse101" aria-expanded="true" aria-controls="collapse101">Countermeasure: Ensure operations on legacy registry (v1) are Disabled <span>[D2.13]</span></button></h5></div><div id="collapse101" class="collapse" aria-labelledby="heading101" data-parent="#controls"><div class="card-body">The latest Docker registry is v2. All operations on the legacy registry version (v1) should be
                        restricted.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker registry v2 brings in many performance and security improvements over v1. It supports
                        container image provenance and other security features such as image signing and verification.
                        Hence, operations on Docker legacy registry should be restricted.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Start the docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --disable-legacy-registry&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        Legacy registry operations would be restricted.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading102"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse102" aria-expanded="true" aria-controls="collapse102">Countermeasure: Ensure live restore is Enabled <span>[D2.14]</span></button></h5></div><div id="collapse102" class="collapse" aria-labelledby="heading102" data-parent="#controls"><div class="card-body">The --live-restore enables full support of daemon-less containers in docker. It ensures that
                        docker does not stop containers on shutdown or restore and properly reconnects to the container
                        when restarted.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        One of the important security triads is availability. Setting --live-restore flag in the docker
                        daemon ensures that container execution is not interrupted when the docker daemon is not
                        available. This also means that it is now easier to update and patch the docker daemon without
                        execution downtime.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Run the docker in daemon mode and pass --live-restore as an argument. For Example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --live-restore&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading103"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse103" aria-expanded="true" aria-controls="collapse103">Countermeasure: Ensure Userland Proxy is Disabled <span>[D2.15]</span></button></h5></div><div id="collapse103" class="collapse" aria-labelledby="heading103" data-parent="#controls"><div class="card-body">The docker daemon starts a userland proxy service for port forwarding whenever a port is
                        exposed. Where hairpin NAT is available, this service is generally superfluous to requirements
                        and can be disabled.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        Docker engine provides two mechanisms for forwarding ports from the host to containers, hairpin
                        NAT, and a userland proxy. In most circumstances, the hairpin NAT mode is preferred as it
                        improves performance and makes use of native Linux iptables functionality instead of an
                        additional component. Where hairpin NAT is available, the userland proxy should be disabled on
                        startup to reduce the attack surface of the installation.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Run the Docker daemon as below: dockerd --userland-proxy=false&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        Some systems with older Linux kernels may not be able to support hairpin NAT and therefore
                        require the userland proxy service. Also, some networking setups can be impacted by the removal
                        of the userland proxy.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading104"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse104" aria-expanded="true" aria-controls="collapse104">Countermeasure: Ensure experimental features are avoided in production <span>[D2.17]</span></button></h5></div><div id="collapse104" class="collapse" aria-labelledby="heading104" data-parent="#controls"><div class="card-body">Avoid experimental features in production.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Experimental is now a runtime docker daemon flag instead of a separate build. Passing
                        --experimental as a runtime flag to the docker daemon, activates experimental features.
                        Experimental is now considered a stable release, but with a couple of features which might not
                        have tested and guaranteed API stability.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not pass --experimental as a runtime parameter to the docker daemon.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading105"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse105" aria-expanded="true" aria-controls="collapse105">Countermeasure: Ensure Docker is allowed to make changes to iptables <span>[D2.3]</span></button></h5></div><div id="collapse105" class="collapse" aria-labelledby="heading105" data-parent="#controls"><div class="card-body">Iptables are used to set up, maintain, and inspect the tables of IP packet filter rules in the
                        Linux kernel. Allow the Docker daemon to make changes to the iptables.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        Docker will never make changes to your system iptables rules if you choose to set it so. Docker
                        server would automatically make the needed changes to iptables based on how you choose your
                        networking options for the containers if it is allowed to do so. It is recommended to let Docker
                        server make changes to iptables automatically to avoid networking misconfiguration that might
                        hamper the communication between containers and to the outside world. Additionally, it would
                        save you the hassle of updating iptables every time you choose to run the containers or modify
                        networking options.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Do not run the Docker daemon with --iptables=false parameter. For example, do not start the
                        Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --iptables=false&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Docker daemon service start requires iptables rules to be enabled before it starts. Any restarts
                        of iptables during docker daemon operation may result in losing docker-created rules. Adding
                        iptables-persistent to your iptables install can assist with mitigating this impact.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading106"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse106" aria-expanded="true" aria-controls="collapse106">Countermeasure: Ensure insecure registries are not used <span>[D2.4]</span></button></h5></div><div id="collapse106" class="collapse" aria-labelledby="heading106" data-parent="#controls"><div class="card-body">Docker considers a private registry either secure or insecure. By default, registries are
                        considered secure.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A secure registry uses TLS. A copy of registry's CA certificate is placed on the Docker host at
                        /etc/docker/certs.d// directory. An insecure registry is one not having either valid registry
                        certificate or is not using TLS. You should not be using any insecure registries in the
                        production environment. Insecure registries can be tampered with leading to possible compromise
                        of your production system.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Additionally, If a registry is marked as insecure then docker pull, docker push, and docker
                        search commands will not result in an error message and the user might be indefinitely working
                        with insecure registries without ever being notified of potential danger.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not use any insecure registries. For example, do not start the Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --insecure-registry 10.1.0.0/16&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading107"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse107" aria-expanded="true" aria-controls="collapse107">Countermeasure: Ensure aufs storage driver is not used <span>[D2.5]</span></button></h5></div><div id="collapse107" class="collapse" aria-labelledby="heading107" data-parent="#controls"><div class="card-body">Do not use aufs as storage driver for your Docker instance.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The aufs storage driver is the oldest storage driver. It is based on a Linux kernel patch-set
                        that is unlikely to be merged into the main Linux kernel. aufs driver is also known to cause
                        some serious kernel crashes. aufs just has legacy support from Docker. Most importantly, aufs is
                        not a supported driver in many Linux distributions using latest Linux kernels.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not explicitly use aufs as storage driver. For example, do not start Docker daemon as below:
                        </div>
                        <blockquote>
                        <div>
                        dockerd --storage-driver aufs&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        aufs is the only storage driver that allows containers to share executable and shared library
                        memory. It might be useful if you are running thousands of containers with the same program or
                        libraries.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading108"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse108" aria-expanded="true" aria-controls="collapse108">Countermeasure: Ensure TLS authentication for Docker daemon is configured <span>[D2.6]</span></button></h5></div><div id="collapse108" class="collapse" aria-labelledby="heading108" data-parent="#controls"><div class="card-body">It is possible to make the Docker daemon listen on a specific IP and port and any other Unix
                        socket other than default Unix socket. Configure TLS authentication to restrict access to Docker
                        daemon via IP and port.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        By default, Docker daemon binds to a non-networked Unix socket and runs with root privileges. If
                        you change the default docker daemon binding to a TCP port or any other Unix socket, anyone with
                        access to that port or socket can have full access to Docker daemon and in turn to the host
                        system. Hence, you should not bind the Docker daemon to another IP/port or a Unix socket. If you
                        must expose the Docker daemon via a network socket, configure TLS authentication for the daemon
                        and Docker Swarm APIs (if using). This would restrict the connections to your Docker daemon over
                        the network to a limited number of clients who could successfully authenticate over TLS.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Follow the steps mentioned in the Docker documentation or other references.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        You would need to manage and guard certificates and keys for Docker daemon and Docker clients.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading109"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse109" aria-expanded="true" aria-controls="collapse109">Countermeasure: Ensure the default ulimit is configured appropriately <span>[D2.7]</span></button></h5></div><div id="collapse109" class="collapse" aria-labelledby="heading109" data-parent="#controls"><div class="card-body">Set the default ulimit options as appropriate in your environment.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        ulimit provides control over the resources available to the shell and to processes started by
                        it. Setting system resource limits judiciously saves you from many disasters such as a fork
                        bomb. Sometimes, even friendly users and legitimate processes can overuse system resources and
                        in-turn can make the system unusable.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Setting default ulimit for the Docker daemon would enforce the ulimit for all container
                        instances. You would not need to set up ulimit for each container instance. However, the default
                        ulimit can be overridden during container runtime, if needed. Hence, to control the system
                        resources, define a default ulimit as needed in your environment.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the docker in daemon mode and pass --default-ulimit as argument with respective ulimits as
                        appropriate in your environment. For Example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --default-ulimit nproc=1024:2048 --default-ulimit nofile=100:200&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If the ulimits are not set properly, the desired resource control might not be achieved and
                        might even make the system unusable.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading110"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse110" aria-expanded="true" aria-controls="collapse110">Countermeasure: Enable user namespace support <span>[D2.8]</span></button></h5></div><div id="collapse110" class="collapse" aria-labelledby="heading110" data-parent="#controls"><div class="card-body">Enable user namespace support in Docker daemon to utilize container user to host user
                        re-mapping. This recommendation is beneficial where containers you are using do not have an
                        explicit container user defined in the container image. If container images that you are using
                        have a pre-defined non-root user, this recommendation may be skipped since this feature is still
                        in its infancy and might give you unpredictable issues and complexities.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The Linux kernel user namespace support in Docker daemon provides additional security for the
                        Docker host system. It allows a container to have a unique range of user and group IDs which are
                        outside the traditional user and group range utilized by the host system. For example, the root
                        user will have expected administrative privilege inside the container but can effectively be
                        mapped to an unprivileged UID on the host system.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Please consult Docker documentation for various ways in which this can be configured depending
                        upon your requirements. Your steps might also vary based on platform - For example, on Red Hat,
                        sub-UIDs and sub-GIDs mapping creation does not work automatically. You might have to create
                        your own mapping. However, the high-level steps are as below:&nbsp;
                        </div>
                        <div>
                        Step 1: Ensure that the files /etc/subuid and /etc/subgid exist. touch /etc/subuid /etc/subgid&nbsp;
                        </div>
                        <div>
                        Step 2: Start the docker daemon with --userns-remap flag dockerd --userns-remap=default&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        User namespace remapping makes quite a few Docker features incompatible and also currently
                        breaks a few functionalities. Check out the Docker documentation and referenced links for
                        details.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading111"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse111" aria-expanded="true" aria-controls="collapse111">Countermeasure: Ensure the default cgroup usage has been confirmed <span>[D2.9]</span></button></h5></div><div id="collapse111" class="collapse" aria-labelledby="heading111" data-parent="#controls"><div class="card-body">The --cgroup-parent option allows you to set the default cgroup parent to use for all the
                        containers. If there is no specific use case, this setting should be left at its default.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        System administrators typically define cgroups under which containers are supposed to run. Even
                        if cgroups are not explicitly defined by the system administrators, containers run under docker
                        cgroup by default. It is possible to attach to a different cgroup other than that which is the
                        default. This usage should be monitored and confirmed. By attaching to a different cgroup other
                        than the one that is a default, it is possible to share resources unevenly and thus might starve
                        the host for resources.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>
                        </div>
                        <div>
                        The default setting is good enough and can be left as-is. If you want to specifically set a
                        non-default cgroup, pass --cgroup-parent parameter to the docker daemon when starting it. For
                        Example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --cgroup-parent=/foobar&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading119"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse119" aria-expanded="true" aria-controls="collapse119">Use case: Logging and Monitoring <span>[LOGGING AND MONITORING]</span></button></h5></div><div id="collapse119" class="collapse" aria-labelledby="heading119" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading118"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse118" aria-expanded="true" aria-controls="collapse118">Threat: Attackers make undetected and unaudited changes to docker daemon configurations <span>[OWASP A10:2017-DAEMON]</span></button></h5></div><div id="collapse118" class="collapse" aria-labelledby="heading118" data-parent="#threats"><div class="card-body">Exploitation of insufficient logging and monitoring is the bedrock of nearly every
                                major incident.
                                Attackers rely on the lack of monitoring and timely response to achieve their goals
                                without being detected.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading117"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse117" aria-expanded="true" aria-controls="collapse117">Weakness: Insufficient Logging <span>[CWE-778]</span></button></h5></div><div id="collapse117" class="collapse" aria-labelledby="heading117" data-parent="#weaknesses"><div class="card-body">When a security-critical event occurs, the software either does not record the event or omits important details about the event when logging it.

When security-critical events are not logged properly, such as a failed login attempt, this can make malicious behavior more difficult to detect and may hinder forensic analysis after an attack succeeds.  <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading115"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse115" aria-expanded="true" aria-controls="collapse115">Countermeasure: Ensure centralized and remote logging is configured <span>[D2.12]</span></button></h5></div><div id="collapse115" class="collapse" aria-labelledby="heading115" data-parent="#controls"><div class="card-body">Docker now supports various log drivers. A preferable way to store logs is the one that
                        supports centralized and remote logging.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Centralized and remote logging ensures that all important log records are safe despite
                        catastrophic events. Docker now supports various such logging drivers. Use the one that suits
                        your environment the best.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Step 1: Setup the desired log driver by following its documentation.&nbsp;
                        </div>
                        <div>
                        Step 2: Start the docker daemon with that logging driver. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --log-driver=syslog --log-opt syslog-address=tcp://192.xxx.xxx.xxx&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading116"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse116" aria-expanded="true" aria-controls="collapse116">Countermeasure: Ensure the logging level is set to 'info' <span>[D2.2]</span></button></h5></div><div id="collapse116" class="collapse" aria-labelledby="heading116" data-parent="#controls"><div class="card-body">Set Docker daemon log level to info.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Setting up an appropriate log level, configures the Docker daemon to log events that you would
                        want to review later. A base log level of info and above would capture all logs except debug
                        logs. Until and unless required, you should not run Docker daemon at debug log level.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --log-level=&quot;info&quot;&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading131"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse131" aria-expanded="true" aria-controls="collapse131">Use case: Networking <span>[NETWORKING]</span></button></h5></div><div id="collapse131" class="collapse" aria-labelledby="heading131" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading123"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse123" aria-expanded="true" aria-controls="collapse123">Threat: Attackers gain access to the Docker daemon by exploiting the vulnerabilities of the network <span>[DOCKER-WIDE-ATTACK-SURFACE-DAEMON]</span></button></h5></div><div id="collapse123" class="collapse" aria-labelledby="heading123" data-parent="#threats"><div class="card-body">Every point of network interaction is a potential part of the network attack surface
                                having exploitable vulnerabilities.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading122"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse122" aria-expanded="true" aria-controls="collapse122">Weakness: Service is exposed to a wide attack surface <span>[UNRESTRICTED-NETWORK]</span></button></h5></div><div id="collapse122" class="collapse" aria-labelledby="heading122" data-parent="#weaknesses"><div class="card-body">The product is exposed or reachable to an unnecessarily large group of potential attackers. An
                        over-exposure of a component increases the chance of an attacker gaining access to the system
                        through a vulnerability.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading120"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse120" aria-expanded="true" aria-controls="collapse120">Countermeasure: Ensure Userland Proxy is Disabled <span>[D2.15]</span></button></h5></div><div id="collapse120" class="collapse" aria-labelledby="heading120" data-parent="#controls"><div class="card-body">The docker daemon starts a userland proxy service for port forwarding whenever a port is
                        exposed. Where hairpin NAT is available, this service is generally superfluous to requirements
                        and can be disabled.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        Docker engine provides two mechanisms for forwarding ports from the host to containers, hairpin
                        NAT, and a userland proxy. In most circumstances, the hairpin NAT mode is preferred as it
                        improves performance and makes use of native Linux iptables functionality instead of an
                        additional component. Where hairpin NAT is available, the userland proxy should be disabled on
                        startup to reduce the attack surface of the installation.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Run the Docker daemon as below: dockerd --userland-proxy=false&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        Some systems with older Linux kernels may not be able to support hairpin NAT and therefore
                        require the userland proxy service. Also, some networking setups can be impacted by the removal
                        of the userland proxy.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading121"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse121" aria-expanded="true" aria-controls="collapse121">Countermeasure: Ensure TLS authentication for Docker daemon is configured <span>[D2.6]</span></button></h5></div><div id="collapse121" class="collapse" aria-labelledby="heading121" data-parent="#controls"><div class="card-body">It is possible to make the Docker daemon listen on a specific IP and port and any other Unix
                        socket other than default Unix socket. Configure TLS authentication to restrict access to Docker
                        daemon via IP and port.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        By default, Docker daemon binds to a non-networked Unix socket and runs with root privileges. If
                        you change the default docker daemon binding to a TCP port or any other Unix socket, anyone with
                        access to that port or socket can have full access to Docker daemon and in turn to the host
                        system. Hence, you should not bind the Docker daemon to another IP/port or a Unix socket. If you
                        must expose the Docker daemon via a network socket, configure TLS authentication for the daemon
                        and Docker Swarm APIs (if using). This would restrict the connections to your Docker daemon over
                        the network to a limited number of clients who could successfully authenticate over TLS.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Follow the steps mentioned in the Docker documentation or other references.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        You would need to manage and guard certificates and keys for Docker daemon and Docker clients.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div><div class="card border-danger"><div class="card-header " id="heading126"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse126" aria-expanded="true" aria-controls="collapse126">Threat: Attackers get sensitive data from docker daemon through sniffing the transmisions between components <span>[CAPEC-157-DAEMON]</span></button></h5></div><div id="collapse126" class="collapse" aria-labelledby="heading126" data-parent="#threats"><div class="card-body">An attacker monitors information transmitted between logical or physical nodes of a
                                network. The attacker need not be able to prevent reception or change content but must
                                simply be able to observe and read the traffic. The attacker might precipitate or
                                indirectly influence the content of the observed transaction, but the attacker is never
                                the intended recipient of the information. Any transmission medium can theoretically be
                                sniffed if the attacker can listen to the contents between the sender and recipient.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading125"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse125" aria-expanded="true" aria-controls="collapse125">Weakness: Use of weak TLS protocols <span>[SSL-WEAK-PROTOCOL]</span></button></h5></div><div id="collapse125" class="collapse" aria-labelledby="heading125" data-parent="#weaknesses"><div class="card-body">A cryptographically weak SSL/TLS protocol could allow an attacker to sniff the traffic or
                        impersonate the server.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading124"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse124" aria-expanded="true" aria-controls="collapse124">Countermeasure: Ensure insecure registries are not used <span>[D2.4]</span></button></h5></div><div id="collapse124" class="collapse" aria-labelledby="heading124" data-parent="#controls"><div class="card-body">Docker considers a private registry either secure or insecure. By default, registries are
                        considered secure.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A secure registry uses TLS. A copy of registry's CA certificate is placed on the Docker host at
                        /etc/docker/certs.d// directory. An insecure registry is one not having either valid registry
                        certificate or is not using TLS. You should not be using any insecure registries in the
                        production environment. Insecure registries can be tampered with leading to possible compromise
                        of your production system.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Additionally, If a registry is marked as insecure then docker pull, docker push, and docker
                        search commands will not result in an error message and the user might be indefinitely working
                        with insecure registries without ever being notified of potential danger.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not use any insecure registries. For example, do not start the Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --insecure-registry 10.1.0.0/16&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div><div class="card border-danger"><div class="card-header " id="heading130"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse130" aria-expanded="true" aria-controls="collapse130">Threat: Attackers get sensitive data from the docker daemon by listening the communication between components <span>[CAPEC-94-DAEMON]</span></button></h5></div><div id="collapse130" class="collapse" aria-labelledby="heading130" data-parent="#threats"><div class="card-body">This type of attack targets the communication between two components (typically client
                                and server). The attacker places himself in the communication channel between the two
                                components. Whenever one component attempts to communicate with the other (data flow,
                                authentication challenges, etc.), the data first goes to the attacker, who has the
                                opportunity to observe or alter it, and it is then passed on to the other component as
                                if it was never intercepted. This interposition is transparent leaving the two
                                compromised components unaware of the potential corruption or leakage of their
                                communications. The potential for Man-in-the-Middle attacks yields an implicit lack of
                                trust in communication or identify between two components.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading129"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse129" aria-expanded="true" aria-controls="collapse129">Weakness: Improper Server's Identity Validation <span>[CWE-287]</span></button></h5></div><div id="collapse129" class="collapse" aria-labelledby="heading129" data-parent="#weaknesses"><div class="card-body">The software does not validate, or incorrectly validates, the server's identity.
                        If the server's identity is not validated, an attacker could spoof a trusted entity by using a
                        man-in-the-middle (MITM) attack. The software might connect to a malicious host while believing
                        it is a trusted host, or the software might be deceived into accepting spoofed data that appears
                        to originate from a trusted host.

                        One way to perform server's authentication is by using X509 certificates over TLS.

                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading127"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse127" aria-expanded="true" aria-controls="collapse127">Countermeasure: Ensure insecure registries are not used <span>[D2.4]</span></button></h5></div><div id="collapse127" class="collapse" aria-labelledby="heading127" data-parent="#controls"><div class="card-body">Docker considers a private registry either secure or insecure. By default, registries are
                        considered secure.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        A secure registry uses TLS. A copy of registry's CA certificate is placed on the Docker host at
                        /etc/docker/certs.d// directory. An insecure registry is one not having either valid registry
                        certificate or is not using TLS. You should not be using any insecure registries in the
                        production environment. Insecure registries can be tampered with leading to possible compromise
                        of your production system.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Additionally, If a registry is marked as insecure then docker pull, docker push, and docker
                        search commands will not result in an error message and the user might be indefinitely working
                        with insecure registries without ever being notified of potential danger.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not use any insecure registries. For example, do not start the Docker daemon as below:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        dockerd --insecure-registry 10.1.0.0/16&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading128"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse128" aria-expanded="true" aria-controls="collapse128">Countermeasure: Ensure TLS authentication for Docker daemon is configured <span>[D2.6]</span></button></h5></div><div id="collapse128" class="collapse" aria-labelledby="heading128" data-parent="#controls"><div class="card-body">It is possible to make the Docker daemon listen on a specific IP and port and any other Unix
                        socket other than default Unix socket. Configure TLS authentication to restrict access to Docker
                        daemon via IP and port.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        By default, Docker daemon binds to a non-networked Unix socket and runs with root privileges. If
                        you change the default docker daemon binding to a TCP port or any other Unix socket, anyone with
                        access to that port or socket can have full access to Docker daemon and in turn to the host
                        system. Hence, you should not bind the Docker daemon to another IP/port or a Unix socket. If you
                        must expose the Docker daemon via a network socket, configure TLS authentication for the daemon
                        and Docker Swarm APIs (if using). This would restrict the connections to your Docker daemon over
                        the network to a limited number of clients who could successfully authenticate over TLS.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Follow the steps mentioned in the Docker documentation or other references.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        You would need to manage and guard certificates and keys for Docker daemon and Docker clients.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-primary"><div class="card-header " id="heading209"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse209" aria-expanded="true" aria-controls="collapse209">Risk pattern: Docker Daemon Configuration Files <span>[DOCKER-DAEMON-CONFIGURATION-FILES]</span></button></h5></div><div id="collapse209" class="collapse" aria-labelledby="heading209" data-parent="#components"><div class="card-body">This Risk Pattern covers Docker related files and directory permissions and ownership. Keeping the files and directories that may contain sensitive parameters secure, is important for correct and secure functioning of Docker daemon.<div class="accordion" id="usecases"><div class="card border-black"><div class="card-header " id="heading208"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse208" aria-expanded="true" aria-controls="collapse208">Use case: Authentication and Authorization <span>[AUTHENTICATION AND AUTHORIZATION]</span></button></h5></div><div id="collapse208" class="collapse" aria-labelledby="heading208" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading207"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse207" aria-expanded="true" aria-controls="collapse207">Threat: Attakers gain access without the necessary privileged to the docker daemon configuration files

 <span>[CAPEC-122-DOCKER-DAEMON-CONFIG-FILES]</span></button></h5></div><div id="collapse207" class="collapse" aria-labelledby="heading207" data-parent="#threats"><div class="card-body">An adversary is able to exploit features of the target that should be reserved for
                                privileged users or administrators but are exposed to use by lower or non-privileged
                                accounts. Access to sensitive information and functionality must be controlled to ensure
                                that only authorized users are able to access these resources. If access control
                                mechanisms are absent or misconfigured, a user may be able to access resources that are
                                intended only for higher level users. An adversary may be able to exploit this to
                                utilize a less trusted account to gain information and perform activities reserved for
                                more trusted accounts. This attack differs from privilege escalation and other privilege
                                stealing attacks in that the adversary never actually escalates their privileges but
                                instead is able to use a lesser degree of privilege to access resources that should be
                                (but are not) reserved for higher privilege accounts. Likewise, the adversary does not
                                exploit trust or subvert systems - all control functionality is working as configured
                                but the configuration does not adequately protect sensitive resources at an appropriate
                                level.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading153"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse153" aria-expanded="true" aria-controls="collapse153">Weakness: Execution with Unnecessary Privileges <span>[CWE-250]</span></button></h5></div><div id="collapse153" class="collapse" aria-labelledby="heading153" data-parent="#weaknesses"><div class="card-body">The software performs an operation at a privilege level that is higher than the minimum level
                        required, which creates new weaknesses or amplifies the consequences of other weaknesses.

                        New weaknesses can be exposed because running with extra privileges, such as root or
                        Administrator, can disable the normal security checks being performed by the operating system or
                        surrounding environment. Other pre-existing weaknesses can turn into security vulnerabilities if
                        they occur while operating at raised privileges. Privilege management functions can behave in
                        some less-than-obvious ways, and they have different quirks on different platforms. These
                        inconsistencies are particularly pronounced if you are transitioning from one non-root user to
                        another. Signal handlers and spawned processes run at the privilege of the owning process, so if
                        a process is running as root when a signal fires or a sub-process is executed, the signal
                        handler or sub-process will operate with root privileges.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading133"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse133" aria-expanded="true" aria-controls="collapse133">Countermeasure: Ensure that docker.service file ownership is set to root:root <span>[D3.1]</span></button></h5></div><div id="collapse133" class="collapse" aria-labelledby="heading133" data-parent="#controls"><div class="card-body">Verify that the docker.service file ownership and group-ownership are correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        docker.service file contains sensitive parameters that may alter the behavior of Docker daemon.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Step 1: Find out the file location: systemctl show -p FragmentPath docker.service&nbsp;
                        </div>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the ownership and group ownership
                        for the file to root. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /usr/lib/systemd/system/docker.service&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading134"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse134" aria-expanded="true" aria-controls="collapse134">Countermeasure: Ensure that TLS CA certificate file permissions are set to 444 or more restrictive <span>[D3.10]</span></button></h5></div><div id="collapse134" class="collapse" aria-labelledby="heading134" data-parent="#controls"><div class="card-body">Verify that the TLS CA certificate file (the file that is passed along with --tlscacert
                        parameter) has permissions of 444 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The TLS CA certificate file should be protected from any tampering. It is used to authenticate
                        Docker server based on given CA certificate. Hence, it must have permissions of 444 to maintain
                        the integrity of the CA certificate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        chmod 444 This would set the file permissions of the TLS CA file to 444.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading135"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse135" aria-expanded="true" aria-controls="collapse135">Countermeasure: Ensure that Docker server certificate file ownership is set to root:root <span>[D3.11]</span></button></h5></div><div id="collapse135" class="collapse" aria-labelledby="heading135" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate file (the file that is passed along with --tlscert
                        parameter) is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        The Docker server certificate file should be protected from any tampering. It is used to
                        authenticate Docker server based on the given server certificate. Hence, it must be owned and
                        group-owned by root to maintain the integrity of the certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the Docker server certificate file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading136"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse136" aria-expanded="true" aria-controls="collapse136">Countermeasure: Ensure that Docker server certificate file permissions are set to 444 or more restrictive <span>[D3.12]</span></button></h5></div><div id="collapse136" class="collapse" aria-labelledby="heading136" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate file (the file that is passed along with --tlscert
                        parameter) has permissions of 444 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        The Docker server certificate file should be protected from any tampering. It is used to
                        authenticate Docker server based on the given server certificate. Hence, it must have
                        permissions of 444 to maintain the integrity of the certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 444&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the file permissions of the Docker server file to 444.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading137"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse137" aria-expanded="true" aria-controls="collapse137">Countermeasure: Ensure that Docker server certificate key file ownership is set to root:root <span>[D3.13]</span></button></h5></div><div id="collapse137" class="collapse" aria-labelledby="heading137" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate key file (the file that is passed along with
                        --tlskey parameter) is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The Docker server certificate key file should be protected from any tampering or unneeded reads.
                        It holds the private key for the Docker server certificate. Hence, it must be owned and
                        group-owned by root to maintain the integrity of the Docker server certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the Docker server certificate key file to
                        root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading138"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse138" aria-expanded="true" aria-controls="collapse138">Countermeasure: Ensure that Docker server certificate key file permissions are set to 400 <span>[D3.14]</span></button></h5></div><div id="collapse138" class="collapse" aria-labelledby="heading138" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate key file (the file that is passed along with
                        --tlskey parameter) has permissions of 400.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The Docker server certificate key file should be protected from any tampering or unneeded reads.
                        It holds the private key for the Docker server certificate. Hence, it must have permissions of
                        400 to maintain the integrity of the Docker server certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 400&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the Docker server certificate key file permissions to 400.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading139"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse139" aria-expanded="true" aria-controls="collapse139">Countermeasure: Ensure that Docker socket file ownership is set to root:docker <span>[D3.15]</span></button></h5></div><div id="collapse139" class="collapse" aria-labelledby="heading139" data-parent="#controls"><div class="card-body">Verify that the Docker socket file is owned by root and group-owned by docker.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker daemon runs as root. The default Unix socket hence must be owned by root. If any other
                        user or process owns this socket, then it might be possible for that non-privileged user or
                        process to interact with Docker daemon. Also, such a non-privileged user or process might
                        interact with containers. This is neither secure nor desired behavior.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Additionally, the Docker installer creates a Unix group called docker. You can add users to this
                        group, and then those users would be able to read and write to default Docker Unix socket. The
                        membership to the docker group is tightly controlled by the system administrator. If any other
                        group owns this socket, then it might be possible for members of that group to interact with
                        Docker daemon. Also, such a group might not be as tightly controlled as the docker group. This
                        is neither secure nor desired behavior. Hence, the default Docker Unix socket file must be owned
                        by root and group-owned by docker to maintain the integrity of the socket file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:docker /var/run/docker.sock&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership to root and group-ownership to docker for default Docker socket
                        file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading140"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse140" aria-expanded="true" aria-controls="collapse140">Countermeasure: Ensure that Docker socket file permissions are set to 660 or more restrictive <span>[D3.16]</span></button></h5></div><div id="collapse140" class="collapse" aria-labelledby="heading140" data-parent="#controls"><div class="card-body">Verify that the Docker socket file has permissions of 660 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Only root and members of docker group should be allowed to read and write to default Docker Unix
                        socket. Hence, the Docket socket file must have permissions of 660 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        </div>
                        <blockquote>
                        <div>
                        <div>
                        chmod 660 /var/run/docker.sock&nbsp;
                        </div>
                        </div>
                        </blockquote>
                        <div>
                        <div>
                        This would set the file permissions of the Docker socket file to 660.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading141"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse141" aria-expanded="true" aria-controls="collapse141">Countermeasure: Ensure that daemon.json file ownership is set to root:root <span>[D3.17]</span></button></h5></div><div id="collapse141" class="collapse" aria-labelledby="heading141" data-parent="#controls"><div class="card-body">Verify that the daemon.json file ownership and group-ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        daemon.json file contains sensitive parameters that may alter the behavior of docker daemon.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker/daemon.json&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading142"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse142" aria-expanded="true" aria-controls="collapse142">Countermeasure: Ensure that daemon.json file permissions are set to 644 or more restrictive <span>[D3.18]</span></button></h5></div><div id="collapse142" class="collapse" aria-labelledby="heading142" data-parent="#controls"><div class="card-body">Verify that the daemon.json file permissions are correctly set to 644 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        daemon.json file contains sensitive parameters that may alter the behavior of docker daemon.
                        Hence, it should be writable only by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 644 /etc/docker/daemon.json&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the file permissions for this file to 644.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading143"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse143" aria-expanded="true" aria-controls="collapse143">Countermeasure: Ensure that /etc/default/docker file ownership is set to root:root <span>[D3.19]</span></button></h5></div><div id="collapse143" class="collapse" aria-labelledby="heading143" data-parent="#controls"><div class="card-body">Verify that the /etc/default/docker file ownership and group-ownership is correctly set to
                        root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/default/docker file contains sensitive parameters that may alter the behavior of docker
                        daemon. Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/default/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading144"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse144" aria-expanded="true" aria-controls="collapse144">Countermeasure: Ensure that docker.service file permissions are set to 644 or more restrictive <span>[D3.2]</span></button></h5></div><div id="collapse144" class="collapse" aria-labelledby="heading144" data-parent="#controls"><div class="card-body">Verify that the docker.service file permissions are correctly set to 644 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        docker.service file contains sensitive parameters that may alter the behavior of Docker daemon.
                        Hence, it should not be writable by any other user other than root to maintain the integrity of
                        the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Step 1: Find out the file location:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        systemctl show -p FragmentPath docker.service&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the file permissions to 644. For
                        example, chmod 644 /usr/lib/systemd/system/docker.service&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading145"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse145" aria-expanded="true" aria-controls="collapse145">Countermeasure: Ensure that /etc/default/docker file permissions are set to 644 or more restrictive <span>[D3.20]</span></button></h5></div><div id="collapse145" class="collapse" aria-labelledby="heading145" data-parent="#controls"><div class="card-body">Verify that the /etc/default/docker file permissions are correctly set to 644 or more
                        restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/default/docker file contains sensitive parameters that may alter the behavior of docker
                        daemon. Hence, it should be writable only by root to maintain the integrity of the file.
                        <br />
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <blockquote>
                        <div>
                        chmod 644 /etc/default/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the file permissions for this file to 644.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading146"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse146" aria-expanded="true" aria-controls="collapse146">Countermeasure: Ensure that docker.socket file ownership is set to root:root <span>[D3.3]</span></button></h5></div><div id="collapse146" class="collapse" aria-labelledby="heading146" data-parent="#controls"><div class="card-body">Verify that the docker.socket file ownership and group ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        docker.socket file contains sensitive parameters that may alter the behavior of Docker remote
                        API. Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Step 1: Find out the file location:
                        </div>
                        <blockquote>
                        <div>
                        systemctl show -p FragmentPath docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the ownership and group ownership
                        for the file to root. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /usr/lib/systemd/system/docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading147"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse147" aria-expanded="true" aria-controls="collapse147">Countermeasure: Ensure that docker.socket file permissions are set to 644 or more restrictive <span>[D3.4]</span></button></h5></div><div id="collapse147" class="collapse" aria-labelledby="heading147" data-parent="#controls"><div class="card-body">Verify that the docker.socket file permissions are correctly set to 644 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        docker.socket file contains sensitive parameters that may alter the behavior of Docker remote
                        API. Hence, it should be writable only by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Step 1: Find out the file location:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        systemctl show -p FragmentPath docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the file permissions to 644. For
                        example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 644 /usr/lib/systemd/system/docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading148"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse148" aria-expanded="true" aria-controls="collapse148">Countermeasure: Ensure that /etc/docker directory ownership is set to root:root <span>[D3.5]</span></button></h5></div><div id="collapse148" class="collapse" aria-labelledby="heading148" data-parent="#controls"><div class="card-body">Verify that the /etc/docker directory ownership and group-ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/docker directory contains certificates and keys in addition to various sensitive files.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the directory.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the directory to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading149"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse149" aria-expanded="true" aria-controls="collapse149">Countermeasure: Ensure that /etc/docker directory permissions are set to 755 or more restrictive <span>[D3.6]</span></button></h5></div><div id="collapse149" class="collapse" aria-labelledby="heading149" data-parent="#controls"><div class="card-body">Verify that the /etc/docker directory permissions are correctly set to 755 or more
                        restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        /etc/docker directory contains certificates and keys in addition to various sensitive files.
                        Hence, it should only be writable by root to maintain the integrity of the directory.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 755 /etc/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the permissions for the directory to 755.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading150"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse150" aria-expanded="true" aria-controls="collapse150">Countermeasure: Ensure that registry certificate file ownership is set to root:root <span>[D3.7]</span></button></h5></div><div id="collapse150" class="collapse" aria-labelledby="heading150" data-parent="#controls"><div class="card-body">Verify that all the registry certificate files (usually found under /etc/docker/certs.d/
                        directory) are owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/docker/certs.d/ directory contains Docker registry certificates. These certificate files
                        must be owned and group-owned by root to maintain the integrity of the certificates.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker/certs.d//*&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the registry certificate files to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading151"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse151" aria-expanded="true" aria-controls="collapse151">Countermeasure: Ensure that registry certificate file permissions are set to 444 or more restrictive <span>[D3.8]</span></button></h5></div><div id="collapse151" class="collapse" aria-labelledby="heading151" data-parent="#controls"><div class="card-body">Verify that all the registry certificate files (usually found under /etc/docker/certs.d/
                        directory) have permissions of 444 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/docker/certs.d/ directory contains Docker registry certificates. These certificate files
                        must have permissions of 444 to maintain the integrity of the certificates.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 444 /etc/docker/certs.d//*
                        </div>
                        </blockquote>
                        <div>
                        This would set the permissions for registry certificate files to 444.
                        <br />
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading152"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse152" aria-expanded="true" aria-controls="collapse152">Countermeasure: Ensure that TLS CA certificate file ownership is set to root:root <span>[D3.9]</span></button></h5></div><div id="collapse152" class="collapse" aria-labelledby="heading152" data-parent="#controls"><div class="card-body">Verify the TLS CA certificate file (the file that is passed along with --tlscacert parameter)
                        is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The TLS CA certificate file should be protected from any tampering. It is used to authenticate
                        Docker server based on given CA certificate. Hence, it must be owned and group-owned by root to
                        maintain the integrity of the CA certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the TLS CA certificate file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading174"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse174" aria-expanded="true" aria-controls="collapse174">Weakness: Incorrect Default Permissions <span>[CWE-276]</span></button></h5></div><div id="collapse174" class="collapse" aria-labelledby="heading174" data-parent="#weaknesses"><div class="card-body">The software, upon installation, sets incorrect permissions for an object which exposes it to
                        an unintended actor.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading154"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse154" aria-expanded="true" aria-controls="collapse154">Countermeasure: Ensure that docker.service file ownership is set to root:root <span>[D3.1]</span></button></h5></div><div id="collapse154" class="collapse" aria-labelledby="heading154" data-parent="#controls"><div class="card-body">Verify that the docker.service file ownership and group-ownership are correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        docker.service file contains sensitive parameters that may alter the behavior of Docker daemon.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Step 1: Find out the file location: systemctl show -p FragmentPath docker.service&nbsp;
                        </div>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the ownership and group ownership
                        for the file to root. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /usr/lib/systemd/system/docker.service&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading155"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse155" aria-expanded="true" aria-controls="collapse155">Countermeasure: Ensure that TLS CA certificate file permissions are set to 444 or more restrictive <span>[D3.10]</span></button></h5></div><div id="collapse155" class="collapse" aria-labelledby="heading155" data-parent="#controls"><div class="card-body">Verify that the TLS CA certificate file (the file that is passed along with --tlscacert
                        parameter) has permissions of 444 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The TLS CA certificate file should be protected from any tampering. It is used to authenticate
                        Docker server based on given CA certificate. Hence, it must have permissions of 444 to maintain
                        the integrity of the CA certificate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        chmod 444 This would set the file permissions of the TLS CA file to 444.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading156"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse156" aria-expanded="true" aria-controls="collapse156">Countermeasure: Ensure that Docker server certificate file ownership is set to root:root <span>[D3.11]</span></button></h5></div><div id="collapse156" class="collapse" aria-labelledby="heading156" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate file (the file that is passed along with --tlscert
                        parameter) is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        The Docker server certificate file should be protected from any tampering. It is used to
                        authenticate Docker server based on the given server certificate. Hence, it must be owned and
                        group-owned by root to maintain the integrity of the certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the Docker server certificate file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading157"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse157" aria-expanded="true" aria-controls="collapse157">Countermeasure: Ensure that Docker server certificate file permissions are set to 444 or more restrictive <span>[D3.12]</span></button></h5></div><div id="collapse157" class="collapse" aria-labelledby="heading157" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate file (the file that is passed along with --tlscert
                        parameter) has permissions of 444 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        The Docker server certificate file should be protected from any tampering. It is used to
                        authenticate Docker server based on the given server certificate. Hence, it must have
                        permissions of 444 to maintain the integrity of the certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 444&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the file permissions of the Docker server file to 444.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading158"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse158" aria-expanded="true" aria-controls="collapse158">Countermeasure: Ensure that Docker server certificate key file ownership is set to root:root <span>[D3.13]</span></button></h5></div><div id="collapse158" class="collapse" aria-labelledby="heading158" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate key file (the file that is passed along with
                        --tlskey parameter) is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The Docker server certificate key file should be protected from any tampering or unneeded reads.
                        It holds the private key for the Docker server certificate. Hence, it must be owned and
                        group-owned by root to maintain the integrity of the Docker server certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the Docker server certificate key file to
                        root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading159"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse159" aria-expanded="true" aria-controls="collapse159">Countermeasure: Ensure that Docker server certificate key file permissions are set to 400 <span>[D3.14]</span></button></h5></div><div id="collapse159" class="collapse" aria-labelledby="heading159" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate key file (the file that is passed along with
                        --tlskey parameter) has permissions of 400.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The Docker server certificate key file should be protected from any tampering or unneeded reads.
                        It holds the private key for the Docker server certificate. Hence, it must have permissions of
                        400 to maintain the integrity of the Docker server certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 400&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the Docker server certificate key file permissions to 400.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading160"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse160" aria-expanded="true" aria-controls="collapse160">Countermeasure: Ensure that Docker socket file ownership is set to root:docker <span>[D3.15]</span></button></h5></div><div id="collapse160" class="collapse" aria-labelledby="heading160" data-parent="#controls"><div class="card-body">Verify that the Docker socket file is owned by root and group-owned by docker.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker daemon runs as root. The default Unix socket hence must be owned by root. If any other
                        user or process owns this socket, then it might be possible for that non-privileged user or
                        process to interact with Docker daemon. Also, such a non-privileged user or process might
                        interact with containers. This is neither secure nor desired behavior.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Additionally, the Docker installer creates a Unix group called docker. You can add users to this
                        group, and then those users would be able to read and write to default Docker Unix socket. The
                        membership to the docker group is tightly controlled by the system administrator. If any other
                        group owns this socket, then it might be possible for members of that group to interact with
                        Docker daemon. Also, such a group might not be as tightly controlled as the docker group. This
                        is neither secure nor desired behavior. Hence, the default Docker Unix socket file must be owned
                        by root and group-owned by docker to maintain the integrity of the socket file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:docker /var/run/docker.sock&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership to root and group-ownership to docker for default Docker socket
                        file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading161"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse161" aria-expanded="true" aria-controls="collapse161">Countermeasure: Ensure that Docker socket file permissions are set to 660 or more restrictive <span>[D3.16]</span></button></h5></div><div id="collapse161" class="collapse" aria-labelledby="heading161" data-parent="#controls"><div class="card-body">Verify that the Docker socket file has permissions of 660 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Only root and members of docker group should be allowed to read and write to default Docker Unix
                        socket. Hence, the Docket socket file must have permissions of 660 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        </div>
                        <blockquote>
                        <div>
                        <div>
                        chmod 660 /var/run/docker.sock&nbsp;
                        </div>
                        </div>
                        </blockquote>
                        <div>
                        <div>
                        This would set the file permissions of the Docker socket file to 660.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading162"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse162" aria-expanded="true" aria-controls="collapse162">Countermeasure: Ensure that daemon.json file ownership is set to root:root <span>[D3.17]</span></button></h5></div><div id="collapse162" class="collapse" aria-labelledby="heading162" data-parent="#controls"><div class="card-body">Verify that the daemon.json file ownership and group-ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        daemon.json file contains sensitive parameters that may alter the behavior of docker daemon.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker/daemon.json&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading163"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse163" aria-expanded="true" aria-controls="collapse163">Countermeasure: Ensure that daemon.json file permissions are set to 644 or more restrictive <span>[D3.18]</span></button></h5></div><div id="collapse163" class="collapse" aria-labelledby="heading163" data-parent="#controls"><div class="card-body">Verify that the daemon.json file permissions are correctly set to 644 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        daemon.json file contains sensitive parameters that may alter the behavior of docker daemon.
                        Hence, it should be writable only by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 644 /etc/docker/daemon.json&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the file permissions for this file to 644.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading164"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse164" aria-expanded="true" aria-controls="collapse164">Countermeasure: Ensure that /etc/default/docker file ownership is set to root:root <span>[D3.19]</span></button></h5></div><div id="collapse164" class="collapse" aria-labelledby="heading164" data-parent="#controls"><div class="card-body">Verify that the /etc/default/docker file ownership and group-ownership is correctly set to
                        root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/default/docker file contains sensitive parameters that may alter the behavior of docker
                        daemon. Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/default/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading165"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse165" aria-expanded="true" aria-controls="collapse165">Countermeasure: Ensure that docker.service file permissions are set to 644 or more restrictive <span>[D3.2]</span></button></h5></div><div id="collapse165" class="collapse" aria-labelledby="heading165" data-parent="#controls"><div class="card-body">Verify that the docker.service file permissions are correctly set to 644 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        docker.service file contains sensitive parameters that may alter the behavior of Docker daemon.
                        Hence, it should not be writable by any other user other than root to maintain the integrity of
                        the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Step 1: Find out the file location:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        systemctl show -p FragmentPath docker.service&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the file permissions to 644. For
                        example, chmod 644 /usr/lib/systemd/system/docker.service&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading166"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse166" aria-expanded="true" aria-controls="collapse166">Countermeasure: Ensure that /etc/default/docker file permissions are set to 644 or more restrictive <span>[D3.20]</span></button></h5></div><div id="collapse166" class="collapse" aria-labelledby="heading166" data-parent="#controls"><div class="card-body">Verify that the /etc/default/docker file permissions are correctly set to 644 or more
                        restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/default/docker file contains sensitive parameters that may alter the behavior of docker
                        daemon. Hence, it should be writable only by root to maintain the integrity of the file.
                        <br />
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <blockquote>
                        <div>
                        chmod 644 /etc/default/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the file permissions for this file to 644.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading167"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse167" aria-expanded="true" aria-controls="collapse167">Countermeasure: Ensure that docker.socket file ownership is set to root:root <span>[D3.3]</span></button></h5></div><div id="collapse167" class="collapse" aria-labelledby="heading167" data-parent="#controls"><div class="card-body">Verify that the docker.socket file ownership and group ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        docker.socket file contains sensitive parameters that may alter the behavior of Docker remote
                        API. Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Step 1: Find out the file location:
                        </div>
                        <blockquote>
                        <div>
                        systemctl show -p FragmentPath docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the ownership and group ownership
                        for the file to root. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /usr/lib/systemd/system/docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading168"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse168" aria-expanded="true" aria-controls="collapse168">Countermeasure: Ensure that docker.socket file permissions are set to 644 or more restrictive <span>[D3.4]</span></button></h5></div><div id="collapse168" class="collapse" aria-labelledby="heading168" data-parent="#controls"><div class="card-body">Verify that the docker.socket file permissions are correctly set to 644 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        docker.socket file contains sensitive parameters that may alter the behavior of Docker remote
                        API. Hence, it should be writable only by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Step 1: Find out the file location:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        systemctl show -p FragmentPath docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the file permissions to 644. For
                        example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 644 /usr/lib/systemd/system/docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading169"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse169" aria-expanded="true" aria-controls="collapse169">Countermeasure: Ensure that /etc/docker directory ownership is set to root:root <span>[D3.5]</span></button></h5></div><div id="collapse169" class="collapse" aria-labelledby="heading169" data-parent="#controls"><div class="card-body">Verify that the /etc/docker directory ownership and group-ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/docker directory contains certificates and keys in addition to various sensitive files.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the directory.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the directory to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading170"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse170" aria-expanded="true" aria-controls="collapse170">Countermeasure: Ensure that /etc/docker directory permissions are set to 755 or more restrictive <span>[D3.6]</span></button></h5></div><div id="collapse170" class="collapse" aria-labelledby="heading170" data-parent="#controls"><div class="card-body">Verify that the /etc/docker directory permissions are correctly set to 755 or more
                        restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        /etc/docker directory contains certificates and keys in addition to various sensitive files.
                        Hence, it should only be writable by root to maintain the integrity of the directory.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 755 /etc/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the permissions for the directory to 755.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading171"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse171" aria-expanded="true" aria-controls="collapse171">Countermeasure: Ensure that registry certificate file ownership is set to root:root <span>[D3.7]</span></button></h5></div><div id="collapse171" class="collapse" aria-labelledby="heading171" data-parent="#controls"><div class="card-body">Verify that all the registry certificate files (usually found under /etc/docker/certs.d/
                        directory) are owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/docker/certs.d/ directory contains Docker registry certificates. These certificate files
                        must be owned and group-owned by root to maintain the integrity of the certificates.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker/certs.d//*&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the registry certificate files to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading172"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse172" aria-expanded="true" aria-controls="collapse172">Countermeasure: Ensure that registry certificate file permissions are set to 444 or more restrictive <span>[D3.8]</span></button></h5></div><div id="collapse172" class="collapse" aria-labelledby="heading172" data-parent="#controls"><div class="card-body">Verify that all the registry certificate files (usually found under /etc/docker/certs.d/
                        directory) have permissions of 444 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/docker/certs.d/ directory contains Docker registry certificates. These certificate files
                        must have permissions of 444 to maintain the integrity of the certificates.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 444 /etc/docker/certs.d//*
                        </div>
                        </blockquote>
                        <div>
                        This would set the permissions for registry certificate files to 444.
                        <br />
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading173"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse173" aria-expanded="true" aria-controls="collapse173">Countermeasure: Ensure that TLS CA certificate file ownership is set to root:root <span>[D3.9]</span></button></h5></div><div id="collapse173" class="collapse" aria-labelledby="heading173" data-parent="#controls"><div class="card-body">Verify the TLS CA certificate file (the file that is passed along with --tlscacert parameter)
                        is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The TLS CA certificate file should be protected from any tampering. It is used to authenticate
                        Docker server based on given CA certificate. Hence, it must be owned and group-owned by root to
                        maintain the integrity of the CA certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the TLS CA certificate file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading185"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse185" aria-expanded="true" aria-controls="collapse185">Weakness: Incorrect Ownership Assignment <span>[CWE-708]</span></button></h5></div><div id="collapse185" class="collapse" aria-labelledby="heading185" data-parent="#weaknesses"><div class="card-body">The software assigns an owner to a resource, but the owner is outside of the intended control
                        sphere.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading175"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse175" aria-expanded="true" aria-controls="collapse175">Countermeasure: Ensure that docker.service file ownership is set to root:root <span>[D3.1]</span></button></h5></div><div id="collapse175" class="collapse" aria-labelledby="heading175" data-parent="#controls"><div class="card-body">Verify that the docker.service file ownership and group-ownership are correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        docker.service file contains sensitive parameters that may alter the behavior of Docker daemon.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Step 1: Find out the file location: systemctl show -p FragmentPath docker.service&nbsp;
                        </div>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the ownership and group ownership
                        for the file to root. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /usr/lib/systemd/system/docker.service&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading176"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse176" aria-expanded="true" aria-controls="collapse176">Countermeasure: Ensure that Docker server certificate file ownership is set to root:root <span>[D3.11]</span></button></h5></div><div id="collapse176" class="collapse" aria-labelledby="heading176" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate file (the file that is passed along with --tlscert
                        parameter) is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        The Docker server certificate file should be protected from any tampering. It is used to
                        authenticate Docker server based on the given server certificate. Hence, it must be owned and
                        group-owned by root to maintain the integrity of the certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the Docker server certificate file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading177"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse177" aria-expanded="true" aria-controls="collapse177">Countermeasure: Ensure that Docker server certificate key file ownership is set to root:root <span>[D3.13]</span></button></h5></div><div id="collapse177" class="collapse" aria-labelledby="heading177" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate key file (the file that is passed along with
                        --tlskey parameter) is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The Docker server certificate key file should be protected from any tampering or unneeded reads.
                        It holds the private key for the Docker server certificate. Hence, it must be owned and
                        group-owned by root to maintain the integrity of the Docker server certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the Docker server certificate key file to
                        root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading178"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse178" aria-expanded="true" aria-controls="collapse178">Countermeasure: Ensure that Docker socket file ownership is set to root:docker <span>[D3.15]</span></button></h5></div><div id="collapse178" class="collapse" aria-labelledby="heading178" data-parent="#controls"><div class="card-body">Verify that the Docker socket file is owned by root and group-owned by docker.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker daemon runs as root. The default Unix socket hence must be owned by root. If any other
                        user or process owns this socket, then it might be possible for that non-privileged user or
                        process to interact with Docker daemon. Also, such a non-privileged user or process might
                        interact with containers. This is neither secure nor desired behavior.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Additionally, the Docker installer creates a Unix group called docker. You can add users to this
                        group, and then those users would be able to read and write to default Docker Unix socket. The
                        membership to the docker group is tightly controlled by the system administrator. If any other
                        group owns this socket, then it might be possible for members of that group to interact with
                        Docker daemon. Also, such a group might not be as tightly controlled as the docker group. This
                        is neither secure nor desired behavior. Hence, the default Docker Unix socket file must be owned
                        by root and group-owned by docker to maintain the integrity of the socket file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:docker /var/run/docker.sock&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership to root and group-ownership to docker for default Docker socket
                        file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading179"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse179" aria-expanded="true" aria-controls="collapse179">Countermeasure: Ensure that daemon.json file ownership is set to root:root <span>[D3.17]</span></button></h5></div><div id="collapse179" class="collapse" aria-labelledby="heading179" data-parent="#controls"><div class="card-body">Verify that the daemon.json file ownership and group-ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        daemon.json file contains sensitive parameters that may alter the behavior of docker daemon.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker/daemon.json&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading180"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse180" aria-expanded="true" aria-controls="collapse180">Countermeasure: Ensure that /etc/default/docker file ownership is set to root:root <span>[D3.19]</span></button></h5></div><div id="collapse180" class="collapse" aria-labelledby="heading180" data-parent="#controls"><div class="card-body">Verify that the /etc/default/docker file ownership and group-ownership is correctly set to
                        root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/default/docker file contains sensitive parameters that may alter the behavior of docker
                        daemon. Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/default/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading181"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse181" aria-expanded="true" aria-controls="collapse181">Countermeasure: Ensure that docker.socket file ownership is set to root:root <span>[D3.3]</span></button></h5></div><div id="collapse181" class="collapse" aria-labelledby="heading181" data-parent="#controls"><div class="card-body">Verify that the docker.socket file ownership and group ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        docker.socket file contains sensitive parameters that may alter the behavior of Docker remote
                        API. Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Step 1: Find out the file location:
                        </div>
                        <blockquote>
                        <div>
                        systemctl show -p FragmentPath docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the ownership and group ownership
                        for the file to root. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /usr/lib/systemd/system/docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading182"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse182" aria-expanded="true" aria-controls="collapse182">Countermeasure: Ensure that /etc/docker directory ownership is set to root:root <span>[D3.5]</span></button></h5></div><div id="collapse182" class="collapse" aria-labelledby="heading182" data-parent="#controls"><div class="card-body">Verify that the /etc/docker directory ownership and group-ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/docker directory contains certificates and keys in addition to various sensitive files.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the directory.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the directory to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading183"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse183" aria-expanded="true" aria-controls="collapse183">Countermeasure: Ensure that registry certificate file ownership is set to root:root <span>[D3.7]</span></button></h5></div><div id="collapse183" class="collapse" aria-labelledby="heading183" data-parent="#controls"><div class="card-body">Verify that all the registry certificate files (usually found under /etc/docker/certs.d/
                        directory) are owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/docker/certs.d/ directory contains Docker registry certificates. These certificate files
                        must be owned and group-owned by root to maintain the integrity of the certificates.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker/certs.d//*&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the registry certificate files to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading184"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse184" aria-expanded="true" aria-controls="collapse184">Countermeasure: Ensure that TLS CA certificate file ownership is set to root:root <span>[D3.9]</span></button></h5></div><div id="collapse184" class="collapse" aria-labelledby="heading184" data-parent="#controls"><div class="card-body">Verify the TLS CA certificate file (the file that is passed along with --tlscacert parameter)
                        is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The TLS CA certificate file should be protected from any tampering. It is used to authenticate
                        Docker server based on given CA certificate. Hence, it must be owned and group-owned by root to
                        maintain the integrity of the CA certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the TLS CA certificate file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading206"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse206" aria-expanded="true" aria-controls="collapse206">Weakness: Incorrect Permission Assignment for Critical Resource <span>[CWE-732]</span></button></h5></div><div id="collapse206" class="collapse" aria-labelledby="heading206" data-parent="#weaknesses"><div class="card-body">The software specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.

When a resource is given a permission setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.  <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading186"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse186" aria-expanded="true" aria-controls="collapse186">Countermeasure: Ensure that docker.service file ownership is set to root:root <span>[D3.1]</span></button></h5></div><div id="collapse186" class="collapse" aria-labelledby="heading186" data-parent="#controls"><div class="card-body">Verify that the docker.service file ownership and group-ownership are correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        docker.service file contains sensitive parameters that may alter the behavior of Docker daemon.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Step 1: Find out the file location: systemctl show -p FragmentPath docker.service&nbsp;
                        </div>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the ownership and group ownership
                        for the file to root. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /usr/lib/systemd/system/docker.service&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading187"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse187" aria-expanded="true" aria-controls="collapse187">Countermeasure: Ensure that TLS CA certificate file permissions are set to 444 or more restrictive <span>[D3.10]</span></button></h5></div><div id="collapse187" class="collapse" aria-labelledby="heading187" data-parent="#controls"><div class="card-body">Verify that the TLS CA certificate file (the file that is passed along with --tlscacert
                        parameter) has permissions of 444 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The TLS CA certificate file should be protected from any tampering. It is used to authenticate
                        Docker server based on given CA certificate. Hence, it must have permissions of 444 to maintain
                        the integrity of the CA certificate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        chmod 444 This would set the file permissions of the TLS CA file to 444.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading188"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse188" aria-expanded="true" aria-controls="collapse188">Countermeasure: Ensure that Docker server certificate file ownership is set to root:root <span>[D3.11]</span></button></h5></div><div id="collapse188" class="collapse" aria-labelledby="heading188" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate file (the file that is passed along with --tlscert
                        parameter) is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        The Docker server certificate file should be protected from any tampering. It is used to
                        authenticate Docker server based on the given server certificate. Hence, it must be owned and
                        group-owned by root to maintain the integrity of the certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the Docker server certificate file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading189"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse189" aria-expanded="true" aria-controls="collapse189">Countermeasure: Ensure that Docker server certificate file permissions are set to 444 or more restrictive <span>[D3.12]</span></button></h5></div><div id="collapse189" class="collapse" aria-labelledby="heading189" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate file (the file that is passed along with --tlscert
                        parameter) has permissions of 444 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        The Docker server certificate file should be protected from any tampering. It is used to
                        authenticate Docker server based on the given server certificate. Hence, it must have
                        permissions of 444 to maintain the integrity of the certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 444&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the file permissions of the Docker server file to 444.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading190"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse190" aria-expanded="true" aria-controls="collapse190">Countermeasure: Ensure that Docker server certificate key file ownership is set to root:root <span>[D3.13]</span></button></h5></div><div id="collapse190" class="collapse" aria-labelledby="heading190" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate key file (the file that is passed along with
                        --tlskey parameter) is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The Docker server certificate key file should be protected from any tampering or unneeded reads.
                        It holds the private key for the Docker server certificate. Hence, it must be owned and
                        group-owned by root to maintain the integrity of the Docker server certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the Docker server certificate key file to
                        root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading191"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse191" aria-expanded="true" aria-controls="collapse191">Countermeasure: Ensure that Docker server certificate key file permissions are set to 400 <span>[D3.14]</span></button></h5></div><div id="collapse191" class="collapse" aria-labelledby="heading191" data-parent="#controls"><div class="card-body">Verify that the Docker server certificate key file (the file that is passed along with
                        --tlskey parameter) has permissions of 400.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The Docker server certificate key file should be protected from any tampering or unneeded reads.
                        It holds the private key for the Docker server certificate. Hence, it must have permissions of
                        400 to maintain the integrity of the Docker server certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 400&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the Docker server certificate key file permissions to 400.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading192"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse192" aria-expanded="true" aria-controls="collapse192">Countermeasure: Ensure that Docker socket file ownership is set to root:docker <span>[D3.15]</span></button></h5></div><div id="collapse192" class="collapse" aria-labelledby="heading192" data-parent="#controls"><div class="card-body">Verify that the Docker socket file is owned by root and group-owned by docker.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker daemon runs as root. The default Unix socket hence must be owned by root. If any other
                        user or process owns this socket, then it might be possible for that non-privileged user or
                        process to interact with Docker daemon. Also, such a non-privileged user or process might
                        interact with containers. This is neither secure nor desired behavior.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Additionally, the Docker installer creates a Unix group called docker. You can add users to this
                        group, and then those users would be able to read and write to default Docker Unix socket. The
                        membership to the docker group is tightly controlled by the system administrator. If any other
                        group owns this socket, then it might be possible for members of that group to interact with
                        Docker daemon. Also, such a group might not be as tightly controlled as the docker group. This
                        is neither secure nor desired behavior. Hence, the default Docker Unix socket file must be owned
                        by root and group-owned by docker to maintain the integrity of the socket file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:docker /var/run/docker.sock&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership to root and group-ownership to docker for default Docker socket
                        file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading193"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse193" aria-expanded="true" aria-controls="collapse193">Countermeasure: Ensure that Docker socket file permissions are set to 660 or more restrictive <span>[D3.16]</span></button></h5></div><div id="collapse193" class="collapse" aria-labelledby="heading193" data-parent="#controls"><div class="card-body">Verify that the Docker socket file has permissions of 660 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Only root and members of docker group should be allowed to read and write to default Docker Unix
                        socket. Hence, the Docket socket file must have permissions of 660 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        </div>
                        <blockquote>
                        <div>
                        <div>
                        chmod 660 /var/run/docker.sock&nbsp;
                        </div>
                        </div>
                        </blockquote>
                        <div>
                        <div>
                        This would set the file permissions of the Docker socket file to 660.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading194"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse194" aria-expanded="true" aria-controls="collapse194">Countermeasure: Ensure that daemon.json file ownership is set to root:root <span>[D3.17]</span></button></h5></div><div id="collapse194" class="collapse" aria-labelledby="heading194" data-parent="#controls"><div class="card-body">Verify that the daemon.json file ownership and group-ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        daemon.json file contains sensitive parameters that may alter the behavior of docker daemon.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker/daemon.json&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading195"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse195" aria-expanded="true" aria-controls="collapse195">Countermeasure: Ensure that daemon.json file permissions are set to 644 or more restrictive <span>[D3.18]</span></button></h5></div><div id="collapse195" class="collapse" aria-labelledby="heading195" data-parent="#controls"><div class="card-body">Verify that the daemon.json file permissions are correctly set to 644 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        daemon.json file contains sensitive parameters that may alter the behavior of docker daemon.
                        Hence, it should be writable only by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 644 /etc/docker/daemon.json&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the file permissions for this file to 644.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading196"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse196" aria-expanded="true" aria-controls="collapse196">Countermeasure: Ensure that /etc/default/docker file ownership is set to root:root <span>[D3.19]</span></button></h5></div><div id="collapse196" class="collapse" aria-labelledby="heading196" data-parent="#controls"><div class="card-body">Verify that the /etc/default/docker file ownership and group-ownership is correctly set to
                        root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/default/docker file contains sensitive parameters that may alter the behavior of docker
                        daemon. Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/default/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading197"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse197" aria-expanded="true" aria-controls="collapse197">Countermeasure: Ensure that docker.service file permissions are set to 644 or more restrictive <span>[D3.2]</span></button></h5></div><div id="collapse197" class="collapse" aria-labelledby="heading197" data-parent="#controls"><div class="card-body">Verify that the docker.service file permissions are correctly set to 644 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        docker.service file contains sensitive parameters that may alter the behavior of Docker daemon.
                        Hence, it should not be writable by any other user other than root to maintain the integrity of
                        the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Step 1: Find out the file location:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        systemctl show -p FragmentPath docker.service&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the file permissions to 644. For
                        example, chmod 644 /usr/lib/systemd/system/docker.service&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading198"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse198" aria-expanded="true" aria-controls="collapse198">Countermeasure: Ensure that /etc/default/docker file permissions are set to 644 or more restrictive <span>[D3.20]</span></button></h5></div><div id="collapse198" class="collapse" aria-labelledby="heading198" data-parent="#controls"><div class="card-body">Verify that the /etc/default/docker file permissions are correctly set to 644 or more
                        restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/default/docker file contains sensitive parameters that may alter the behavior of docker
                        daemon. Hence, it should be writable only by root to maintain the integrity of the file.
                        <br />
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <blockquote>
                        <div>
                        chmod 644 /etc/default/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the file permissions for this file to 644.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading199"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse199" aria-expanded="true" aria-controls="collapse199">Countermeasure: Ensure that docker.socket file ownership is set to root:root <span>[D3.3]</span></button></h5></div><div id="collapse199" class="collapse" aria-labelledby="heading199" data-parent="#controls"><div class="card-body">Verify that the docker.socket file ownership and group ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        docker.socket file contains sensitive parameters that may alter the behavior of Docker remote
                        API. Hence, it should be owned and group-owned by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Step 1: Find out the file location:
                        </div>
                        <blockquote>
                        <div>
                        systemctl show -p FragmentPath docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the ownership and group ownership
                        for the file to root. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /usr/lib/systemd/system/docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading200"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse200" aria-expanded="true" aria-controls="collapse200">Countermeasure: Ensure that docker.socket file permissions are set to 644 or more restrictive <span>[D3.4]</span></button></h5></div><div id="collapse200" class="collapse" aria-labelledby="heading200" data-parent="#controls"><div class="card-body">Verify that the docker.socket file permissions are correctly set to 644 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        docker.socket file contains sensitive parameters that may alter the behavior of Docker remote
                        API. Hence, it should be writable only by root to maintain the integrity of the file.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Step 1: Find out the file location:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        systemctl show -p FragmentPath docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
                        execute the below command with the correct file path to set the file permissions to 644. For
                        example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 644 /usr/lib/systemd/system/docker.socket&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading201"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse201" aria-expanded="true" aria-controls="collapse201">Countermeasure: Ensure that /etc/docker directory ownership is set to root:root <span>[D3.5]</span></button></h5></div><div id="collapse201" class="collapse" aria-labelledby="heading201" data-parent="#controls"><div class="card-body">Verify that the /etc/docker directory ownership and group-ownership is correctly set to root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/docker directory contains certificates and keys in addition to various sensitive files.
                        Hence, it should be owned and group-owned by root to maintain the integrity of the directory.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the directory to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading202"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse202" aria-expanded="true" aria-controls="collapse202">Countermeasure: Ensure that /etc/docker directory permissions are set to 755 or more restrictive <span>[D3.6]</span></button></h5></div><div id="collapse202" class="collapse" aria-labelledby="heading202" data-parent="#controls"><div class="card-body">Verify that the /etc/docker directory permissions are correctly set to 755 or more
                        restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        /etc/docker directory contains certificates and keys in addition to various sensitive files.
                        Hence, it should only be writable by root to maintain the integrity of the directory.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 755 /etc/docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the permissions for the directory to 755.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading203"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse203" aria-expanded="true" aria-controls="collapse203">Countermeasure: Ensure that registry certificate file ownership is set to root:root <span>[D3.7]</span></button></h5></div><div id="collapse203" class="collapse" aria-labelledby="heading203" data-parent="#controls"><div class="card-body">Verify that all the registry certificate files (usually found under /etc/docker/certs.d/
                        directory) are owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/docker/certs.d/ directory contains Docker registry certificates. These certificate files
                        must be owned and group-owned by root to maintain the integrity of the certificates.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <blockquote>
                        <div>
                        chown root:root /etc/docker/certs.d//*&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the registry certificate files to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading204"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse204" aria-expanded="true" aria-controls="collapse204">Countermeasure: Ensure that registry certificate file permissions are set to 444 or more restrictive <span>[D3.8]</span></button></h5></div><div id="collapse204" class="collapse" aria-labelledby="heading204" data-parent="#controls"><div class="card-body">Verify that all the registry certificate files (usually found under /etc/docker/certs.d/
                        directory) have permissions of 444 or more restrictive.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        /etc/docker/certs.d/ directory contains Docker registry certificates. These certificate files
                        must have permissions of 444 to maintain the integrity of the certificates.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chmod 444 /etc/docker/certs.d//*
                        </div>
                        </blockquote>
                        <div>
                        This would set the permissions for registry certificate files to 444.
                        <br />
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading205"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse205" aria-expanded="true" aria-controls="collapse205">Countermeasure: Ensure that TLS CA certificate file ownership is set to root:root <span>[D3.9]</span></button></h5></div><div id="collapse205" class="collapse" aria-labelledby="heading205" data-parent="#controls"><div class="card-body">Verify the TLS CA certificate file (the file that is passed along with --tlscacert parameter)
                        is owned and group-owned by root.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The TLS CA certificate file should be protected from any tampering. It is used to authenticate
                        Docker server based on given CA certificate. Hence, it must be owned and group-owned by root to
                        maintain the integrity of the CA certificate.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        chown root:root&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        This would set the ownership and group-ownership for the TLS CA certificate file to root.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-primary"><div class="card-header " id="heading210"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse210" aria-expanded="true" aria-controls="collapse210">Risk pattern: Docker Environment <span>[DOCKER]</span></button></h5></div><div id="collapse210" class="collapse" aria-labelledby="heading210" data-parent="#components"><div class="card-body"><div class="accordion" id="usecases"></div></div></div></div><div class="card border-primary"><div class="card-header " id="heading244"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse244" aria-expanded="true" aria-controls="collapse244">Risk pattern: Docker Images and Build File <span>[DOCKER-IMAGES-BUILD-FILE]</span></button></h5></div><div id="collapse244" class="collapse" aria-labelledby="heading244" data-parent="#components"><div class="card-body">Container base images and build files govern the fundamentals of how a container instance from a particular image would behave. Ensuring that you are using proper base images and appropriate build files can be very important for building your containerized infrastructure. This Risk Pattern contains some of the recommendations that you should follow for container base images and build files to ensure that your containerized infrastructure is secure.<div class="accordion" id="usecases"><div class="card border-black"><div class="card-header " id="heading221"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse221" aria-expanded="true" aria-controls="collapse221">Use case: Authentication and Authorization <span>[AUTHENTICATION AND AUTHORIZATION]</span></button></h5></div><div id="collapse221" class="collapse" aria-labelledby="heading221" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading220"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse220" aria-expanded="true" aria-controls="collapse220">Threat: Attakers gain access without the necessary privileged to the docker images and build files <span>[CAPEC-122-DOCKER-IMAGES-BUILD-FILES]</span></button></h5></div><div id="collapse220" class="collapse" aria-labelledby="heading220" data-parent="#threats"><div class="card-body">An adversary is able to exploit features of the target that should be reserved for
                                privileged users or administrators but are exposed to use by lower or non-privileged
                                accounts. Access to sensitive information and functionality must be controlled to ensure
                                that only authorized users are able to access these resources. If access control
                                mechanisms are absent or misconfigured, a user may be able to access resources that are
                                intended only for higher level users. An adversary may be able to exploit this to
                                utilize a less trusted account to gain information and perform activities reserved for
                                more trusted accounts. This attack differs from privilege escalation and other privilege
                                stealing attacks in that the adversary never actually escalates their privileges but
                                instead is able to use a lesser degree of privilege to access resources that should be
                                (but are not) reserved for higher privilege accounts. Likewise, the adversary does not
                                exploit trust or subvert systems - all control functionality is working as configured
                                but the configuration does not adequately protect sensitive resources at an appropriate
                                level.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading213"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse213" aria-expanded="true" aria-controls="collapse213">Weakness: Execution with Unnecessary Privileges <span>[CWE-250]</span></button></h5></div><div id="collapse213" class="collapse" aria-labelledby="heading213" data-parent="#weaknesses"><div class="card-body">The software performs an operation at a privilege level that is higher than the minimum level
                        required, which creates new weaknesses or amplifies the consequences of other weaknesses.

                        New weaknesses can be exposed because running with extra privileges, such as root or
                        Administrator, can disable the normal security checks being performed by the operating system or
                        surrounding environment. Other pre-existing weaknesses can turn into security vulnerabilities if
                        they occur while operating at raised privileges. Privilege management functions can behave in
                        some less-than-obvious ways, and they have different quirks on different platforms. These
                        inconsistencies are particularly pronounced if you are transitioning from one non-root user to
                        another. Signal handlers and spawned processes run at the privilege of the owning process, so if
                        a process is running as root when a signal fires or a sub-process is executed, the signal
                        handler or sub-process will operate with root privileges.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading211"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse211" aria-expanded="true" aria-controls="collapse211">Countermeasure: Ensure a user for the container has been created <span>[D4.1]</span></button></h5></div><div id="collapse211" class="collapse" aria-labelledby="heading211" data-parent="#controls"><div class="card-body">Create a non-root user for the container in the Dockerfile for the container image.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        It is a good practice to run the container as a non-root user, if possible. Though user
                        namespace mapping is now available, if a user is already defined in the container image, the
                        container is run as that user by default and specific user namespace remapping is not required.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Ensure that the Dockerfile for the container image contains the below instruction: USER Where
                        username or ID refers to the user that could be found in the container base image. If there is
                        no specific user created in the container base image, then add a useradd command to add the
                        specific user before USER instruction. For example, add the below lines in the Dockerfile to
                        create a user in the container:
                        </div>
                        </div>
                        <blockquote>
                        <div>
                        <div>
                        RUN useradd -d /home/username -m -s /bin/bash username USER username&nbsp;
                        </div>
                        </div>
                        </blockquote>
                        <div>
                        <div>
                        Note: If there are users in the image that the containers do not need, consider deleting them.
                        After deleting those users, commit the image and then generate new instances of containers for
                        use.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading212"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse212" aria-expanded="true" aria-controls="collapse212">Countermeasure: Ensure setuid and setgid permissions are removed in the images <span>[D4.8]</span></button></h5></div><div id="collapse212" class="collapse" aria-labelledby="heading212" data-parent="#controls"><div class="card-body">Removing setuid and setgid permissions in the images will help prevent privilege escalation
                        attacks in the containers.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        setuid and setgid permissions could be used for elevating privileges. While these permissions
                        are at times legitimately needed, these could potentially be used in privilege escalation
                        attacks. Thus, you should consider dropping these permissions for the packages which do not need
                        them within the images.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Allow setuid and setgid permissions only on executables which need them. You could remove these
                        permissions during build time by adding the following command in your Dockerfile, preferably
                        towards the end of the Dockerfile:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        RUN find / -perm +6000 -type f -exec chmod a-s {} \; || true&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Above command breaks all the executables that depend on setuid or setgid permissions including
                        the legitimate ones. Hence, be careful to modify the command to suit your requirements so that
                        it does not drop the permissions of legitimate programs. This requires a careful examination of
                        each executable and fine tuning the permissions.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading216"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse216" aria-expanded="true" aria-controls="collapse216">Weakness: Incorrect Default Permissions <span>[CWE-276]</span></button></h5></div><div id="collapse216" class="collapse" aria-labelledby="heading216" data-parent="#weaknesses"><div class="card-body">The software, upon installation, sets incorrect permissions for an object that exposes it to
                        an unintended actor.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading214"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse214" aria-expanded="true" aria-controls="collapse214">Countermeasure: Ensure a user for the container has been created <span>[D4.1]</span></button></h5></div><div id="collapse214" class="collapse" aria-labelledby="heading214" data-parent="#controls"><div class="card-body">Create a non-root user for the container in the Dockerfile for the container image.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        It is a good practice to run the container as a non-root user, if possible. Though user
                        namespace mapping is now available, if a user is already defined in the container image, the
                        container is run as that user by default and specific user namespace remapping is not required.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Ensure that the Dockerfile for the container image contains the below instruction: USER Where
                        username or ID refers to the user that could be found in the container base image. If there is
                        no specific user created in the container base image, then add a useradd command to add the
                        specific user before USER instruction. For example, add the below lines in the Dockerfile to
                        create a user in the container:
                        </div>
                        </div>
                        <blockquote>
                        <div>
                        <div>
                        RUN useradd -d /home/username -m -s /bin/bash username USER username&nbsp;
                        </div>
                        </div>
                        </blockquote>
                        <div>
                        <div>
                        Note: If there are users in the image that the containers do not need, consider deleting them.
                        After deleting those users, commit the image and then generate new instances of containers for
                        use.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading215"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse215" aria-expanded="true" aria-controls="collapse215">Countermeasure: Ensure setuid and setgid permissions are removed in the images <span>[D4.8]</span></button></h5></div><div id="collapse215" class="collapse" aria-labelledby="heading215" data-parent="#controls"><div class="card-body">Removing setuid and setgid permissions in the images will help prevent privilege escalation
                        attacks in the containers.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        setuid and setgid permissions could be used for elevating privileges. While these permissions
                        are at times legitimately needed, these could potentially be used in privilege escalation
                        attacks. Thus, you should consider dropping these permissions for the packages which do not need
                        them within the images.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Allow setuid and setgid permissions only on executables which need them. You could remove these
                        permissions during build time by adding the following command in your Dockerfile, preferably
                        towards the end of the Dockerfile:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        RUN find / -perm +6000 -type f -exec chmod a-s {} \; || true&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Above command breaks all the executables that depend on setuid or setgid permissions including
                        the legitimate ones. Hence, be careful to modify the command to suit your requirements so that
                        it does not drop the permissions of legitimate programs. This requires a careful examination of
                        each executable and fine tuning the permissions.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading219"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse219" aria-expanded="true" aria-controls="collapse219">Weakness: Incorrect Permission Assignment for Critical Resource <span>[CWE-732]</span></button></h5></div><div id="collapse219" class="collapse" aria-labelledby="heading219" data-parent="#weaknesses"><div class="card-body">The software specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.

When a resource is given a permission setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.  <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading217"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse217" aria-expanded="true" aria-controls="collapse217">Countermeasure: Ensure a user for the container has been created <span>[D4.1]</span></button></h5></div><div id="collapse217" class="collapse" aria-labelledby="heading217" data-parent="#controls"><div class="card-body">Create a non-root user for the container in the Dockerfile for the container image.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        It is a good practice to run the container as a non-root user, if possible. Though user
                        namespace mapping is now available, if a user is already defined in the container image, the
                        container is run as that user by default and specific user namespace remapping is not required.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:&nbsp;</b>
                        </div>
                        <div>
                        Ensure that the Dockerfile for the container image contains the below instruction: USER Where
                        username or ID refers to the user that could be found in the container base image. If there is
                        no specific user created in the container base image, then add a useradd command to add the
                        specific user before USER instruction. For example, add the below lines in the Dockerfile to
                        create a user in the container:
                        </div>
                        </div>
                        <blockquote>
                        <div>
                        <div>
                        RUN useradd -d /home/username -m -s /bin/bash username USER username&nbsp;
                        </div>
                        </div>
                        </blockquote>
                        <div>
                        <div>
                        Note: If there are users in the image that the containers do not need, consider deleting them.
                        After deleting those users, commit the image and then generate new instances of containers for
                        use.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading218"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse218" aria-expanded="true" aria-controls="collapse218">Countermeasure: Ensure setuid and setgid permissions are removed in the images <span>[D4.8]</span></button></h5></div><div id="collapse218" class="collapse" aria-labelledby="heading218" data-parent="#controls"><div class="card-body">Removing setuid and setgid permissions in the images will help prevent privilege escalation
                        attacks in the containers.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        setuid and setgid permissions could be used for elevating privileges. While these permissions
                        are at times legitimately needed, these could potentially be used in privilege escalation
                        attacks. Thus, you should consider dropping these permissions for the packages which do not need
                        them within the images.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Allow setuid and setgid permissions only on executables which need them. You could remove these
                        permissions during build time by adding the following command in your Dockerfile, preferably
                        towards the end of the Dockerfile:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        RUN find / -perm +6000 -type f -exec chmod a-s {} \; || true&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Above command breaks all the executables that depend on setuid or setgid permissions including
                        the legitimate ones. Hence, be careful to modify the command to suit your requirements so that
                        it does not drop the permissions of legitimate programs. This requires a careful examination of
                        each executable and fine tuning the permissions.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading236"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse236" aria-expanded="true" aria-controls="collapse236">Use case: General <span>[GENERAL]</span></button></h5></div><div id="collapse236" class="collapse" aria-labelledby="heading236" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading224"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse224" aria-expanded="true" aria-controls="collapse224">Threat: Attackers gain access to the docker images and build files by using sensitive data which was found embedded within it <span>[CAPEC-37-IMAGES-BUILD-FILE]</span></button></h5></div><div id="collapse224" class="collapse" aria-labelledby="heading224" data-parent="#threats"><div class="card-body">An attacker examines a target system to find sensitive data that has been embedded
                                within it. This information can reveal confidential contents, such as account numbers or
                                individual keys/credentials that can be used as an intermediate step in a larger attack.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading223"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse223" aria-expanded="true" aria-controls="collapse223">Weakness: Secrets, API keys and or passwords are included in the source code or online repositories <span>[CWE-312]</span></button></h5></div><div id="collapse223" class="collapse" aria-labelledby="heading223" data-parent="#weaknesses"><div class="card-body">API keys, passwords or secrets included in the source code or in the configuration files can be leaked to users with access to the code. This access can be incidentally granted by publishing the source code on a package-form or an online, public repository.

          The unauthorized access to any of those secrets could lead to a compromise of sensitive data or a system.<div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading222"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse222" aria-expanded="true" aria-controls="collapse222">Countermeasure: Ensure secrets are not stored in Dockerfiles <span>[D4.10]</span></button></h5></div><div id="collapse222" class="collapse" aria-labelledby="heading222" data-parent="#controls"><div class="card-body">Do not store any secrets in Dockerfiles.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Dockerfiles could be backtracked easily by using native Docker commands such as docker history
                        and various tools and utilities. Also, as a general practice, image publishers provide
                        Dockerfiles to build the credibility for their images. Hence, the secrets within these
                        Dockerfiles could be easily exposed and potentially be exploited.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Do not store any kind of secrets within Dockerfiles.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        You would need to identify a way to handle secrets for your Docker images.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div><div class="card border-danger"><div class="card-header " id="heading235"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse235" aria-expanded="true" aria-controls="collapse235">Threat: Exploitation of Security Misconfiguration of the Docker images and build files security

 <span>[OWASP A6:2017-DOCKER-IMAGES-BUILD-FILES]</span></button></h5></div><div id="collapse235" class="collapse" aria-labelledby="heading235" data-parent="#threats"><div class="card-body">Attackers will often attempt to exploit unpatched flaws or access default accounts,
                                unused pages, unprotected files and directories, etc to gain unauthorized access or
                                knowledge of the system.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading226"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse226" aria-expanded="true" aria-controls="collapse226">Weakness: Recommended security patches are not applied <span>[UNPATCHED-SERVER]</span></button></h5></div><div id="collapse226" class="collapse" aria-labelledby="heading226" data-parent="#weaknesses"><div class="card-body">When patches are not applied in a timely manner then the server or system could be vulnerable
                        to known security issues. These issues could be used by an attacker to gain access to the
                        system.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading225"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse225" aria-expanded="true" aria-controls="collapse225">Countermeasure: Ensure images are scanned and rebuilt to include security patches <span>[D4.4]</span></button></h5></div><div id="collapse225" class="collapse" aria-labelledby="heading225" data-parent="#controls"><div class="card-body">Images should be scanned "frequently" for any vulnerabilities. Rebuild the images to include
                        patches and then instantiate new containers from it.

                        Rationale:
                        Vulnerabilities are loopholes/bugs that can be exploited and security patches are updates to
                        resolve these vulnerabilities. We can use image vulnerability scanning tools to find any kind of
                        vulnerabilities within the images and then check for available patches to mitigate these
                        vulnerabilities. Patches update the system to the most recent code base. Being on the current
                        code base is important because that's where vendors focus on fixing problems. Evaluate the
                        security patches before applying and follow the patching best practices.
                        Also, it would be better if, image vulnerability scanning tools could perform binary level
                        analysis or hash based verification instead of just version string matching.

                        Remediation:
                        Follow the below steps to rebuild the images with security patches:

                        Step 1: Pull all the base images (i.e., given your set of Dockerfiles, extract all images
                        declared in FROM instructions, and re-pull them to check for an updated/patched versions). Patch
                        the packages within the images too.

                        docker pull

                        Step 2: Force a rebuild of each image:

                        docker build --no-cache

                        Step 3: Restart all containers with the updated images.
                        You could also use ONBUILD directive in the Dockerfile to trigger particular update instructions
                        for images that you know are used as base images frequently.

                        Impact:
                        None
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading234"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse234" aria-expanded="true" aria-controls="collapse234">Weakness: Unexpected Environment Condition <span>[CWE-2]</span></button></h5></div><div id="collapse234" class="collapse" aria-labelledby="heading234" data-parent="#weaknesses"><div class="card-body">This is a generic weakness that includes several different situations, they are all related to
                        unexpected environmental conditions and they could be related to:&nbsp;
                        <div>
                        <ul>
                        <li>Misconfiguration.</li>
                        <li>Uncleared buffers, shared memory, files, etc.&nbsp;</li>
                        <li>Problems between the interaction of two different entities that cause unexpected
                        behavior.</li>
                        </ul>
                        </div>
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading227"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse227" aria-expanded="true" aria-controls="collapse227">Countermeasure: Ensure verified packages only are Installed <span>[D4.11]</span></button></h5></div><div id="collapse227" class="collapse" aria-labelledby="heading227" data-parent="#controls"><div class="card-body">Verify authenticity of the packages before installing them in the image.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        Verifying authenticity of the packages is essential for building a secure container image.
                        Tampered packages could potentially be malicious or have some known vulnerabilities that could
                        be exploited.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Use GPG keys for downloading and verifying packages or any other secure package distribution
                        mechanism of your choice.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading228"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse228" aria-expanded="true" aria-controls="collapse228">Countermeasure: Ensure unnecessary packages are not installed in the container <span>[D4.3]</span></button></h5></div><div id="collapse228" class="collapse" aria-labelledby="heading228" data-parent="#controls"><div class="card-body">Containers tend to be minimal and slimmed down versions of the Operating System. Do not
                        install anything that does not justify the purpose of the container.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Bloated containers with unnecessary software could possibly increase the attack surface of the
                        container. This also voids the concept of minimal and slimmed down versions of container images.
                        Hence, do not install anything else apart from what is truly needed for the purpose of the
                        container.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        At the outset, do not install anything on the container that does not justify the purpose. If
                        the image had some packages that your container does not use, uninstall them. Consider using a
                        minimal base image rather than the standard Redhat/Centos/Debian images if you can. Some of the
                        options include BusyBox and Alpine. Not only does this trim your image size from &gt;150Mb
                        to ~20 Mb, there are also fewer tools and paths to escalate privileges. You can even remove the
                        package installer as a final hardening measure for leaf/production containers.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading229"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse229" aria-expanded="true" aria-controls="collapse229">Countermeasure: Ensure Content trust for Docker is Enabled <span>[D4.5]</span></button></h5></div><div id="collapse229" class="collapse" aria-labelledby="heading229" data-parent="#controls"><div class="card-body">Content trust is disabled by default. You should enable it.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Content trust provides the ability to use digital signatures for data sent to and received from
                        remote Docker registries. These signatures allow client-side verification of the integrity and
                        publisher of specific image tags. This ensures provenance of container images.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        To enable content trust in a bash shell, enter the following command:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        export DOCKER_CONTENT_TRUST=1&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Alternatively, set this environment variable in your profile file so that content trust in
                        enabled on every login.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        In an environment where DOCKER_CONTENT_TRUST is set, you are required to follow trust procedures
                        while working with images - build, create, pull, push and run. You can use the
                        --disable-content-trust flag to run individual operations on tagged images without content trust
                        on an as-needed basis but that defeats the purpose of enabling content trust and hence, should
                        be avoided wherever possible.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Note: Content trust is currently only available for users of the public Docker Hub. It is
                        currently not available for the Docker Trusted Registry or for private registries.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading230"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse230" aria-expanded="true" aria-controls="collapse230">Countermeasure: Ensure HEALTHCHECK instructions have been added to the container image <span>[D4.6]</span></button></h5></div><div id="collapse230" class="collapse" aria-labelledby="heading230" data-parent="#controls"><div class="card-body">Add HEALTHCHECK instruction in your docker container images to perform the health check on
                        running containers.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        One of the important security triads is availability. Adding HEALTHCHECK instruction to your
                        container image ensures that the docker engine periodically checks the running container
                        instances against that instruction to ensure that the instances are still working. Based on the
                        reported health status, the docker engine could then exit non-working containers and instantiate
                        new ones.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Follow Docker documentation and rebuild your container image with HEALTHCHECK instruction.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading231"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse231" aria-expanded="true" aria-controls="collapse231">Countermeasure: Ensure update instructions are not used alone in the Dockerfile <span>[D4.7]</span></button></h5></div><div id="collapse231" class="collapse" aria-labelledby="heading231" data-parent="#controls"><div class="card-body">Do not use update instructions such as apt-get update alone or in a single line in the
                        Dockerfile.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Adding the update instructions in a single line on the Dockerfile will cache the update layer.
                        Thus, when you build any image later using the same instruction, previously cached update layer
                        will be used. This could potentially deny any fresh updates to go in the later builds.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Use update instructions along with install instructions (or any other) and version pinning for
                        packages while installing them. This would bust the cache and force extraction of the required
                        versions.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Alternatively, you could use --no-cache flag during docker build process to avoid using cached
                        layers.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading232"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse232" aria-expanded="true" aria-controls="collapse232">Countermeasure: Ensure setuid and setgid permissions are removed in the images <span>[D4.8]</span></button></h5></div><div id="collapse232" class="collapse" aria-labelledby="heading232" data-parent="#controls"><div class="card-body">Removing setuid and setgid permissions in the images will help prevent privilege escalation
                        attacks in the containers.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        setuid and setgid permissions could be used for elevating privileges. While these permissions
                        are at times legitimately needed, these could potentially be used in privilege escalation
                        attacks. Thus, you should consider dropping these permissions for the packages which do not need
                        them within the images.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Allow setuid and setgid permissions only on executables which need them. You could remove these
                        permissions during build time by adding the following command in your Dockerfile, preferably
                        towards the end of the Dockerfile:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        RUN find / -perm +6000 -type f -exec chmod a-s {} \; || true&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Above command breaks all the executables that depend on setuid or setgid permissions including
                        the legitimate ones. Hence, be careful to modify the command to suit your requirements so that
                        it does not drop the permissions of legitimate programs. This requires a careful examination of
                        each executable and fine tuning the permissions.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading233"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse233" aria-expanded="true" aria-controls="collapse233">Countermeasure: Ensure COPY is used instead of ADD in Dockerfile <span>[D4.9]</span></button></h5></div><div id="collapse233" class="collapse" aria-labelledby="heading233" data-parent="#controls"><div class="card-body">Use COPY instruction instead of ADD instruction in the Dockerfile.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        COPY instruction just copies the files from the local host machine to the container file system.
                        ADD instruction potentially could retrieve files from remote URLs and perform operations such as
                        unpacking. Thus, ADD instruction introduces risks such as adding malicious files from URLs
                        without scanning and unpacking procedures for vulnerabilities.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Use COPY instructions in Dockerfiles.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        You would need to take care of the functionalities provided by ADD instructions such as fetching
                        files from remote URLs.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading243"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse243" aria-expanded="true" aria-controls="collapse243">Use case: Networking <span>[NETWORKING]</span></button></h5></div><div id="collapse243" class="collapse" aria-labelledby="heading243" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading239"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse239" aria-expanded="true" aria-controls="collapse239">Threat: Attackers get sensitive data from docker images and build files through sniffing the transmisions between components <span>[CAPEC-157-IMAGES-BUILD-FILES]</span></button></h5></div><div id="collapse239" class="collapse" aria-labelledby="heading239" data-parent="#threats"><div class="card-body">An attacker monitors information transmitted between logical or physical nodes of a
                                network. The attacker need not be able to prevent reception or change content but must
                                simply be able to observe and read the traffic. The attacker might precipitate or
                                indirectly influence the content of the observed transaction, but the attacker is never
                                the intended recipient of the information. Any transmission medium can theoretically be
                                sniffed if the attacker can listen to the contents between the sender and recipient.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading238"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse238" aria-expanded="true" aria-controls="collapse238">Weakness: The component uses a weak TLS implementation <span>[CWE-327]</span></button></h5></div><div id="collapse238" class="collapse" aria-labelledby="heading238" data-parent="#weaknesses"><div class="card-body">The use of an unverified TLS library could lead to the use of weak or faulty implementations
                        of the TLS protocol and cipher suites.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading237"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse237" aria-expanded="true" aria-controls="collapse237">Countermeasure: Ensure Content trust for Docker is Enabled <span>[D4.5]</span></button></h5></div><div id="collapse237" class="collapse" aria-labelledby="heading237" data-parent="#controls"><div class="card-body">Content trust is disabled by default. You should enable it.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Content trust provides the ability to use digital signatures for data sent to and received from
                        remote Docker registries. These signatures allow client-side verification of the integrity and
                        publisher of specific image tags. This ensures provenance of container images.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        To enable content trust in a bash shell, enter the following command:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        export DOCKER_CONTENT_TRUST=1&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Alternatively, set this environment variable in your profile file so that content trust in
                        enabled on every login.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        In an environment where DOCKER_CONTENT_TRUST is set, you are required to follow trust procedures
                        while working with images - build, create, pull, push and run. You can use the
                        --disable-content-trust flag to run individual operations on tagged images without content trust
                        on an as-needed basis but that defeats the purpose of enabling content trust and hence, should
                        be avoided wherever possible.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Note: Content trust is currently only available for users of the public Docker Hub. It is
                        currently not available for the Docker Trusted Registry or for private registries.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div><div class="card border-danger"><div class="card-header " id="heading242"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse242" aria-expanded="true" aria-controls="collapse242">Threat: Attackers steal sensitive data from the docker images and build files by listening the communication between components <span>[CAPEC-94-IMAGES-BUILD-FILES]</span></button></h5></div><div id="collapse242" class="collapse" aria-labelledby="heading242" data-parent="#threats"><div class="card-body">This type of attack targets the communication between two components (typically client
                                and server). The attacker places himself in the communication channel between the two
                                components. Whenever one component attempts to communicate with the other (data flow,
                                authentication challenges, etc.), the data first goes to the attacker, who has the
                                opportunity to observe or alter it, and it is then passed on to the other component as
                                if it was never intercepted. This interposition is transparent leaving the two
                                compromised components unaware of the potential corruption or leakage of their
                                communications. The potential for Man-in-the-Middle attacks yields an implicit lack of
                                trust in communication or identify between two components.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading241"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse241" aria-expanded="true" aria-controls="collapse241">Weakness: Improper Server's Identity Validation <span>[CWE-287]</span></button></h5></div><div id="collapse241" class="collapse" aria-labelledby="heading241" data-parent="#weaknesses"><div class="card-body">The software does not validate, or incorrectly validates, the server's identity.
                        If the server's identity is not validated, an attacker could spoof a trusted entity by using a
                        man-in-the-middle (MITM) attack. The software might connect to a malicious host while believing
                        it is a trusted host, or the software might be deceived into accepting spoofed data that appears
                        to originate from a trusted host.

                        One way to perform server's authentication is by using X509 certificates over TLS.

                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading240"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse240" aria-expanded="true" aria-controls="collapse240">Countermeasure: Ensure Content trust for Docker is Enabled <span>[D4.5]</span></button></h5></div><div id="collapse240" class="collapse" aria-labelledby="heading240" data-parent="#controls"><div class="card-body">Content trust is disabled by default. You should enable it.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Content trust provides the ability to use digital signatures for data sent to and received from
                        remote Docker registries. These signatures allow client-side verification of the integrity and
                        publisher of specific image tags. This ensures provenance of container images.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        To enable content trust in a bash shell, enter the following command:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        export DOCKER_CONTENT_TRUST=1&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Alternatively, set this environment variable in your profile file so that content trust in
                        enabled on every login.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        In an environment where DOCKER_CONTENT_TRUST is set, you are required to follow trust procedures
                        while working with images - build, create, pull, push and run. You can use the
                        --disable-content-trust flag to run individual operations on tagged images without content trust
                        on an as-needed basis but that defeats the purpose of enabling content trust and hence, should
                        be avoided wherever possible.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Note: Content trust is currently only available for users of the public Docker Hub. It is
                        currently not available for the Docker Trusted Registry or for private registries.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-primary"><div class="card-header " id="heading300"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse300" aria-expanded="true" aria-controls="collapse300">Risk pattern: Docker Linux Host OS <span>[DOCKER-LINUX-HOST-OS]</span></button></h5></div><div id="collapse300" class="collapse" aria-labelledby="heading300" data-parent="#components"><div class="card-body">The Docker Linux Host OS Risk Pattern is based on CIS Docker CE 17.06 Benchmark, which provides prescriptive guidance for establishing a secure configuration posture for Docker CE container version 17.06 and pertains to the Linux Host OS.<div class="accordion" id="usecases"><div class="card border-black"><div class="card-header " id="heading258"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse258" aria-expanded="true" aria-controls="collapse258">Use case: Authentication and Authorization <span>[AUTHENTICATION AND AUTHORIZATION]</span></button></h5></div><div id="collapse258" class="collapse" aria-labelledby="heading258" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading257"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse257" aria-expanded="true" aria-controls="collapse257">Threat: Attakers gain access without the necessary privileged to Linux security configurations <span>[CAPEC-122-DOCKER-LINUX]</span></button></h5></div><div id="collapse257" class="collapse" aria-labelledby="heading257" data-parent="#threats"><div class="card-body">An adversary is able to exploit features of the target that should be reserved for
                                privileged users or administrators but are exposed to use by lower or non-privileged
                                accounts. Access to sensitive information and functionality must be controlled to ensure
                                that only authorized users are able to access these resources. If access control
                                mechanisms are absent or misconfigured, a user may be able to access resources that are
                                intended only for higher level users. An adversary may be able to exploit this to
                                utilize a less trusted account to gain information and perform activities reserved for
                                more trusted accounts. This attack differs from privilege escalation and other privilege
                                stealing attacks in that the adversary never actually escalates their privileges but
                                instead is able to use a lesser degree of privilege to access resources that should be
                                (but are not) reserved for higher privilege accounts. Likewise, the adversary does not
                                exploit trust or subvert systems - all control functionality is working as configured
                                but the configuration does not adequately protect sensitive resources at an appropriate
                                level.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading246"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse246" aria-expanded="true" aria-controls="collapse246">Weakness: Execution with Unnecessary Privileges <span>[CWE-250]</span></button></h5></div><div id="collapse246" class="collapse" aria-labelledby="heading246" data-parent="#weaknesses"><div class="card-body">The software performs an operation at a privilege level that is higher than the minimum level
                        required, which creates new weaknesses or amplifies the consequences of other weaknesses.

                        New weaknesses can be exposed because running with extra privileges, such as root or
                        Administrator, can disable the normal security checks being performed by the operating system or
                        surrounding environment. Other pre-existing weaknesses can turn into security vulnerabilities if
                        they occur while operating at raised privileges. Privilege management functions can behave in
                        some less-than-obvious ways, and they have different quirks on different platforms. These
                        inconsistencies are particularly pronounced if you are transitioning from one non-root user to
                        another. Signal handlers and spawned processes run at the privilege of the owning process, so if
                        a process is running as root when a signal fires or a sub-process is executed, the signal
                        handler or sub-process will operate with root privileges.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading245"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse245" aria-expanded="true" aria-controls="collapse245">Countermeasure: Ensure only trusted users are allowed to control Docker daemon <span>[D1.4]</span></button></h5></div><div id="collapse245" class="collapse" aria-labelledby="heading245" data-parent="#controls"><div class="card-body">The Docker daemon currently requires root privileges. A user added to the docker group gives
                        him full root access rights.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker allows you to share a directory between the Docker host and a guest container without
                        limiting the access rights of the container. This means that you can start a container and map
                        the / directory on your host to the container. The container will then be able to alter your
                        host file system without any restrictions. In simple terms, this means that you can attain
                        elevated privileges with just being a member of the docker group and then starting a container
                        with mapped / directory on the host.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Remove any users from the docker group that are not trusted. Additionally, do not create a
                        mapping of sensitive directories on host to container volumes.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Rights to build and execute containers as normal user would be restricted.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading248"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse248" aria-expanded="true" aria-controls="collapse248">Weakness: Incorrect Default Permissions <span>[CWE-276]</span></button></h5></div><div id="collapse248" class="collapse" aria-labelledby="heading248" data-parent="#weaknesses"><div class="card-body">The software, upon installation, sets incorrect permissions for an object that exposes it to
                        an unintended actor.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading247"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse247" aria-expanded="true" aria-controls="collapse247">Countermeasure: Ensure only trusted users are allowed to control Docker daemon <span>[D1.4]</span></button></h5></div><div id="collapse247" class="collapse" aria-labelledby="heading247" data-parent="#controls"><div class="card-body">The Docker daemon currently requires root privileges. A user added to the docker group gives
                        him full root access rights.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker allows you to share a directory between the Docker host and a guest container without
                        limiting the access rights of the container. This means that you can start a container and map
                        the / directory on your host to the container. The container will then be able to alter your
                        host file system without any restrictions. In simple terms, this means that you can attain
                        elevated privileges with just being a member of the docker group and then starting a container
                        with mapped / directory on the host.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Remove any users from the docker group that are not trusted. Additionally, do not create a
                        mapping of sensitive directories on host to container volumes.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Rights to build and execute containers as normal user would be restricted.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading250"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse250" aria-expanded="true" aria-controls="collapse250">Weakness: Incorrect Ownership Assignment <span>[CWE-708]</span></button></h5></div><div id="collapse250" class="collapse" aria-labelledby="heading250" data-parent="#weaknesses"><div class="card-body">The software assigns an owner to a resource, but the owner is outside of the intended control
                        sphere.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading249"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse249" aria-expanded="true" aria-controls="collapse249">Countermeasure: Ensure only trusted users are allowed to control Docker daemon <span>[D1.4]</span></button></h5></div><div id="collapse249" class="collapse" aria-labelledby="heading249" data-parent="#controls"><div class="card-body">The Docker daemon currently requires root privileges. A user added to the docker group gives
                        him full root access rights.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker allows you to share a directory between the Docker host and a guest container without
                        limiting the access rights of the container. This means that you can start a container and map
                        the / directory on your host to the container. The container will then be able to alter your
                        host file system without any restrictions. In simple terms, this means that you can attain
                        elevated privileges with just being a member of the docker group and then starting a container
                        with mapped / directory on the host.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Remove any users from the docker group that are not trusted. Additionally, do not create a
                        mapping of sensitive directories on host to container volumes.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Rights to build and execute containers as normal user would be restricted.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading252"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse252" aria-expanded="true" aria-controls="collapse252">Weakness: Incorrect Permission Assignment for Critical Resource <span>[CWE-732]</span></button></h5></div><div id="collapse252" class="collapse" aria-labelledby="heading252" data-parent="#weaknesses"><div class="card-body">The software specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.

When a resource is given a permission setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.  <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading251"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse251" aria-expanded="true" aria-controls="collapse251">Countermeasure: Ensure only trusted users are allowed to control Docker daemon <span>[D1.4]</span></button></h5></div><div id="collapse251" class="collapse" aria-labelledby="heading251" data-parent="#controls"><div class="card-body">The Docker daemon currently requires root privileges. A user added to the docker group gives
                        him full root access rights.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker allows you to share a directory between the Docker host and a guest container without
                        limiting the access rights of the container. This means that you can start a container and map
                        the / directory on your host to the container. The container will then be able to alter your
                        host file system without any restrictions. In simple terms, this means that you can attain
                        elevated privileges with just being a member of the docker group and then starting a container
                        with mapped / directory on the host.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Remove any users from the docker group that are not trusted. Additionally, do not create a
                        mapping of sensitive directories on host to container volumes.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Rights to build and execute containers as normal user would be restricted.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading256"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse256" aria-expanded="true" aria-controls="collapse256">Weakness: Information Exposure Through Local Storage <span>[CWE-922]</span></button></h5></div><div id="collapse256" class="collapse" aria-labelledby="heading256" data-parent="#weaknesses"><div class="card-body">The software stores sensitive information without properly limiting read or write access by
                        unauthorized actors.
                        If read access is not properly restricted, then attackers can steal the sensitive information.
                        If write access is not properly restricted, then attackers can modify and possibly delete the
                        data, causing incorrect results and possibly a denial of service.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading253"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse253" aria-expanded="true" aria-controls="collapse253">Countermeasure: Ensure a separate partition for containers has been created <span>[D1.1]</span></button></h5></div><div id="collapse253" class="collapse" aria-labelledby="heading253" data-parent="#controls"><div class="card-body">All Docker containers and their data and metadata is stored under /var/lib/docker directory.
                        By default, /var/lib/docker would be mounted under / or /var partitions based on availability.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        Docker depends on /var/lib/docker as the default directory where all Docker related files,
                        including the images, are stored. This directory might fill up fast and soon Docker and the host
                        could become unusable. So, it is advisable to create a separate partition (logical volume) for
                        storing Docker files.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        For new installations, create a separate partition for /var/lib/docker mount point. For systems
                        that were previously installed, use the Logical Volume Manager (LVM) to create partitions.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading254"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse254" aria-expanded="true" aria-controls="collapse254">Countermeasure: Ensure image sprawl is avoided <span>[D6.1]</span></button></h5></div><div id="collapse254" class="collapse" aria-labelledby="heading254" data-parent="#controls"><div class="card-body">Do not keep a large number of container images on the same host. Use only tagged images as
                        appropriate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Tagged images are useful to fall back from &quot;latest&quot; to a specific version of
                        an image in production. Images with unused or old tags may contain vulnerabilities that might be
                        exploited, if instantiated. Additionally, if you fail to remove unused images from the system
                        and there are various such redundant and unused images, the host filesystem may become full and
                        could lead to denial of service.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Keep the set of the images that you actually need and establish a workflow to remove old or
                        stale images from the host. Additionally, use features such as pull-by-digest to get specific
                        images from the registry. Additionally, you can follow the below set of steps to find unused
                        images on the system and delete them.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        Step 1 Make a list of all image IDs that are currently instantiated by executing below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 2: List all the images present on the system by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 3: Compare the list of image IDs populated from Step 1 and Step 2 and find images that are
                        currently not being instantiated.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Step 4: Decide if you want to keep the images that are not currently in use. If not. delete them
                        by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker rmi $IMAGE_ID&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading255"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse255" aria-expanded="true" aria-controls="collapse255">Countermeasure: Ensure container sprawl is avoided <span>[D6.2]</span></button></h5></div><div id="collapse255" class="collapse" aria-labelledby="heading255" data-parent="#controls"><div class="card-body">Do not keep a large number of containers on the same host.
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The flexibility of containers makes it easy to run multiple instances of applications and
                        indirectly leads to Docker images that exist at varying security patch levels. It also means
                        that you are consuming host resources that otherwise could have been used for running 'useful'
                        containers. Having more than just the manageable number of containers on a particular host makes
                        the situation vulnerable to mishandling, misconfiguration and fragmentation. Thus, avoid
                        container sprawl and keep the number of containers on a host to a manageable total.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Periodically check your container inventory per host and clean up the stopped containers using
                        the below command:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker container prune&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If you keep too few containers per host, then perhaps you are not utilizing your host resources
                        adequately.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading287"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse287" aria-expanded="true" aria-controls="collapse287">Use case: General <span>[GENERAL]</span></button></h5></div><div id="collapse287" class="collapse" aria-labelledby="heading287" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading262"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse262" aria-expanded="true" aria-controls="collapse262">Threat: Attackers consume the resources of the Linux Host OS by rapidly engaging to do the target inaccessible or to break the target <span>[CAPEC-125-LINUX]</span></button></h5></div><div id="collapse262" class="collapse" aria-labelledby="heading262" data-parent="#threats"><div class="card-body">An adversary consumes the resources of a target by rapidly engaging in a large number
                                of interactions with the target. This type of attack generally exposes a weakness in
                                rate limiting or flow. When successful this attack prevents legitimate users from
                                accessing the service and can cause the target to crash. This attack differs from
                                resource depletion through leaks or allocations in that the latter attacks do not rely
                                on the volume of requests made to the target but instead focus on manipulation of the
                                target's operations. The key factor in a flooding attack is the number of requests the
                                adversary can make in a given period of time. The greater this number, the more likely
                                an attack is to succeed against a given target.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading261"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse261" aria-expanded="true" aria-controls="collapse261">Weakness: Uncontrolled Resource Consumption ('Resource Exhaustion') <span>[CWE-400]</span></button></h5></div><div id="collapse261" class="collapse" aria-labelledby="heading261" data-parent="#weaknesses"><div class="card-body">The software does not properly restrict the size or amount of resources that are requested or
                        influenced by an actor, which can be used to consume more resources than intended.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading259"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse259" aria-expanded="true" aria-controls="collapse259">Countermeasure: Ensure image sprawl is avoided <span>[D6.1]</span></button></h5></div><div id="collapse259" class="collapse" aria-labelledby="heading259" data-parent="#controls"><div class="card-body">Do not keep a large number of container images on the same host. Use only tagged images as
                        appropriate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Tagged images are useful to fall back from &quot;latest&quot; to a specific version of
                        an image in production. Images with unused or old tags may contain vulnerabilities that might be
                        exploited, if instantiated. Additionally, if you fail to remove unused images from the system
                        and there are various such redundant and unused images, the host filesystem may become full and
                        could lead to denial of service.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Keep the set of the images that you actually need and establish a workflow to remove old or
                        stale images from the host. Additionally, use features such as pull-by-digest to get specific
                        images from the registry. Additionally, you can follow the below set of steps to find unused
                        images on the system and delete them.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        Step 1 Make a list of all image IDs that are currently instantiated by executing below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 2: List all the images present on the system by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 3: Compare the list of image IDs populated from Step 1 and Step 2 and find images that are
                        currently not being instantiated.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Step 4: Decide if you want to keep the images that are not currently in use. If not. delete them
                        by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker rmi $IMAGE_ID&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading260"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse260" aria-expanded="true" aria-controls="collapse260">Countermeasure: Ensure container sprawl is avoided <span>[D6.2]</span></button></h5></div><div id="collapse260" class="collapse" aria-labelledby="heading260" data-parent="#controls"><div class="card-body">Do not keep a large number of containers on the same host.
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The flexibility of containers makes it easy to run multiple instances of applications and
                        indirectly leads to Docker images that exist at varying security patch levels. It also means
                        that you are consuming host resources that otherwise could have been used for running 'useful'
                        containers. Having more than just the manageable number of containers on a particular host makes
                        the situation vulnerable to mishandling, misconfiguration and fragmentation. Thus, avoid
                        container sprawl and keep the number of containers on a host to a manageable total.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Periodically check your container inventory per host and clean up the stopped containers using
                        the below command:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker container prune&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If you keep too few containers per host, then perhaps you are not utilizing your host resources
                        adequately.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div><div class="card border-danger"><div class="card-header " id="heading286"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse286" aria-expanded="true" aria-controls="collapse286">Threat: Exploitation of Security Misconfiguration of the Linux system

 <span>[OWASP A6:2017-LINUX]</span></button></h5></div><div id="collapse286" class="collapse" aria-labelledby="heading286" data-parent="#threats"><div class="card-body">Attackers will often attempt to exploit unpatched flaws or access default accounts,
                                unused pages, unprotected files and directories, etc to gain unauthorized access or
                                knowledge of the system.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading265"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse265" aria-expanded="true" aria-controls="collapse265">Weakness: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') <span>[CWE-120]</span></button></h5></div><div id="collapse265" class="collapse" aria-labelledby="heading265" data-parent="#weaknesses"><div class="card-body">The program copies an input buffer to an output buffer without verifying that the size of the
                        input buffer is less than the size of the output buffer, leading to a buffer overflow.
                        <br />A buffer overflow condition exists when a program attempts to put more data in a
                        buffer than it can hold, or when a program attempts to put data in a memory area outside of the
                        boundaries of a buffer. The simplest type of error, and the most common cause of buffer
                        overflows, is the &quot;classic&quot; case in which the program copies the buffer
                        without restricting how much is copied. Other variants exist, but the existence of a classic
                        overflow strongly suggests that the programmer is not considering even the most basic of
                        security protections.
                        <br />
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading263"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse263" aria-expanded="true" aria-controls="collapse263">Countermeasure: Ensure the container host has been Hardened <span>[D1.2]</span></button></h5></div><div id="collapse263" class="collapse" aria-labelledby="heading263" data-parent="#controls"><div class="card-body">Containers run on a Linux host. A container host can run one or more containers. It is of
                        utmost importance to harden the host to mitigate host security misconfiguration.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        You should follow infrastructure security best practices and harden your host OS. Keeping the
                        host system hardened would ensure that the host vulnerabilities are mitigated. Not hardening the
                        host system could lead to security exposures and breaches.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        You may consider various CIS Security Benchmarks for your container host. If you have other
                        security guidelines or regulatory requirements to adhere to, please follow them as appropriate
                        in your environment.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Additionally, you can run a kernel with grsecurity and PaX. This would add many safety checks,
                        both at compile-time and run-time. It is also designed to defeat many exploits and has powerful
                        security features. These features do not require Docker-specific configuration, since these
                        security features apply system-wide, independent of containers.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading264"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse264" aria-expanded="true" aria-controls="collapse264">Countermeasure: Ensure Docker is up to date <span>[D1.3]</span></button></h5></div><div id="collapse264" class="collapse" aria-labelledby="heading264" data-parent="#controls"><div class="card-body">There are frequent releases for Docker software that address security vulnerabilities, product
                        bugs and bring in new functionality. Keep a tab on these product updates and upgrade as
                        frequently as new security vulnerabilities are fixed or deemed correct for your organization.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        By staying up to date on Docker updates, vulnerabilities in the Docker software can be
                        mitigated. An educated attacker may exploit known vulnerabilities when attempting to attain
                        access or elevate privileges. Not installing regular Docker updates may leave you running
                        vulnerable Docker software. It might lead to elevation privileges, unauthorized access or other
                        security breaches. Keep a track of new releases and update as necessary.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Keep a track of Docker releases and update as necessary.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        Perform a risk assessment for docker version updates of how they may impact your Docker
                        operations. Be aware that several third-party products that use Docker may require older major
                        version of Docker to be supported.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading268"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse268" aria-expanded="true" aria-controls="collapse268">Weakness: Data is stored into unprotected locations <span>[MOB-DATA]</span></button></h5></div><div id="collapse268" class="collapse" aria-labelledby="heading268" data-parent="#weaknesses"><div class="card-body">When sensitive data is stored into unprotected locations, an attacker with access to the
                        device through physical access or a remote exploit, could gain access to it.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading266"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse266" aria-expanded="true" aria-controls="collapse266">Countermeasure: Ensure image sprawl is avoided <span>[D6.1]</span></button></h5></div><div id="collapse266" class="collapse" aria-labelledby="heading266" data-parent="#controls"><div class="card-body">Do not keep a large number of container images on the same host. Use only tagged images as
                        appropriate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Tagged images are useful to fall back from &quot;latest&quot; to a specific version of
                        an image in production. Images with unused or old tags may contain vulnerabilities that might be
                        exploited, if instantiated. Additionally, if you fail to remove unused images from the system
                        and there are various such redundant and unused images, the host filesystem may become full and
                        could lead to denial of service.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Keep the set of the images that you actually need and establish a workflow to remove old or
                        stale images from the host. Additionally, use features such as pull-by-digest to get specific
                        images from the registry. Additionally, you can follow the below set of steps to find unused
                        images on the system and delete them.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        Step 1 Make a list of all image IDs that are currently instantiated by executing below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 2: List all the images present on the system by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 3: Compare the list of image IDs populated from Step 1 and Step 2 and find images that are
                        currently not being instantiated.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Step 4: Decide if you want to keep the images that are not currently in use. If not. delete them
                        by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker rmi $IMAGE_ID&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading267"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse267" aria-expanded="true" aria-controls="collapse267">Countermeasure: Ensure container sprawl is avoided <span>[D6.2]</span></button></h5></div><div id="collapse267" class="collapse" aria-labelledby="heading267" data-parent="#controls"><div class="card-body">Do not keep a large number of containers on the same host.
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The flexibility of containers makes it easy to run multiple instances of applications and
                        indirectly leads to Docker images that exist at varying security patch levels. It also means
                        that you are consuming host resources that otherwise could have been used for running 'useful'
                        containers. Having more than just the manageable number of containers on a particular host makes
                        the situation vulnerable to mishandling, misconfiguration and fragmentation. Thus, avoid
                        container sprawl and keep the number of containers on a host to a manageable total.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Periodically check your container inventory per host and clean up the stopped containers using
                        the below command:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker container prune&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If you keep too few containers per host, then perhaps you are not utilizing your host resources
                        adequately.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading271"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse271" aria-expanded="true" aria-controls="collapse271">Weakness: Information Exposure Through Caching <span>[CWE-524]</span></button></h5></div><div id="collapse271" class="collapse" aria-labelledby="heading271" data-parent="#weaknesses"><div class="card-body">The application uses a cache to maintain a pool of objects, threads, connections, pages, or
                        passwords to minimize the time it takes to access them or the resources to which they connect.
                        If implemented improperly, these caches can allow access to unauthorized information or cause a
                        denial of service vulnerability.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading269"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse269" aria-expanded="true" aria-controls="collapse269">Countermeasure: Ensure image sprawl is avoided <span>[D6.1]</span></button></h5></div><div id="collapse269" class="collapse" aria-labelledby="heading269" data-parent="#controls"><div class="card-body">Do not keep a large number of container images on the same host. Use only tagged images as
                        appropriate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Tagged images are useful to fall back from &quot;latest&quot; to a specific version of
                        an image in production. Images with unused or old tags may contain vulnerabilities that might be
                        exploited, if instantiated. Additionally, if you fail to remove unused images from the system
                        and there are various such redundant and unused images, the host filesystem may become full and
                        could lead to denial of service.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Keep the set of the images that you actually need and establish a workflow to remove old or
                        stale images from the host. Additionally, use features such as pull-by-digest to get specific
                        images from the registry. Additionally, you can follow the below set of steps to find unused
                        images on the system and delete them.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        Step 1 Make a list of all image IDs that are currently instantiated by executing below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 2: List all the images present on the system by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 3: Compare the list of image IDs populated from Step 1 and Step 2 and find images that are
                        currently not being instantiated.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Step 4: Decide if you want to keep the images that are not currently in use. If not. delete them
                        by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker rmi $IMAGE_ID&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading270"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse270" aria-expanded="true" aria-controls="collapse270">Countermeasure: Ensure container sprawl is avoided <span>[D6.2]</span></button></h5></div><div id="collapse270" class="collapse" aria-labelledby="heading270" data-parent="#controls"><div class="card-body">Do not keep a large number of containers on the same host.
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The flexibility of containers makes it easy to run multiple instances of applications and
                        indirectly leads to Docker images that exist at varying security patch levels. It also means
                        that you are consuming host resources that otherwise could have been used for running 'useful'
                        containers. Having more than just the manageable number of containers on a particular host makes
                        the situation vulnerable to mishandling, misconfiguration and fragmentation. Thus, avoid
                        container sprawl and keep the number of containers on a host to a manageable total.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Periodically check your container inventory per host and clean up the stopped containers using
                        the below command:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker container prune&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If you keep too few containers per host, then perhaps you are not utilizing your host resources
                        adequately.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading274"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse274" aria-expanded="true" aria-controls="collapse274">Weakness: Production data used in pre-production system <span>[CWE-485-PREPROD]</span></button></h5></div><div id="collapse274" class="collapse" aria-labelledby="heading274" data-parent="#weaknesses"><div class="card-body">Production data used in pre-production system might not be properly protected as applications
                        in pre-production are not usually well tested. pre-production environments usually lack the
                        strong Countermeasures that are set for production environments.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading272"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse272" aria-expanded="true" aria-controls="collapse272">Countermeasure: Ensure image sprawl is avoided <span>[D6.1]</span></button></h5></div><div id="collapse272" class="collapse" aria-labelledby="heading272" data-parent="#controls"><div class="card-body">Do not keep a large number of container images on the same host. Use only tagged images as
                        appropriate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Tagged images are useful to fall back from &quot;latest&quot; to a specific version of
                        an image in production. Images with unused or old tags may contain vulnerabilities that might be
                        exploited, if instantiated. Additionally, if you fail to remove unused images from the system
                        and there are various such redundant and unused images, the host filesystem may become full and
                        could lead to denial of service.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Keep the set of the images that you actually need and establish a workflow to remove old or
                        stale images from the host. Additionally, use features such as pull-by-digest to get specific
                        images from the registry. Additionally, you can follow the below set of steps to find unused
                        images on the system and delete them.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        Step 1 Make a list of all image IDs that are currently instantiated by executing below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 2: List all the images present on the system by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 3: Compare the list of image IDs populated from Step 1 and Step 2 and find images that are
                        currently not being instantiated.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Step 4: Decide if you want to keep the images that are not currently in use. If not. delete them
                        by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker rmi $IMAGE_ID&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading273"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse273" aria-expanded="true" aria-controls="collapse273">Countermeasure: Ensure container sprawl is avoided <span>[D6.2]</span></button></h5></div><div id="collapse273" class="collapse" aria-labelledby="heading273" data-parent="#controls"><div class="card-body">Do not keep a large number of containers on the same host.
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The flexibility of containers makes it easy to run multiple instances of applications and
                        indirectly leads to Docker images that exist at varying security patch levels. It also means
                        that you are consuming host resources that otherwise could have been used for running 'useful'
                        containers. Having more than just the manageable number of containers on a particular host makes
                        the situation vulnerable to mishandling, misconfiguration and fragmentation. Thus, avoid
                        container sprawl and keep the number of containers on a host to a manageable total.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Periodically check your container inventory per host and clean up the stopped containers using
                        the below command:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker container prune&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If you keep too few containers per host, then perhaps you are not utilizing your host resources
                        adequately.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading276"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse276" aria-expanded="true" aria-controls="collapse276">Weakness: Recommended security patches are not applied <span>[UNPATCHED-SERVER]</span></button></h5></div><div id="collapse276" class="collapse" aria-labelledby="heading276" data-parent="#weaknesses"><div class="card-body">When patches are not applied in a timely manner then the server or system could be vulnerable
                        to known security issues. These issues could be used by an attacker to gain access to the
                        system.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading275"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse275" aria-expanded="true" aria-controls="collapse275">Countermeasure: Ensure Docker is up to date <span>[D1.3]</span></button></h5></div><div id="collapse275" class="collapse" aria-labelledby="heading275" data-parent="#controls"><div class="card-body">There are frequent releases for Docker software that address security vulnerabilities, product
                        bugs and bring in new functionality. Keep a tab on these product updates and upgrade as
                        frequently as new security vulnerabilities are fixed or deemed correct for your organization.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        By staying up to date on Docker updates, vulnerabilities in the Docker software can be
                        mitigated. An educated attacker may exploit known vulnerabilities when attempting to attain
                        access or elevate privileges. Not installing regular Docker updates may leave you running
                        vulnerable Docker software. It might lead to elevation privileges, unauthorized access or other
                        security breaches. Keep a track of new releases and update as necessary.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Keep a track of Docker releases and update as necessary.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        Perform a risk assessment for docker version updates of how they may impact your Docker
                        operations. Be aware that several third-party products that use Docker may require older major
                        version of Docker to be supported.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading278"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse278" aria-expanded="true" aria-controls="collapse278">Weakness: The application has not been securely developed <span>[CWE-398]</span></button></h5></div><div id="collapse278" class="collapse" aria-labelledby="heading278" data-parent="#weaknesses"><div class="card-body"><div>
                        The code has features that do not directly introduce a&nbsp;weakness&nbsp;or&nbsp;vulnerability,
                        but indicate that the product has not been carefully developed or maintained.
                        </div>
                        <div>
                        <p>Programs are more likely to be secure when good development practices are followed. If
                        a program is complex, difficult to maintain, not portable, or shows evidence of neglect, then
                        there is a higher likelihood that&nbsp;weaknesses&nbsp;are buried in the code.</p>
                        </div>
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading277"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse277" aria-expanded="true" aria-controls="collapse277">Countermeasure: Ensure image sprawl is avoided <span>[D6.1]</span></button></h5></div><div id="collapse277" class="collapse" aria-labelledby="heading277" data-parent="#controls"><div class="card-body">Do not keep a large number of container images on the same host. Use only tagged images as
                        appropriate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Tagged images are useful to fall back from &quot;latest&quot; to a specific version of
                        an image in production. Images with unused or old tags may contain vulnerabilities that might be
                        exploited, if instantiated. Additionally, if you fail to remove unused images from the system
                        and there are various such redundant and unused images, the host filesystem may become full and
                        could lead to denial of service.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Keep the set of the images that you actually need and establish a workflow to remove old or
                        stale images from the host. Additionally, use features such as pull-by-digest to get specific
                        images from the registry. Additionally, you can follow the below set of steps to find unused
                        images on the system and delete them.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        Step 1 Make a list of all image IDs that are currently instantiated by executing below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 2: List all the images present on the system by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 3: Compare the list of image IDs populated from Step 1 and Step 2 and find images that are
                        currently not being instantiated.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Step 4: Decide if you want to keep the images that are not currently in use. If not. delete them
                        by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker rmi $IMAGE_ID&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading280"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse280" aria-expanded="true" aria-controls="collapse280">Weakness: The service contains vulnerabilities that could grant access to data <span>[CWE-284]</span></button></h5></div><div id="collapse280" class="collapse" aria-labelledby="heading280" data-parent="#weaknesses"><div class="card-body">The services may contain security vulnerabilities that can be exploited by attackers to gain unauthorized access to data or additional services.<div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading279"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse279" aria-expanded="true" aria-controls="collapse279">Countermeasure: Ensure Docker is up to date <span>[D1.3]</span></button></h5></div><div id="collapse279" class="collapse" aria-labelledby="heading279" data-parent="#controls"><div class="card-body">There are frequent releases for Docker software that address security vulnerabilities, product
                        bugs and bring in new functionality. Keep a tab on these product updates and upgrade as
                        frequently as new security vulnerabilities are fixed or deemed correct for your organization.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        By staying up to date on Docker updates, vulnerabilities in the Docker software can be
                        mitigated. An educated attacker may exploit known vulnerabilities when attempting to attain
                        access or elevate privileges. Not installing regular Docker updates may leave you running
                        vulnerable Docker software. It might lead to elevation privileges, unauthorized access or other
                        security breaches. Keep a track of new releases and update as necessary.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Keep a track of Docker releases and update as necessary.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        Perform a risk assessment for docker version updates of how they may impact your Docker
                        operations. Be aware that several third-party products that use Docker may require older major
                        version of Docker to be supported.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading285"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse285" aria-expanded="true" aria-controls="collapse285">Weakness: Unexpected Environment Condition <span>[CWE-2]</span></button></h5></div><div id="collapse285" class="collapse" aria-labelledby="heading285" data-parent="#weaknesses"><div class="card-body">This is a generic weakness that includes several different situations, they are all related to
                        unexpected environmental conditions and they could be related to:&nbsp;
                        <div>
                        <ul>
                        <li>Misconfiguration.</li>
                        <li>Uncleared buffers, shared memory, files, etc.&nbsp;</li>
                        <li>Problems between the interaction of two different entities that cause unexpected
                        behavior.</li>
                        </ul>
                        </div>
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading281"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse281" aria-expanded="true" aria-controls="collapse281">Countermeasure: Ensure a separate partition for containers has been created <span>[D1.1]</span></button></h5></div><div id="collapse281" class="collapse" aria-labelledby="heading281" data-parent="#controls"><div class="card-body">All Docker containers and their data and metadata is stored under /var/lib/docker directory.
                        By default, /var/lib/docker would be mounted under / or /var partitions based on availability.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        Docker depends on /var/lib/docker as the default directory where all Docker related files,
                        including the images, are stored. This directory might fill up fast and soon Docker and the host
                        could become unusable. So, it is advisable to create a separate partition (logical volume) for
                        storing Docker files.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        For new installations, create a separate partition for /var/lib/docker mount point. For systems
                        that were previously installed, use the Logical Volume Manager (LVM) to create partitions.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading282"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse282" aria-expanded="true" aria-controls="collapse282">Countermeasure: Ensure the container host has been Hardened <span>[D1.2]</span></button></h5></div><div id="collapse282" class="collapse" aria-labelledby="heading282" data-parent="#controls"><div class="card-body">Containers run on a Linux host. A container host can run one or more containers. It is of
                        utmost importance to harden the host to mitigate host security misconfiguration.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        You should follow infrastructure security best practices and harden your host OS. Keeping the
                        host system hardened would ensure that the host vulnerabilities are mitigated. Not hardening the
                        host system could lead to security exposures and breaches.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        You may consider various CIS Security Benchmarks for your container host. If you have other
                        security guidelines or regulatory requirements to adhere to, please follow them as appropriate
                        in your environment.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Additionally, you can run a kernel with grsecurity and PaX. This would add many safety checks,
                        both at compile-time and run-time. It is also designed to defeat many exploits and has powerful
                        security features. These features do not require Docker-specific configuration, since these
                        security features apply system-wide, independent of containers.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading283"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse283" aria-expanded="true" aria-controls="collapse283">Countermeasure: Ensure image sprawl is avoided <span>[D6.1]</span></button></h5></div><div id="collapse283" class="collapse" aria-labelledby="heading283" data-parent="#controls"><div class="card-body">Do not keep a large number of container images on the same host. Use only tagged images as
                        appropriate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Tagged images are useful to fall back from &quot;latest&quot; to a specific version of
                        an image in production. Images with unused or old tags may contain vulnerabilities that might be
                        exploited, if instantiated. Additionally, if you fail to remove unused images from the system
                        and there are various such redundant and unused images, the host filesystem may become full and
                        could lead to denial of service.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Keep the set of the images that you actually need and establish a workflow to remove old or
                        stale images from the host. Additionally, use features such as pull-by-digest to get specific
                        images from the registry. Additionally, you can follow the below set of steps to find unused
                        images on the system and delete them.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        Step 1 Make a list of all image IDs that are currently instantiated by executing below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 2: List all the images present on the system by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker images&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <blockquote>
                        <div>
                        Step 3: Compare the list of image IDs populated from Step 1 and Step 2 and find images that are
                        currently not being instantiated.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Step 4: Decide if you want to keep the images that are not currently in use. If not. delete them
                        by executing the below command:&nbsp;
                        </div>
                        </blockquote>
                        <blockquote>
                        <blockquote>
                        <div>
                        docker rmi $IMAGE_ID&nbsp;
                        </div>
                        </blockquote>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading284"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse284" aria-expanded="true" aria-controls="collapse284">Countermeasure: Ensure container sprawl is avoided <span>[D6.2]</span></button></h5></div><div id="collapse284" class="collapse" aria-labelledby="heading284" data-parent="#controls"><div class="card-body">Do not keep a large number of containers on the same host.
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        The flexibility of containers makes it easy to run multiple instances of applications and
                        indirectly leads to Docker images that exist at varying security patch levels. It also means
                        that you are consuming host resources that otherwise could have been used for running 'useful'
                        containers. Having more than just the manageable number of containers on a particular host makes
                        the situation vulnerable to mishandling, misconfiguration and fragmentation. Thus, avoid
                        container sprawl and keep the number of containers on a host to a manageable total.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Periodically check your container inventory per host and clean up the stopped containers using
                        the below command:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker container prune&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        If you keep too few containers per host, then perhaps you are not utilizing your host resources
                        adequately.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading299"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse299" aria-expanded="true" aria-controls="collapse299">Use case: Logging and Monitoring <span>[LOGGING AND MONITORING]</span></button></h5></div><div id="collapse299" class="collapse" aria-labelledby="heading299" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading298"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse298" aria-expanded="true" aria-controls="collapse298">Threat: Attackers make undetected and unaudited changes to Linux host OS configurations <span>[OWASP A10:2017-LINUX]</span></button></h5></div><div id="collapse298" class="collapse" aria-labelledby="heading298" data-parent="#threats"><div class="card-body">Exploitation of insufficient logging and monitoring is the bedrock of nearly every
                                major incident.
                                Attackers rely on the lack of monitoring and timely response to achieve their goals
                                without being detected.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading297"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse297" aria-expanded="true" aria-controls="collapse297">Weakness: Insufficient Logging <span>[CWE-778]</span></button></h5></div><div id="collapse297" class="collapse" aria-labelledby="heading297" data-parent="#weaknesses"><div class="card-body">When a security-critical event occurs, the software either does not record the event or omits important details about the event when logging it.

When security-critical events are not logged properly, such as a failed login attempt, this can make malicious behavior more difficult to detect and may hinder forensic analysis after an attack succeeds.  <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading288"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse288" aria-expanded="true" aria-controls="collapse288">Countermeasure: Ensure auditing is configured for Docker files and directories - /etc/default/docker <span>[D1.10]</span></button></h5></div><div id="collapse288" class="collapse" aria-labelledby="heading288" data-parent="#controls"><div class="card-body">Audit /etc/default/docker, if applicable.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Apart from auditing your regular Linux file system and system calls, audit all Docker related
                        files and directories. Docker daemon runs with root privileges. Its behavior depends on some key
                        files and directories. /etc/default/docker is one such file. It holds various parameters for
                        Docker daemon. It must be audited, if applicable.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Add a rule for /etc/default/docker file. For example, Add the line as below in
                        /etc/audit/audit.rules file:
                        </div>
                        <blockquote>
                        <div>
                        -w /etc/default/docker -k docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Then, restart the audit daemon. For example, service auditd restart&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Auditing generates quite big log files. Ensure to rotate and archive them periodically. Also,
                        create a separate partition of audit logs to avoid filling root file system.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading289"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse289" aria-expanded="true" aria-controls="collapse289">Countermeasure: Ensure auditing is configured for Docker files and directories - /etc/docker/daemon.json <span>[D1.11]</span></button></h5></div><div id="collapse289" class="collapse" aria-labelledby="heading289" data-parent="#controls"><div class="card-body">Audit /etc/docker/daemon.json, if applicable.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Apart from auditing your regular Linux file system and system calls, audit all Docker related
                        files and directories. Docker daemon runs with root privileges. Its behavior depends on some key
                        files and directories. /etc/docker/daemon.json is one such file. It holds various parameters for
                        Docker daemon. It must be audited, if applicable.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Add a rule for /etc/docker/daemon.json file. For example, Add the line as below in
                        /etc/audit/audit.rules file:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        -w /etc/docker/daemon.json -k docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Then, restart the audit daemon. For example, service auditd restart&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Auditing generates quite big log files. Ensure to rotate and archive them periodically. Also,
                        create a separate partition of audit logs to avoid filling root file system.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading290"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse290" aria-expanded="true" aria-controls="collapse290">Countermeasure: Ensure auditing is configured for Docker files and directories - /usr/bin/docker-containerd <span>[D1.12]</span></button></h5></div><div id="collapse290" class="collapse" aria-labelledby="heading290" data-parent="#controls"><div class="card-body">Audit /usr/bin/docker-containerd, if applicable.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Apart from auditing your regular Linux file system and system calls, audit all Docker related
                        files and directories. Docker daemon runs with root privileges. Its behavior depends on some key
                        files and directories. /usr/bin/docker-containerd is one such file. Docker now relies on
                        containerd and runC to spawn containers. It must be audited, if applicable.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Add a rule for /usr/bin/docker-containerd file. For example, Add the line as below in
                        /etc/audit/audit.rules file:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        -w /usr/bin/docker-containerd -k docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Then, restart the audit daemon. For example, service auditd restart
                        <br />
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        Auditing generates quite big log files. Ensure to rotate and archive them periodically. Also,
                        create a separate partition of audit logs to avoid filling root file system.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading291"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse291" aria-expanded="true" aria-controls="collapse291">Countermeasure: Ensure auditing is configured for Docker files and directories - /usr/bin/docker-runc <span>[D1.13]</span></button></h5></div><div id="collapse291" class="collapse" aria-labelledby="heading291" data-parent="#controls"><div class="card-body">Audit /usr/bin/docker-runc, if applicable.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        Apart from auditing your regular Linux file system and system calls, audit all Docker related
                        files and directories. Docker daemon runs with root privileges. Its behavior depends on some key
                        files and directories. /usr/bin/docker-runc is one such file. Docker now relies on containerd
                        and runC to spawn containers. It must be audited, if applicable.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>
                        </div>
                        <div>
                        Add a rule for /usr/bin/docker-runc file. For example, Add the line as below in
                        /etc/audit/audit.rules file:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        -w /usr/bin/docker-runc -k docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Then, restart the audit daemon. For example, service auditd restart&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        Auditing generates quite big log files. Ensure to rotate and archive them periodically. Also,
                        create a separate partition of audit logs to avoid filling root file system.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading292"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse292" aria-expanded="true" aria-controls="collapse292">Countermeasure: Ensure auditing is configured for the docker daemon <span>[D1.5]</span></button></h5></div><div id="collapse292" class="collapse" aria-labelledby="heading292" data-parent="#controls"><div class="card-body">Audit all Docker daemon activities.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Apart from auditing your regular Linux file system and system calls, audit Docker daemon as
                        well. Docker daemon runs with root privileges. It is thus necessary to audit its activities and
                        usage.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Add a rule for Docker daemon. For example, Add the line as below in /etc/audit/audit.rules file:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        -w /usr/bin/docker -k docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Then, restart the audit daemon. For example, service auditd restart&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Auditing generates quite big log files. Ensure to rotate and archive them periodically. Also,
                        create a separate partition of audit logs to avoid filling the root file system.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading293"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse293" aria-expanded="true" aria-controls="collapse293">Countermeasure: Ensure auditing is configured for Docker files and directories - /var/lib/docker <span>[D1.6]</span></button></h5></div><div id="collapse293" class="collapse" aria-labelledby="heading293" data-parent="#controls"><div class="card-body">Audit /var/lib/docker.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Apart from auditing your regular Linux file system and system calls, audit all Docker related
                        files and directories. Docker daemon runs with root privileges. Its behavior depends on some key
                        files and directories. /var/lib/docker is one such directory. It holds all the information about
                        containers. It must be audited.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Add a rule for /var/lib/docker directory. For example, Add the line as below in
                        /etc/audit/audit.rules file:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        -w /var/lib/docker -k docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Then, restart the audit daemon. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        service auditd restart&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Auditing generates quite big log files. Ensure to rotate and archive them periodically. Also,
                        create a separate partition of audit logs to avoid filling root file system.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading294"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse294" aria-expanded="true" aria-controls="collapse294">Countermeasure: Ensure auditing is configured for Docker files and directories - /etc/docker <span>[D1.7]</span></button></h5></div><div id="collapse294" class="collapse" aria-labelledby="heading294" data-parent="#controls"><div class="card-body">Audit /etc/docker.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        Apart from auditing your regular Linux file system and system calls, audit all Docker related
                        files and directories. Docker daemon runs with root privileges. Its behavior depends on some key
                        files and directories. /etc/docker is one such directory. It holds various certificates and keys
                        used for TLS communication between Docker daemon and Docker client. It must be audited.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Add a rule for /etc/docker directory. For example, Add the line as below in
                        /etc/audit/audit.rules file:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        -w /etc/docker -k docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Then, restart the audit daemon. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        service auditd restart&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        </blockquote>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Auditing generates quite big log files. Ensure to rotate and archive them periodically. Also,
                        create a separate partition of audit logs to avoid filling root file system.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading295"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse295" aria-expanded="true" aria-controls="collapse295">Countermeasure: Ensure auditing is configured for Docker files and directories - docker.service <span>[D1.8]</span></button></h5></div><div id="collapse295" class="collapse" aria-labelledby="heading295" data-parent="#controls"><div class="card-body">Audit docker.service, if applicable.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Apart from auditing your regular Linux file system and system calls, audit all Docker related
                        files and directories. Docker daemon runs with root privileges. Its behavior depends on some key
                        files and directories. docker.service is one such file. The docker.service file might be present
                        if the daemon parameters have been changed by an administrator. It holds various parameters for
                        Docker daemon. It must be audited, if applicable.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>
                        </div>
                        <div>
                        If the file exists, add a rule for it. For example, Add the line as below in
                        /etc/audit/audit.rules file:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        -w /usr/lib/systemd/system/docker.service -k docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Then, restart the audit daemon. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        service auditd restart&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Auditing generates quite big log files. Ensure to rotate and archive them periodically. Also,
                        create a separate partition of audit logs to avoid filling root file system.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading296"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse296" aria-expanded="true" aria-controls="collapse296">Countermeasure: Ensure auditing is configured for Docker files and directories - docker.socket <span>[D1.9]</span></button></h5></div><div id="collapse296" class="collapse" aria-labelledby="heading296" data-parent="#controls"><div class="card-body">Audit docker.socket, if applicable.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Apart from auditing your regular Linux file system and system calls, audit all Docker related
                        files and directories. Docker daemon runs with root privileges. Its behavior depends on some key
                        files and directories. docker.socket is one such file. It holds various parameters for Docker
                        daemon socket. It must be audited, if applicable.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        If the file exists, add a rule for it. For example, Add the line as below in
                        /etc/audit/audit.rules file:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        -w /usr/lib/systemd/system/docker.socket -k docker&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Then, restart the audit daemon.For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        service auditd restart&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        Auditing generates quite big log files. Ensure to rotate and archive them periodically. Also,
                        create a separate partition of audit logs to avoid filling root file system.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-primary"><div class="card-header " id="heading330"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse330" aria-expanded="true" aria-controls="collapse330">Risk pattern: Docker Swarm <span>[DOCKER-SWARM]</span></button></h5></div><div id="collapse330" class="collapse" aria-labelledby="heading330" data-parent="#components"><div class="card-body">This Risk Pattern lists the recommendations that alter and secure the behavior of Docker Swarm.<div class="accordion" id="usecases"><div class="card border-black"><div class="card-header " id="heading308"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse308" aria-expanded="true" aria-controls="collapse308">Use case: Authentication and Authorization <span>[AUTHENTICATION AND AUTHORIZATION]</span></button></h5></div><div id="collapse308" class="collapse" aria-labelledby="heading308" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading307"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse307" aria-expanded="true" aria-controls="collapse307">Threat: Attakers gain access without the necessary privileged to the docker swarm <span>[CAPEC-122-DOCKER-SWARM]</span></button></h5></div><div id="collapse307" class="collapse" aria-labelledby="heading307" data-parent="#threats"><div class="card-body">An adversary is able to exploit features of the target that should be reserved for
                                privileged users or administrators but are exposed to use by lower or non-privileged
                                accounts. Access to sensitive information and functionality must be controlled to ensure
                                that only authorized users are able to access these resources. If access control
                                mechanisms are absent or misconfigured, a user may be able to access resources that are
                                intended only for higher level users. An adversary may be able to exploit this to
                                utilize a less trusted account to gain information and perform activities reserved for
                                more trusted accounts. This attack differs from privilege escalation and other privilege
                                stealing attacks in that the adversary never actually escalates their privileges but
                                instead is able to use a lesser degree of privilege to access resources that should be
                                (but are not) reserved for higher privilege accounts. Likewise, the adversary does not
                                exploit trust or subvert systems - all control functionality is working as configured
                                but the configuration does not adequately protect sensitive resources at an appropriate
                                level.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading302"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse302" aria-expanded="true" aria-controls="collapse302">Weakness: Incorrect Permission Assignment for Critical Resource <span>[CWE-732]</span></button></h5></div><div id="collapse302" class="collapse" aria-labelledby="heading302" data-parent="#weaknesses"><div class="card-body">The software specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.

When a resource is given a permission setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.  <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading301"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse301" aria-expanded="true" aria-controls="collapse301">Countermeasure: Ensure the minimum number of manager nodes have been created in a swarm <span>[D7.2]</span></button></h5></div><div id="collapse301" class="collapse" aria-labelledby="heading301" data-parent="#controls"><div class="card-body">Ensure that the minimum number of required manager nodes is created in a swarm.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Manager nodes within a swarm have control over the swarm and change its configuration modifying
                        security parameters. Having excessive manager nodes could render the swarm more susceptible to
                        compromise. If fault tolerance is not required in the manager nodes, a single node should be
                        elected as a manger. If fault tolerance is required then the smallest practical odd number to
                        achieve the appropriate level of tolerance should be configured.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        If an excessive number of managers is configured, the excess can be demoted as worker using the
                        following command: docker node demote Where is the node ID value of the manager to be demoted.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading304"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse304" aria-expanded="true" aria-controls="collapse304">Weakness: The application does not re-authenticate on critical functions <span>[CSD-SESS-REAUTH]</span></button></h5></div><div id="collapse304" class="collapse" aria-labelledby="heading304" data-parent="#weaknesses"><div class="card-body">The application does not require the user to re-authenticate for specific critical functions,
                        like password changes or changes to sensitive security settings.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading303"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse303" aria-expanded="true" aria-controls="collapse303">Countermeasure: Ensure swarm manager is running in auto-lock mode <span>[D7.6]</span></button></h5></div><div id="collapse303" class="collapse" aria-labelledby="heading303" data-parent="#controls"><div class="card-body">Run Docker swarm manager in auto-lock mode.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        When Docker restarts, both the TLS key used to encrypt communication among swarm nodes, and the
                        key used to encrypt and decrypt Raft logs on disk, are loaded into each manager node's memory.
                        You should protect the mutual TLS encryption key and the key used to encrypt and decrypt Raft
                        logs at rest. This protection could be enabled by initializing swarm with the --autolock flag.
                        With --autolock enabled, when Docker restarts, you must unlock the swarm first, using a key
                        encryption key generated by Docker when the swarm was initialized.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        If you are initializing swarm, use the below command. docker swarm init --autolock If you want
                        to set --autolock on an existing swarm manager node, use the below command.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker swarm update --autolock&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        A swarm in auto-lock mode won't recover from a re-start without manual intervention from a user
                        to enter the unlock key. In some deployments, this might not be good for availability.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading306"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse306" aria-expanded="true" aria-controls="collapse306">Weakness: Use of a Key Past its Expiration Date <span>[CWE-324]</span></button></h5></div><div id="collapse306" class="collapse" aria-labelledby="heading306" data-parent="#weaknesses"><div class="card-body">The product uses a cryptographic key or password past its expiration date, which diminishes
                        its safety significantly by increasing the timing window for cracking attacks against that key.
                        While the expiration of keys does not necessarily ensure that they are compromised, it is a
                        significant concern that keys which remain in use for prolonged periods of time have a
                        decreasing probability of integrity. For this reason, it is important to replace keys within a
                        period of time proportional to their strength.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading305"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse305" aria-expanded="true" aria-controls="collapse305">Countermeasure: Ensure swarm manager auto-lock key is rotated periodically <span>[D7.7]</span></button></h5></div><div id="collapse305" class="collapse" aria-labelledby="heading305" data-parent="#controls"><div class="card-body">Rotate swarm manager auto-lock key periodically.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Swarm manager auto-lock key is not automatically rotated. You should rotate them periodically as
                        a best practice.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the below command to rotate the keys.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker swarm unlock-key --rotate&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        Additionally, to facilitate audit for this recommendation, maintain key rotation records and
                        ensure that you establish a pre-defined frequency for key rotation.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading316"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse316" aria-expanded="true" aria-controls="collapse316">Use case: General <span>[GENERAL]</span></button></h5></div><div id="collapse316" class="collapse" aria-labelledby="heading316" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading315"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse315" aria-expanded="true" aria-controls="collapse315">Threat: Exploitation of Security Misconfiguration of the Docker swarm <span>[OWASP A6:2017-DOCKER-SWARM]</span></button></h5></div><div id="collapse315" class="collapse" aria-labelledby="heading315" data-parent="#threats"><div class="card-body">Attackers will often attempt to exploit unpatched flaws or access default accounts,
                                unused pages, unprotected files and directories, etc to gain unauthorized access or
                                knowledge of the system.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading310"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse310" aria-expanded="true" aria-controls="collapse310">Weakness: The application does not define isolated boundaries (Insufficient Encapsulation) <span>[CWE-485]</span></button></h5></div><div id="collapse310" class="collapse" aria-labelledby="heading310" data-parent="#weaknesses"><div class="card-body"><div>
                        The application does not sufficiently encapsulate critical data or functionality.
                        </div>
                        <p>Encapsulation is about drawing strong boundaries. In a web browser that might mean
                        ensuring that your mobile code cannot be abused by other mobile code. On the server it might
                        mean differentiation between validated data and unvalidated data, between one user's data and
                        another's, or between data users are allowed to see and data that they are not.</p>
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading309"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse309" aria-expanded="true" aria-controls="collapse309">Countermeasure: Ensure management plane traffic has been separated from data plane traffic <span>[D7.10]</span></button></h5></div><div id="collapse309" class="collapse" aria-labelledby="heading309" data-parent="#controls"><div class="card-body">Separate management plane traffic from data plane traffic.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Separating the management plane traffic from data plane traffic ensures that this traffic are on
                        their respective paths. These paths could then be individually monitored and could be tied to
                        different traffic control policies and monitoring. This also ensures that the management plane
                        is always reachable despite the huge volume of data flow.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Initialize Swarm with dedicated interfaces for management and data planes respectively. For
                        example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker swarm init --advertise-addr=192.168.0.1 --data-path-addr=17.1.0.3&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        </blockquote>
                        <b>Impact:</b>&nbsp;
                        <div>
                        You would require 2 network interface cards per node.
                        </div>
                    </div></div></div></div></div></div></div><div class="card border-warning"><div class="card-header " id="heading314"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse314" aria-expanded="true" aria-controls="collapse314">Weakness: Unexpected Environment Condition <span>[CWE-2]</span></button></h5></div><div id="collapse314" class="collapse" aria-labelledby="heading314" data-parent="#weaknesses"><div class="card-body">This is a generic weakness that includes several different situations, they are all related to
                        unexpected environmental conditions and they could be related to:&nbsp;
                        <div>
                        <ul>
                        <li>Misconfiguration.</li>
                        <li>Uncleared buffers, shared memory, files, etc.&nbsp;</li>
                        <li>Problems between the interaction of two different entities that cause unexpected
                        behavior.</li>
                        </ul>
                        </div>
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading311"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse311" aria-expanded="true" aria-controls="collapse311">Countermeasure: Ensure swarm mode is not Enabled, if not needed <span>[D7.1]</span></button></h5></div><div id="collapse311" class="collapse" aria-labelledby="heading311" data-parent="#controls"><div class="card-body">Do not enable swarm mode on a docker engine instance unless needed.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        By default, a Docker engine instance will not listen on any network ports, with all
                        communication with the client coming over the Unix socket. When Docker swarm mode is enabled on
                        a docker engine instance, multiple network ports are opened on the system and made available to
                        other systems on the network for the purposes of cluster management and node communication.
                        Opening network ports on a system increase its attack surface and this should be avoided unless
                        required.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        If swarm mode has been enabled on a system in error, run:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker swarm leave&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading312"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse312" aria-expanded="true" aria-controls="collapse312">Countermeasure: Ensure swarm services are binded to a specific host interface <span>[D7.3]</span></button></h5></div><div id="collapse312" class="collapse" aria-labelledby="heading312" data-parent="#controls"><div class="card-body">By default, the docker swarm services will listen to all interfaces on the host, which may not
                        be necessary for the operation of the swarm where the host has multiple network interfaces.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        When a swarm is initialized the default value for the --listen-addr flag is 0.0.0.0:2377 which
                        means that the swarm services will listen on all interfaces on the host. If a host has multiple
                        network interfaces this may be undesirable as it may expose the docker swarm services to
                        networks which are not involved in the operation of the swarm. By passing a specific IP address
                        to the --listen-addr, a specific network interface can be specified limiting this exposure.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Remediation of this requires re-initialization of the swarm specifying a specific interface for
                        the --listen-addr parameter.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading313"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse313" aria-expanded="true" aria-controls="collapse313">Countermeasure: Ensure Docker's secret management commands are used for managing secrets in a Swarm cluster <span>[D7.5]</span></button></h5></div><div id="collapse313" class="collapse" aria-labelledby="heading313" data-parent="#controls"><div class="card-body">Use Docker's in-built secret management command.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker has various commands for managing secrets in a Swarm cluster. This is the foundation for
                        future secret support in Docker with potential improvements such as Windows support, different
                        backing stores, etc.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Follow docker secret documentation and use it to manage secrets effectively.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading329"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse329" aria-expanded="true" aria-controls="collapse329">Use case: Networking <span>[NETWORKING]</span></button></h5></div><div id="collapse329" class="collapse" aria-labelledby="heading329" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading320"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse320" aria-expanded="true" aria-controls="collapse320">Threat: Attackers gain access to the Docker swarm by exploiting the vulnerabilities of the network <span>[DOCKER-WIDE-ATTACK-SURFACE-SWARM]</span></button></h5></div><div id="collapse320" class="collapse" aria-labelledby="heading320" data-parent="#threats"><div class="card-body">Every point of network interaction is a potential part of the network attack surface
                                having exploitable vulnerabilities.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading319"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse319" aria-expanded="true" aria-controls="collapse319">Weakness: Service is exposed to a wide attack surface <span>[UNRESTRICTED-NETWORK]</span></button></h5></div><div id="collapse319" class="collapse" aria-labelledby="heading319" data-parent="#weaknesses"><div class="card-body">The product is exposed or reachable to an unnecessarily large group of potential attackers. An
                        over-exposure of a component increases the chance of an attacker gaining access to the system
                        through a vulnerability.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading317"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse317" aria-expanded="true" aria-controls="collapse317">Countermeasure: Ensure swarm mode is not Enabled, if not needed <span>[D7.1]</span></button></h5></div><div id="collapse317" class="collapse" aria-labelledby="heading317" data-parent="#controls"><div class="card-body">Do not enable swarm mode on a docker engine instance unless needed.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:&nbsp;</b>
                        </div>
                        <div>
                        By default, a Docker engine instance will not listen on any network ports, with all
                        communication with the client coming over the Unix socket. When Docker swarm mode is enabled on
                        a docker engine instance, multiple network ports are opened on the system and made available to
                        other systems on the network for the purposes of cluster management and node communication.
                        Opening network ports on a system increase its attack surface and this should be avoided unless
                        required.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        If swarm mode has been enabled on a system in error, run:&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker swarm leave&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading318"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse318" aria-expanded="true" aria-controls="collapse318">Countermeasure: Ensure swarm services are binded to a specific host interface <span>[D7.3]</span></button></h5></div><div id="collapse318" class="collapse" aria-labelledby="heading318" data-parent="#controls"><div class="card-body">By default, the docker swarm services will listen to all interfaces on the host, which may not
                        be necessary for the operation of the swarm where the host has multiple network interfaces.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        When a swarm is initialized the default value for the --listen-addr flag is 0.0.0.0:2377 which
                        means that the swarm services will listen on all interfaces on the host. If a host has multiple
                        network interfaces this may be undesirable as it may expose the docker swarm services to
                        networks which are not involved in the operation of the swarm. By passing a specific IP address
                        to the --listen-addr, a specific network interface can be specified limiting this exposure.&nbsp;
                        </div>
                        <div>
                        <b><br /></b>
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Remediation of this requires re-initialization of the swarm specifying a specific interface for
                        the --listen-addr parameter.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div><div class="card border-danger"><div class="card-header " id="heading324"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse324" aria-expanded="true" aria-controls="collapse324">Threat: Attackers get sensitive data from docker swarm through sniffing the transmisions between components <span>[CAPEC-157-SWARM]</span></button></h5></div><div id="collapse324" class="collapse" aria-labelledby="heading324" data-parent="#threats"><div class="card-body">An attacker monitors information transmitted between logical or physical nodes of a
                                network. The attacker need not be able to prevent reception or change content but must
                                simply be able to observe and read the traffic. The attacker might precipitate or
                                indirectly influence the content of the observed transaction, but the attacker is never
                                the intended recipient of the information. Any transmission medium can theoretically be
                                sniffed if the attacker can listen to the contents between the sender and recipient.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading323"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse323" aria-expanded="true" aria-controls="collapse323">Weakness: A connection to an external system is performed in plain text <span>[CWE-311]</span></button></h5></div><div id="collapse323" class="collapse" aria-labelledby="heading323" data-parent="#weaknesses"><div class="card-body">Connections made in plain text are not only target for interception but, even when the component is not dealing with sensitive data, a man in the middle attack is possible and the attacker could pretend to be, i.e. an authentication system to gain the user's credentials.<div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading321"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse321" aria-expanded="true" aria-controls="collapse321">Countermeasure: Ensure data exchanged between containers are encrypted on different nodes on the overlay network <span>[D7.4]</span></button></h5></div><div id="collapse321" class="collapse" aria-labelledby="heading321" data-parent="#controls"><div class="card-body">Encrypt data exchanged between containers on different nodes on the overlay network.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>
                        </div>
                        <div>
                        By default, data exchanged between containers on different nodes on the overlay network is not
                        encrypted. This could potentially expose traffic between the container nodes.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Create overlay network with --opt encrypted flag.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading322"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse322" aria-expanded="true" aria-controls="collapse322">Countermeasure: Ensure swarm manager is running in auto-lock mode <span>[D7.6]</span></button></h5></div><div id="collapse322" class="collapse" aria-labelledby="heading322" data-parent="#controls"><div class="card-body">Run Docker swarm manager in auto-lock mode.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        When Docker restarts, both the TLS key used to encrypt communication among swarm nodes, and the
                        key used to encrypt and decrypt Raft logs on disk, are loaded into each manager node's memory.
                        You should protect the mutual TLS encryption key and the key used to encrypt and decrypt Raft
                        logs at rest. This protection could be enabled by initializing swarm with the --autolock flag.
                        With --autolock enabled, when Docker restarts, you must unlock the swarm first, using a key
                        encryption key generated by Docker when the swarm was initialized.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        If you are initializing swarm, use the below command. docker swarm init --autolock If you want
                        to set --autolock on an existing swarm manager node, use the below command.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker swarm update --autolock&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        A swarm in auto-lock mode won't recover from a re-start without manual intervention from a user
                        to enter the unlock key. In some deployments, this might not be good for availability.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div><div class="card border-danger"><div class="card-header " id="heading328"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse328" aria-expanded="true" aria-controls="collapse328">Threat: Attackers get sensitive data from the docker swarm by listening the communication between components <span>[CAPEC-94-SWARM]</span></button></h5></div><div id="collapse328" class="collapse" aria-labelledby="heading328" data-parent="#threats"><div class="card-body">This type of attack targets the communication between two components (typically client
                                and server). The attacker places himself in the communication channel between the two
                                components. Whenever one component attempts to communicate with the other (data flow,
                                authentication challenges, etc.), the data first goes to the attacker, who has the
                                opportunity to observe or alter it, and it is then passed on to the other component as
                                if it was never intercepted. This interposition is transparent leaving the two
                                compromised components unaware of the potential corruption or leakage of their
                                communications. The potential for Man-in-the-Middle attacks yields an implicit lack of
                                trust in communication or identify between two components.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading327"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse327" aria-expanded="true" aria-controls="collapse327">Weakness: Improper Server's Identity Validation <span>[CWE-287]</span></button></h5></div><div id="collapse327" class="collapse" aria-labelledby="heading327" data-parent="#weaknesses"><div class="card-body">The software does not validate, or incorrectly validates, the server's identity.
                        If the server's identity is not validated, an attacker could spoof a trusted entity by using a
                        man-in-the-middle (MITM) attack. The software might connect to a malicious host while believing
                        it is a trusted host, or the software might be deceived into accepting spoofed data that appears
                        to originate from a trusted host.

                        One way to perform server authentication is by using X509 certificates over TLS.

                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading325"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse325" aria-expanded="true" aria-controls="collapse325">Countermeasure: Ensure node certificates are rotated as appropriate <span>[D7.8]</span></button></h5></div><div id="collapse325" class="collapse" aria-labelledby="heading325" data-parent="#controls"><div class="card-body">Rotate swarm node certificates as appropriate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker Swarm uses mutual TLS for clustering operations amongst its nodes. Certificate rotation
                        ensures that in an event such as a compromised node or key, it is difficult to impersonate a
                        node. By default, node certificates are rotated every 90 days. You should rotate it more often
                        or as appropriate in your environment.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the below command to set the desired expiry time. For example,&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker swarm update --cert-expiry 48h&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div><div class="card border-success"><div class="card-header " id="heading326"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse326" aria-expanded="true" aria-controls="collapse326">Countermeasure: Ensure CA certificates are rotated as appropriate <span>[D7.9]</span></button></h5></div><div id="collapse326" class="collapse" aria-labelledby="heading326" data-parent="#controls"><div class="card-body">Rotate root CA certificates as appropriate.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Docker Swarm uses mutual TLS for clustering operations amongst its nodes. Certificate rotation
                        ensures that in an event such as compromised node or key, it is difficult to impersonate a node.
                        Node certificates depend upon root CA certificates. For operational security, it is important to
                        rotate these frequently. Currently, root CA certificates are not rotated automatically. You
                        should thus establish a process to rotate it at the desired frequency.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the below command to rotate the certificate.&nbsp;
                        </div>
                        <blockquote>
                        <div>
                        docker swarm ca --rotate&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-primary"><div class="card-header " id="heading343"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse343" aria-expanded="true" aria-controls="collapse343">Risk pattern: Inter-Container Communication <span>[INTER-CONTAINER-COMMUNICATION]</span></button></h5></div><div id="collapse343" class="collapse" aria-labelledby="heading343" data-parent="#components"><div class="card-body">This Risk Pattern contains the recommendations applied when the containers should communicate with each other.<div class="accordion" id="usecases"><div class="card border-black"><div class="card-header " id="heading334"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse334" aria-expanded="true" aria-controls="collapse334">Use case: Authentication and Authorization <span>[AUTHENTICATION AND AUTHORIZATION]</span></button></h5></div><div id="collapse334" class="collapse" aria-labelledby="heading334" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading333"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse333" aria-expanded="true" aria-controls="collapse333">Threat: Attakers gain access without the necessary privileged to the docker connection inter-container <span>[CAPEC-122-DOCKER-CONTAINERS]</span></button></h5></div><div id="collapse333" class="collapse" aria-labelledby="heading333" data-parent="#threats"><div class="card-body">An adversary is able to exploit features of the target that should be reserved for
                                privileged users or administrators but are exposed to use by lower or non-privileged
                                accounts. Access to sensitive information and functionality must be controlled to ensure
                                that only authorized users are able to access these resources. If access control
                                mechanisms are absent or misconfigured, a user may be able to access resources that are
                                intended only for higher level users. An adversary may be able to exploit this to
                                utilize a less trusted account to gain information and perform activities reserved for
                                more trusted accounts. This attack differs from privilege escalation and other privilege
                                stealing attacks in that the adversary never actually escalates their privileges but
                                instead is able to use a lesser degree of privilege to access resources that should be
                                (but are not) reserved for higher privilege accounts. Likewise, the adversary does not
                                exploit trust or subvert systems - all control functionality is working as configured
                                but the configuration does not adequately protect sensitive resources at an appropriate
                                level.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading332"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse332" aria-expanded="true" aria-controls="collapse332">Weakness: Incorrect Default Permissions <span>[CWE-276]</span></button></h5></div><div id="collapse332" class="collapse" aria-labelledby="heading332" data-parent="#weaknesses"><div class="card-body">The software, upon installation, sets incorrect permissions for an object that exposes it to
                        an unintended actor.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading331"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse331" aria-expanded="true" aria-controls="collapse331">Countermeasure: Ensure that only containers which are required to communicate with each other are linked together <span>[D2.1.1]</span></button></h5></div><div id="collapse331" class="collapse" aria-labelledby="heading331" data-parent="#controls"><div class="card-body">By default, all network traffic is allowed between containers on the same host on the default
                        network bridge. If your containers should communicate with each other, you can create a custom
                        network and only join containers that need to communicate to that custom network. Alternatively,
                        link only specific containers together that require communication.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        By default, unrestricted network traffic is enabled between all containers on the same host on
                        the default network bridge. Thus, each container has the potential of reading all packets across
                        the container network on the same host. This might lead to an unintended and unwanted disclosure
                        of information to other containers. Hence, create a custom network and only join containers that
                        need to communicate to that custom network or link only specific containers together that
                        require communication.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        You can follow the Docker documentation to create a custom network and only join containers that
                        need to communicate to that custom network. The --icc parameter only applies to the default
                        docker bridge, if custom networks are used then the approach of segmenting networks should be
                        adopted instead.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Alternatively, follow the Docker documentation and link specific containers using the --link
                        flag.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Note: Docker warns users not to use the --link flag unless absolutely necessary, because it is a
                        legacy Docker feature and it may eventually be removed.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        You have to manage the custom networks.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading338"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse338" aria-expanded="true" aria-controls="collapse338">Use case: General <span>[GENERAL]</span></button></h5></div><div id="collapse338" class="collapse" aria-labelledby="heading338" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading337"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse337" aria-expanded="true" aria-controls="collapse337">Threat: Attackers gain access to the docker container communication by using sensitive data which was found embedded within it <span>[CAPEC-37-CONTAINER-COMMUNICATION]</span></button></h5></div><div id="collapse337" class="collapse" aria-labelledby="heading337" data-parent="#threats"><div class="card-body">An attacker examines a target system to find sensitive data that has been embedded
                                within it. This information can reveal confidential contents, such as account numbers or
                                individual keys/credentials that can be used as an intermediate step in a larger attack.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading336"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse336" aria-expanded="true" aria-controls="collapse336">Weakness: Information Exposure <span>[CWE-200]</span></button></h5></div><div id="collapse336" class="collapse" aria-labelledby="heading336" data-parent="#weaknesses"><div class="card-body">An information exposure is the intentional or unintentional disclosure of information to an
                        actor that is not explicitly authorized to have access to that information.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading335"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse335" aria-expanded="true" aria-controls="collapse335">Countermeasure: Ensure that only containers which are required to communicate with each other are linked together <span>[D2.1.1]</span></button></h5></div><div id="collapse335" class="collapse" aria-labelledby="heading335" data-parent="#controls"><div class="card-body">By default, all network traffic is allowed between containers on the same host on the default
                        network bridge. If your containers should communicate with each other, you can create a custom
                        network and only join containers that need to communicate to that custom network. Alternatively,
                        link only specific containers together that require communication.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        By default, unrestricted network traffic is enabled between all containers on the same host on
                        the default network bridge. Thus, each container has the potential of reading all packets across
                        the container network on the same host. This might lead to an unintended and unwanted disclosure
                        of information to other containers. Hence, create a custom network and only join containers that
                        need to communicate to that custom network or link only specific containers together that
                        require communication.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        You can follow the Docker documentation to create a custom network and only join containers that
                        need to communicate to that custom network. The --icc parameter only applies to the default
                        docker bridge, if custom networks are used then the approach of segmenting networks should be
                        adopted instead.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Alternatively, follow the Docker documentation and link specific containers using the --link
                        flag.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Note: Docker warns users not to use the --link flag unless absolutely necessary, because it is a
                        legacy Docker feature and it may eventually be removed.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        You have to manage the custom networks.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading342"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse342" aria-expanded="true" aria-controls="collapse342">Use case: Networking <span>[NETWORKING]</span></button></h5></div><div id="collapse342" class="collapse" aria-labelledby="heading342" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading341"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse341" aria-expanded="true" aria-controls="collapse341">Threat: Attackers gain access to the Docker container communication by exploiting the vulnerabilities of the network <span>[DOCKER-WIDE-ATTACK-SURFACE-CONTAINER-COMMUNICATION]</span></button></h5></div><div id="collapse341" class="collapse" aria-labelledby="heading341" data-parent="#threats"><div class="card-body">Every point of network interaction is a potential part of the network attack surface
                                having exploitable vulnerabilities.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading340"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse340" aria-expanded="true" aria-controls="collapse340">Weakness: Service is exposed to a wide attack surface <span>[UNRESTRICTED-NETWORK]</span></button></h5></div><div id="collapse340" class="collapse" aria-labelledby="heading340" data-parent="#weaknesses"><div class="card-body">The product is exposed or reachable to an unnecessarily large group of potential attackers. An
                        over-exposure of a component increases the chance of an attacker gaining access to the system
                        through a vulnerability.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading339"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse339" aria-expanded="true" aria-controls="collapse339">Countermeasure: Ensure that only containers which are required to communicate with each other are linked together <span>[D2.1.1]</span></button></h5></div><div id="collapse339" class="collapse" aria-labelledby="heading339" data-parent="#controls"><div class="card-body">By default, all network traffic is allowed between containers on the same host on the default
                        network bridge. If your containers should communicate with each other, you can create a custom
                        network and only join containers that need to communicate to that custom network. Alternatively,
                        link only specific containers together that require communication.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        By default, unrestricted network traffic is enabled between all containers on the same host on
                        the default network bridge. Thus, each container has the potential of reading all packets across
                        the container network on the same host. This might lead to an unintended and unwanted disclosure
                        of information to other containers. Hence, create a custom network and only join containers that
                        need to communicate to that custom network or link only specific containers together that
                        require communication.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        You can follow the Docker documentation to create a custom network and only join containers that
                        need to communicate to that custom network. The --icc parameter only applies to the default
                        docker bridge, if custom networks are used then the approach of segmenting networks should be
                        adopted instead.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Alternatively, follow the Docker documentation and link specific containers using the --link
                        flag.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Note: Docker warns users not to use the --link flag unless absolutely necessary, because it is a
                        legacy Docker feature and it may eventually be removed.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        You have to manage the custom networks.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-primary"><div class="card-header " id="heading356"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse356" aria-expanded="true" aria-controls="collapse356">Risk pattern: Inter-Container Restriction <span>[INTER-CONTAINER-RESTRICTION]</span></button></h5></div><div id="collapse356" class="collapse" aria-labelledby="heading356" data-parent="#components"><div class="card-body">This Risk Pattern contains the recommendations applied when the containers should NOT communicate with each other.<div class="accordion" id="usecases"><div class="card border-black"><div class="card-header " id="heading347"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse347" aria-expanded="true" aria-controls="collapse347">Use case: Authentication and Authorization <span>[AUTHENTICATION AND AUTHORIZATION]</span></button></h5></div><div id="collapse347" class="collapse" aria-labelledby="heading347" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading346"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse346" aria-expanded="true" aria-controls="collapse346">Threat: Attakers gain access without the necessary privileged to the docker connection inter-container <span>[CAPEC-122-DOCKER-CONTAINERS]</span></button></h5></div><div id="collapse346" class="collapse" aria-labelledby="heading346" data-parent="#threats"><div class="card-body">An adversary is able to exploit features of the target that should be reserved for
                                privileged users or administrators but are exposed to use by lower or non-privileged
                                accounts. Access to sensitive information and functionality must be controlled to ensure
                                that only authorized users are able to access these resources. If access control
                                mechanisms are absent or misconfigured, a user may be able to access resources that are
                                intended only for higher level users. An adversary may be able to exploit this to
                                utilize a less trusted account to gain information and perform activities reserved for
                                more trusted accounts. This attack differs from privilege escalation and other privilege
                                stealing attacks in that the adversary never actually escalates their privileges but
                                instead is able to use a lesser degree of privilege to access resources that should be
                                (but are not) reserved for higher privilege accounts. Likewise, the adversary does not
                                exploit trust or subvert systems - all control functionality is working as configured
                                but the configuration does not adequately protect sensitive resources at an appropriate
                                level.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading345"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse345" aria-expanded="true" aria-controls="collapse345">Weakness: Incorrect Default Permissions <span>[CWE-276]</span></button></h5></div><div id="collapse345" class="collapse" aria-labelledby="heading345" data-parent="#weaknesses"><div class="card-body">The software, upon installation, sets incorrect permissions for an object that exposes it to
                        an unintended actor.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading344"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse344" aria-expanded="true" aria-controls="collapse344">Countermeasure: Ensure all network traffic is restricted between containers on the default bridge <span>[D2.1.2]</span></button></h5></div><div id="collapse344" class="collapse" aria-labelledby="heading344" data-parent="#controls"><div class="card-body">By default, all network traffic is allowed between containers on the same host on the default
                        network bridge. If not desired, restrict all inter-container communication.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        By default, unrestricted network traffic is enabled between all containers on the same host on
                        the default network bridge. Thus, each container has the potential of reading all packets across
                        the container network on the same host. This might lead to an unintended and unwanted disclosure
                        of information to other containers. Hence, restrict the inter-container communication on the
                        default network bridge.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the docker in daemon mode and pass --icc=false as an argument. For Example,
                        </div>
                        <blockquote>
                        <div>
                        dockerd --icc=false&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        The inter-container communication would be disabled on the default network bridge. If any
                        communication between containers on the same host is desired in the future, then it needs to be
                        explicitly defined using container linking or alternatively custom networks have to be defined.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading351"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse351" aria-expanded="true" aria-controls="collapse351">Use case: General <span>[GENERAL]</span></button></h5></div><div id="collapse351" class="collapse" aria-labelledby="heading351" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading350"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse350" aria-expanded="true" aria-controls="collapse350">Threat: Attackers gain access to the docker container communication by using sensitive data which was found embedded within it <span>[CAPEC-37-CONTAINER-COMMUNICATION]</span></button></h5></div><div id="collapse350" class="collapse" aria-labelledby="heading350" data-parent="#threats"><div class="card-body">An attacker examines a target system to find sensitive data that has been embedded
                                within it. This information can reveal confidential contents, such as account numbers or
                                individual keys/credentials that can be used as an intermediate step in a larger attack.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading349"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse349" aria-expanded="true" aria-controls="collapse349">Weakness: Information Exposure <span>[CWE-200]</span></button></h5></div><div id="collapse349" class="collapse" aria-labelledby="heading349" data-parent="#weaknesses"><div class="card-body">An information exposure is the intentional or unintentional disclosure of information to an
                        actor that is not explicitly authorized to have access to that information.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading348"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse348" aria-expanded="true" aria-controls="collapse348">Countermeasure: Ensure all network traffic is restricted between containers on the default bridge <span>[D2.1.2]</span></button></h5></div><div id="collapse348" class="collapse" aria-labelledby="heading348" data-parent="#controls"><div class="card-body">By default, all network traffic is allowed between containers on the same host on the default
                        network bridge. If not desired, restrict all inter-container communication.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        By default, unrestricted network traffic is enabled between all containers on the same host on
                        the default network bridge. Thus, each container has the potential of reading all packets across
                        the container network on the same host. This might lead to an unintended and unwanted disclosure
                        of information to other containers. Hence, restrict the inter-container communication on the
                        default network bridge.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the docker in daemon mode and pass --icc=false as an argument. For Example,
                        </div>
                        <blockquote>
                        <div>
                        dockerd --icc=false&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        The inter-container communication would be disabled on the default network bridge. If any
                        communication between containers on the same host is desired in the future, then it needs to be
                        explicitly defined using container linking or alternatively custom networks have to be defined.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-black"><div class="card-header " id="heading355"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse355" aria-expanded="true" aria-controls="collapse355">Use case: Networking <span>[NETWORKING]</span></button></h5></div><div id="collapse355" class="collapse" aria-labelledby="heading355" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading354"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse354" aria-expanded="true" aria-controls="collapse354">Threat: Attackers gain access to the Docker container communication by exploiting the vulnerabilities of the network <span>[DOCKER-WIDE-ATTACK-SURFACE-CONTAINER-COMMUNICATION]</span></button></h5></div><div id="collapse354" class="collapse" aria-labelledby="heading354" data-parent="#threats"><div class="card-body">Every point of network interaction is a potential part of the network attack surface
                                having exploitable vulnerabilities.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading353"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse353" aria-expanded="true" aria-controls="collapse353">Weakness: Service is exposed to a wide attack surface <span>[UNRESTRICTED-NETWORK]</span></button></h5></div><div id="collapse353" class="collapse" aria-labelledby="heading353" data-parent="#weaknesses"><div class="card-body">The product is exposed or reachable to an unnecessarily large group of potential attackers. An
                        over-exposure of a component increases the chance of an attacker gaining access to the system
                        through a vulnerability.
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading352"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse352" aria-expanded="true" aria-controls="collapse352">Countermeasure: Ensure all network traffic is restricted between containers on the default bridge <span>[D2.1.2]</span></button></h5></div><div id="collapse352" class="collapse" aria-labelledby="heading352" data-parent="#controls"><div class="card-body">By default, all network traffic is allowed between containers on the same host on the default
                        network bridge. If not desired, restrict all inter-container communication.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        By default, unrestricted network traffic is enabled between all containers on the same host on
                        the default network bridge. Thus, each container has the potential of reading all packets across
                        the container network on the same host. This might lead to an unintended and unwanted disclosure
                        of information to other containers. Hence, restrict the inter-container communication on the
                        default network bridge.
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        Run the docker in daemon mode and pass --icc=false as an argument. For Example,
                        </div>
                        <blockquote>
                        <div>
                        dockerd --icc=false&nbsp;
                        </div>
                        </blockquote>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Impact:&nbsp;</b>
                        </div>
                        <div>
                        The inter-container communication would be disabled on the default network bridge. If any
                        communication between containers on the same host is desired in the future, then it needs to be
                        explicitly defined using container linking or alternatively custom networks have to be defined.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div class="card border-primary"><div class="card-header " id="heading361"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse361" aria-expanded="true" aria-controls="collapse361">Risk pattern: Third Party/Public Repositories <span>[THIRD-PARTY-PUBLIC-REPOSITORIES]</span></button></h5></div><div id="collapse361" class="collapse" aria-labelledby="heading361" data-parent="#components"><div class="card-body">This Risk Pattern contains the recommendations applied when container images are from a third party/public repository.<div class="accordion" id="usecases"><div class="card border-black"><div class="card-header " id="heading360"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse360" aria-expanded="true" aria-controls="collapse360">Use case: General <span>[GENERAL]</span></button></h5></div><div id="collapse360" class="collapse" aria-labelledby="heading360" data-parent="#usecases"><div class="card-body"><div class="accordion" id="threats"><div class="card border-danger"><div class="card-header " id="heading359"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse359" aria-expanded="true" aria-controls="collapse359">Threat: Attackers gain access to the sensitive data through injecting code in the repositories <span>[OWASP A1:2017]</span></button></h5></div><div id="collapse359" class="collapse" aria-labelledby="heading359" data-parent="#threats"><div class="card-body">Almost any source of data can be an injection vector: environment variables,
                                parameters, external and internal web services, and all types of users. Injection flaws
                                occur when an attacker can send hostile data to an interpreter.
                            <div class="accordion" id="weaknesses"><div class="card border-warning"><div class="card-header " id="heading358"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse358" aria-expanded="true" aria-controls="collapse358">Weakness: Third party libraries contain security weaknesses <span>[CWE-937]</span></button></h5></div><div id="collapse358" class="collapse" aria-labelledby="heading358" data-parent="#weaknesses"><div class="card-body">In theory, it ought to be easy to figure out if you are currently using any vulnerable
                        components or libraries. Unfortunately, vulnerability reports for commercial or open source
                        software do not always specify exactly which versions of a component are vulnerable in a
                        standard, searchable way. Further, not all libraries use an understandable version numbering
                        system. Worst of all, not all vulnerabilities are reported to a central clearing house that is
                        easy to search, although sites like CVE and NVD are becoming easier to search.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        Determining if you are vulnerable requires searching these databases, as well as keeping abreast
                        of project mailing lists and announcements for anything that might be a vulnerability. If one of
                        your components does have a vulnerability, you should carefully evaluate whether you are
                        actually vulnerable by checking to see if your code uses the part of the component with the
                        vulnerability and whether the flaw could result in an impact you care about.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        Component vulnerabilities can cause almost any type of risk imaginable, ranging from the trivial
                        to sophisticated malware designed to target a specific organization. Components almost always
                        run with the full privilege of the application, so flaws in any component can be serious.
                        </div>
                    <div class="accordion" id="controls"><div class="card border-success"><div class="card-header " id="heading357"\><h5 class="mb-0"><button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse357" aria-expanded="true" aria-controls="collapse357">Countermeasure: Ensure that containers use trusted base images <span>[D4.2]</span></button></h5></div><div id="collapse357" class="collapse" aria-labelledby="heading357" data-parent="#controls"><div class="card-body">Ensure that the container image is written either from scratch or is based on another
                        established and trusted base image downloaded over a secure channel.&nbsp;
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Rationale:</b>&nbsp;
                        </div>
                        <div>
                        Official repositories are Docker images curated and optimized by the Docker community or the
                        vendor. There could be other potentially unsafe public repositories. Caution should be exercised
                        when obtaining container images from Docker and third parties and how they will be used for your
                        organization's data.&nbsp;
                        </div>
                        <div>
                        <br />
                        </div>
                        <div>
                        <b>Remediation:</b>&nbsp;
                        </div>
                        <div>
                        <ol>
                        <li>Configure and use Docker Content trust.&nbsp;</li>
                        <li>Inspect Docker image history to evaluate their risk to operate on your network.&nbsp;</li>
                        <li>Scan Docker images for vulnerabilities in their dependencies and configurations they
                        will impose upon your network.&nbsp;</li>
                        </ol>
                        <b>Impact:</b>&nbsp;
                        </div>
                        <div>
                        None.
                        </div>
                    </div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>